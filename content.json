{"meta":{"title":"OdinSam's blogs-一个热爱编程性格开朗的Coder","subtitle":"","description":"OdinSam的博客，记录和分享.Net Core后端框架、React、Vue等前端框架在工作和学习过程中使用的点点滴滴。坚定的.Net Core拥护者，性格开朗喜欢折腾，爱写代码也喜欢看老电影，老电视剧，听老歌。并将这些作为一种生活乐趣。","author":"OdinSam","url":"https://www.odinsam.com","root":"/"},"pages":[{"title":"404","date":"2019-11-23T13:10:10.000Z","updated":"2021-07-02T16:57:53.465Z","comments":true,"path":"404.html","permalink":"https://www.odinsam.com/404.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-07-02T17:07:05.129Z","updated":"2021-07-02T17:07:05.129Z","comments":false,"path":"/404.html","permalink":"https://www.odinsam.com/404.html","excerpt":"","text":"404"},{"title":"关于","date":"2021-06-30T13:44:29.643Z","updated":"2021-05-25T13:01:43.352Z","comments":false,"path":"about/index.html","permalink":"https://www.odinsam.com/about/index.html","excerpt":"","text":"一个热爱编程性格开朗的 Coder，喜欢折腾，爱写代码，并将它作为一种生活乐趣，标准技术宅一个。也喜欢看老电影，老电视剧，有精力的老年 Coder。 sequenceDiagram participant z as today participant l as tomorrow loop day after day z->>l: coding？ l-->>z: yeah,happy coding activate z Note left of z: think await alt not yet coding z-xl: no else conding z-xl: happy end opt find happy l-->z: Coding makes us happy Work end end"},{"title":"书单","date":"2021-06-30T13:44:29.644Z","updated":"2021-05-23T16:01:47.549Z","comments":false,"path":"books/index.html","permalink":"https://www.odinsam.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-06-30T13:44:29.646Z","updated":"2021-05-23T16:01:47.549Z","comments":false,"path":"categories/index.html","permalink":"https://www.odinsam.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-06-30T13:44:29.647Z","updated":"2021-05-23T16:01:47.550Z","comments":true,"path":"links/index.html","permalink":"https://www.odinsam.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-06-30T13:44:29.648Z","updated":"2021-05-23T16:01:47.551Z","comments":false,"path":"repository/index.html","permalink":"https://www.odinsam.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-30T13:44:29.649Z","updated":"2021-05-23T16:01:47.552Z","comments":false,"path":"tags/index.html","permalink":"https://www.odinsam.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue2.0 - 06. 数据代理-Object.defineProperty","slug":"Vue2-0-06-数据代理-Object-defineProperty","date":"2022-10-14T18:12:00.000Z","updated":"2022-10-14T19:05:15.892Z","comments":true,"path":"/articles/7c3d.html","link":"","permalink":"https://www.odinsam.com/articles/7c3d.html","excerpt":"【Vue2.0】学习系列 第6章: 数据代理-Object.defineProperty","text":"【Vue2.0】学习系列 第6章: 数据代理-Object.defineProperty Object.defineProperty的基本用法 1234567891011121314151617let user=&#123;name:&#x27;odinsam&#x27;,sex:&#x27;男&#x27;&#125;Object.defineProperty(user,&#x27;age&#x27;,&#123;value:20,enumerable:true,writable:true,configurable:true&#125;)&#123;name: &#x27;odinsam&#x27;, sex: &#x27;男&#x27;, age: 20&#125;for(let key in user)&#123; console.log(`user的key-value key:$&#123;key&#125; value:$&#123;user[key]&#125;`) &#125;// user的key-value key:name value:odinsam// user的key-value key:sex value:男//user的key-value key:age value:20user.age=3030user.age30delete user.agetruefor(let key in user)&#123; console.log(`user的key-value key:$&#123;key&#125; value:$&#123;user[key]&#125;`) &#125;user的key-value key:name value:odinsamuser的key-value key:sex value:男 Object.defineProperty的 get set 用法 123456789101112131415161718let number = 20let user=&#123;name:&#x27;odinsam&#x27;,sex:&#x27;男&#x27;&#125;Object.defineProperty(user,&#x27;age&#x27;,&#123; get()&#123; return number &#125; set(value)&#123; number=value &#125; &#125;)&#123;name: &#x27;odinsam&#x27;, sex: &#x27;男&#x27;, age: 20&#125;for(let key in user)&#123; console.log(`user的key-value key:$&#123;key&#125; value:$&#123;user[key]&#125;`) &#125;// user的key-value key:name value:odinsam// user的key-value key:sex value:男//user的key-value key:age value:20user.age=3030user.age30delete user.agetruefor(let key in user)&#123; console.log(`user的key-value key:$&#123;key&#125; value:$&#123;user[key]&#125;`) &#125;user的key-value key:name value:odinsamuser的key-value key:sex value:男 原始的数据代理 obj2通过数据代理获取obj1的x属性 1234567891011//原始的数据代理let obj1 = &#123; x: 10 &#125;;let obj2 = &#123; y: 10 &#125;;Object.defineProperty(obj2, &#x27;x&#x27;, &#123; get() &#123; return obj1.x; &#125;, set(value) &#123; obj1.x = value; &#125;&#125;); vue中的数据代理 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;06.数据代理-Object.defineProperty&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;script&gt; /* vue中的数据代理 1. 通过vm对象来代理data对象中属性的操作 getter setter 2. 更加方便的操作data中的数据 3. 通过Object.defineProperty()把data对象中所有的属性添加到vm上 4. 为每一个添加到wm上的属性都指定 getter、setter方法 5. 在getter、setter内部操作data中对应的属性 6. vm._data中的属性不是数据代理而是数据劫持，通过数据劫持监听数据改变从而render页面 */ &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"原型链","slug":"原型链","permalink":"https://www.odinsam.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}],"author":"OdinSam"},{"title":"Vue2.0 - 05. mvvm模型","slug":"Vue2-0-05-mvvm模型","date":"2022-10-14T17:52:00.000Z","updated":"2022-10-14T18:19:05.587Z","comments":true,"path":"/articles/a38e.html","link":"","permalink":"https://www.odinsam.com/articles/a38e.html","excerpt":"【Vue2.0】学习系列 第5章: mvvm模型","text":"【Vue2.0】学习系列 第5章: mvvm模型 MVVM 解释123M - 模型 即 data 中的数据V - 视图 即 模板 VM - viewModel 即 vue的实例对象 data bindings 数据以对象的形式存储在data中，通过databindings将数据绑定在 view 页面中 view页面改变，通过 dom listeners 修改 data中的数据 data中所有的属性，最后都出现在vm立 vm所有的属性即vue原型的属性，在vue模板中都可以直接使用","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"Vue2.0 - 04. el与data的两种写法","slug":"Vue2-0-04-el与data","date":"2022-10-14T17:26:00.000Z","updated":"2022-10-14T18:19:00.807Z","comments":true,"path":"/articles/3899.html","link":"","permalink":"https://www.odinsam.com/articles/3899.html","excerpt":"【Vue2.0】学习系列 第4章: el 与 data的两种写法","text":"【Vue2.0】学习系列 第4章: el 与 data的两种写法 重点注意: 由vue管理的函数(例如 data 的函数式写法)，一定不能写箭头函数，否则this指向的实例就会是window对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;04.el与data的两种写法&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;通过vue的实例对象挂载数据:&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; /* el 与 data 有两种写法 el 的两种写法: 1. 在new vue(&#123; el:&#x27;#root&#x27; &#125;) 时同时指定el的容器 2. 在创建vue后 通过实例对象指定el的值 vm.$mount(&#x27;#root&#x27;) data 的两种写法 1. 通过对象的形式 data:&#123; title:&#x27;hello vue&#x27; &#125; 2. 使用函数的形式 data() &#123; return &#123; title:&#x27;hello vue&#x27; &#125; &#125; 后期使用函数式组件时，data必须使用函数形式 重点注意: 由vue管理的函数(例如 data 的函数式写法)，一定不能写箭头函数，否则this指向的实例就会是window对象 */ Vue.config.productionTip = false; // 写法1 const vm = new Vue(&#123; // el: &#x27;#root&#x27;, // 直接指定vue对应的容器 // 使用data对象形式 // data: &#123; // title: &#x27;hello vue&#x27;, // url: &#x27;http://www.odinsam.com&#x27; // &#125; // 使用函数式 data() &#123; return &#123; title: &#x27;hello vue !!&#x27; &#125;; &#125; &#125;); // 写法2 vm.$mount(&#x27;#root&#x27;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"Vue2.0 - 03. 数据绑定","slug":"Vue2-0-03-数据绑定语法","date":"2022-10-14T16:43:00.000Z","updated":"2022-10-14T18:18:07.813Z","comments":true,"path":"/articles/f50b.html","link":"","permalink":"https://www.odinsam.com/articles/f50b.html","excerpt":"【Vue2.0】学习系列 第3章: vue 的数据绑定","text":"【Vue2.0】学习系列 第3章: vue 的数据绑定 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;03.数据绑定&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- vue有单向数据绑定和双向数据绑定两种 1. 单向绑定 v-bind 数据只能从data流向页面 2. 双向绑定 v-model 数据不仅可以从data流向页面，当页面发生改变同样可以修改data的内容 备注： 1. 双向绑定一般都应用在表单元素 如 input select 等 2. v-model:value 可以简写为 v-model 因为 v-model默认收集的就是valuede值 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;单向数据绑定 : v-bind 的简写&lt;/h2&gt; &lt;input type=&quot;text&quot; :value=&quot;title&quot; /&gt; &lt;h2&gt;双向数据绑定 v-model&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;title&quot; /&gt; &lt;!-- 如下代码是错误的： [Vue warn]: Failed to resolve directive: modle --&gt; &lt;h2 v-modle:value=&quot;title&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; title: &#x27;hello vue&#x27;, url: &#x27;http://www.odinsam.com&#x27; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 效果如图","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://www.odinsam.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"}],"author":"OdinSam"},{"title":"Vue2.0 - 02. 模板语法","slug":"Vue2-0-01-模板语法","date":"2022-10-14T16:26:00.000Z","updated":"2022-10-14T18:18:55.279Z","comments":true,"path":"/articles/1660.html","link":"","permalink":"https://www.odinsam.com/articles/1660.html","excerpt":"【Vue2.0】学习系列 第2章: vue 的模板语法.","text":"【Vue2.0】学习系列 第2章: vue 的模板语法. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;02.模板语法&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--模板语法有插值语法和指令语法--&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 插值语法一般用于显示标签的内容 --&gt; &lt;h1&gt;插值语法: &#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;指令语法&lt;/h2&gt; &lt;!-- 指令语法常用语解析标签 包括标签属性、标签内容、标签事件 v-bind绑定 1. 将 “”中的内容即 url 当做js表达式， url在data中找到对应的链接，所以绑定在a标签的href属性上 2. v-bind 可以简写为 : 3. v-bind 仅可以绑定数据，单向数据绑定（从data中获取数据绑定到页面中），页面中的数据发生变化，无法修改data中的内容 --&gt; &lt;a v-bind:href=&quot;url&quot;&gt;odinsam 的博客&lt;/a&gt; &lt;br /&gt; &lt;a :href=&quot;Date.now()&quot;&gt;当前时间&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; title: &#x27;hello vue&#x27;, url: &#x27;http://www.odinsam.com&#x27; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"Vue2.0 - 01. hello vue","slug":"Vue-01-hello-vue","date":"2022-10-14T16:18:00.000Z","updated":"2022-10-14T18:19:45.067Z","comments":true,"path":"/articles/deab.html","link":"","permalink":"https://www.odinsam.com/articles/deab.html","excerpt":"【Vue2.0】学习系列 第2章: 初始 vue.","text":"【Vue2.0】学习系列 第2章: 初始 vue. 01. hello vue 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;01.hello案例&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 需要创建vue实例，且传入一个配置对象 2. root容器中的代码需要符合html规范，只是加入了vue语法 3. root容器立的代码被称为 vue 模板 4. 插值语法 &#123;&#123; $1 &#125;&#125; 中的内容需要是 js 表达式，且内容可以直接读取到配置的data中所有的属性 5. vue实例和容器需要时一一对应 6. 一旦 data 中的数据发生变化，页面会自动更新 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello vue&lt;/h1&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;!--当前语法为 vue 的插值语法--&gt; &lt;h2&gt;&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; //阻止 vue 在启动时生成生产提示 Vue.config.productionTip = false; //创建vue实例 const vm = new Vue(&#123; //指定当前vue实例为那个容器服务， css选择器选择对应容器 el: &#x27;#root&#x27;, //定义对应的数据，可以在对应的容器 el 中使用 data: &#123; name: &#x27;odinsam&#x27;, age: 20 &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"Vue2.0 系列","slug":"Vue2-0-系列","date":"2022-10-14T16:16:00.000Z","updated":"2022-10-14T18:18:48.030Z","comments":true,"path":"/articles/da3d.html","link":"","permalink":"https://www.odinsam.com/articles/da3d.html","excerpt":"vue 学习系列的目录.","text":"vue 学习系列的目录. 目录 [01] hello vue [02] 模板语法 [03] 数据绑定 [04] el与data的两种写法 [05] mvvm模型 [06] 数据代理-Object.defineProperty","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"OdinLog 组件","slug":"dinLog-组件","date":"2022-07-03T10:37:10.000Z","updated":"2022-07-05T13:17:00.246Z","comments":true,"path":"/articles/86b2.html","link":"","permalink":"https://www.odinsam.com/articles/86b2.html","excerpt":"自定义简单的一个日志组件。可以存储本地文件，也可以存储到数据库(目前仅支持 mysql 和 sqlServer 数据库)。后期扩展和ELK结合。具体源代码在github可以查看。","text":"自定义简单的一个日志组件。可以存储本地文件，也可以存储到数据库(目前仅支持 mysql 和 sqlServer 数据库)。后期扩展和ELK结合。具体源代码在github可以查看。 1. 简介 组件可以生成对应日志文件( bin 目录下)，可用于winform、webapi项目。如果存储在本地，以日志级别 Info、Debug、Error生成文件夹，内部以 yyyy-MM-dd 格式生成文件夹。日志文件以数字标识，如果单个日志文件大小超过5M则另生成日志文件。 2. 组件使用 可以使用依赖注入，也可以在配置Config后直接使用 依赖注入1234builder.Services.AddOdinSingletonOdinLogs(opt=&gt; opt.Config=new LogConfig &#123; LogSaveType=new EnumLogSaveType[]&#123;EnumLogSaveType.All&#125;, ConnectionString = &quot;server=xxxx;Database=xxxx;Uid=xxx;Pwd=xxx;&quot;&#125;); 直接配置123OdinLog.Core.OdinLogs = new OdinLogs(new LogConfig &#123; LogSaveType=new EnumLogSaveType[]&#123;EnumLogSaveType.All&#125;, ConnectionString = &quot;server=xxxx;Database=xxxx;Uid=xxx;Pwd=xxx;&quot;&#125;);) 调用123456OdinLogs.Info(new LogInfo()&#123;LogContent = &quot;log info test&quot;,LogMark=&quot;log mark&quot;, &#125;); OdinLogs.Error( new ExceptionLog()&#123; LogContent = &quot;log exception test&quot;, LogMark=&quot;log mark&quot;, LogException = new Exception(&quot;custom exceptioni&quot;)&#125;); 具体配置参看 LogConfig 结构 3. 存储表结构 https://github.com/odinsam/OdinLog/tree/master/OdinLog/doc/DDL/scripts 4. 文件夹结构、文件内容格式如下： 1234567891011-- logs --Info -- 2022-06-01 0.txt 1.txt --Debug -- 2022-06-01 0.txt --Error -- 2022-06-01 0.txt Info、Debug 文件内容格式如下: 123456【 LogId 】: 766c769d349d494daf82fca503666d5d 【 Log Level 】: Info 【 LogTime 】: 2022-07-03 17:59:44 【 LogContent 】:log info test**************************************************************************************************** Error 文件内容格式如下: 1234567891011121314151617181920【 LogId 】: 57c2978db92a44959e613f7a1e733d8b 【 Log Level 】: Error 【 LogTime 】: 2022-07-03 18:10:51 【 Exception Message 】: custom exceptioni【 Exception Info 】: &#123; &quot;ClassName&quot;: &quot;System.Exception&quot;, &quot;Message&quot;: &quot;custom exceptioni&quot;, &quot;Data&quot;: null, &quot;InnerException&quot;: null, &quot;HelpURL&quot;: null, &quot;StackTraceString&quot;: null, &quot;RemoteStackTraceString&quot;: null, &quot;RemoteStackIndex&quot;: 0, &quot;ExceptionMethod&quot;: null, &quot;HResult&quot;: -2146233088, &quot;Source&quot;: null, &quot;WatsonBuckets&quot;: null&#125;**************************************************************************************************** 具体的代码在 GitHub","categories":[],"tags":[],"author":"OdinSam"},{"title":"mysql8 远程连接解决办法","slug":"mysql8-远程连接解决办法","date":"2022-06-30T07:41:00.000Z","updated":"2022-06-30T07:43:43.878Z","comments":true,"path":"/articles/8b92.html","link":"","permalink":"https://www.odinsam.com/articles/8b92.html","excerpt":"","text":"123grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; ;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;flush privileges;","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.odinsam.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.odinsam.com/tags/mysql/"}],"author":"OdinSam"},{"title":"ApiLinkMonitor 单服务链路追踪框架","slug":"ApiLinkMonitor-单服务链路追踪框架","date":"2021-07-24T12:01:00.000Z","updated":"2021-07-24T12:07:26.510Z","comments":true,"path":"/articles/5b4d.html","link":"","permalink":"https://www.odinsam.com/articles/5b4d.html","excerpt":"在平时的开发中，虽然我们有日志信息、报错信息等等，但是我们依然在某些时候需要查看项目中方法调用的来龙去脉，这种信息一般叫做链路信息。这里介绍一个单服务用于中小型项目的链路追踪框架。","text":"在平时的开发中，虽然我们有日志信息、报错信息等等，但是我们依然在某些时候需要查看项目中方法调用的来龙去脉，这种信息一般叫做链路信息。这里介绍一个单服务用于中小型项目的链路追踪框架。 服务调用链路监控框架 简介 项目基于 OdinInjectCore 和 SnowFlake 框架开发，使用 .net core 中间件实现，主要用到了 AspectCore.Core 第三方框架为底层服务类方法调用的链路监控。监控的项目调用的链路信息入库 mongo，所以需要搭配 mongo 一起使用. 并且 使用 1234567891011121314// 注入链路监控services .AddSingletonSnowFlake(dataCenterId, workerId) .AddOdinTransientMongoDb( opt =&gt; &#123; opt.ConnectionString = mongoConnection; opt.DbName = databaseName; &#125;) .AddOdinTransientInject&lt;IOdinApiLinkMonitor&gt;();services.ConfigureDynamicProxy(config =&gt; &#123; // ~ 使用通配符的特定全局拦截器 config.Interceptors.AddTyped&lt;OdinAspectCoreInterceptorAttribute&gt;(Predicates.ForService(&quot;*Service&quot;)); &#125;); 链路数据 controller 调用的 service 类需要以 Service 结尾,例如 接口 ITestService 和 实现类 TestService,controller 的 api 方法被调用后生成链路数据. 所有数据均进入 mongo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&#123; // 链路的 雪花Id，本次链路唯一 &quot;Id&quot;: 206324387228553216, // 链路 当前的雪花Id &quot;CurrentId&quot;: 206324387245330432, // 链路状态 &quot;LinkStatusEnum&quot;: 0, // 链路状态描述 start 表示本次链路开始 &quot;LinkStatusStr&quot;: &quot;Start&quot;, // 上层链路雪花Id 0代表没有上层链路 &quot;LinkPrevious&quot;: 0, // 链路调用返回的状态 &quot;InvokerReturnStatusEnum&quot;: 0, // 链路调用返回的状态描述 &quot;InvokerReturnStatusStr&quot;: null, // 下级链路雪花Id &quot;LinkNext&quot;: 206324387245330433, // 链路耗时 &quot;ElapsedTime&quot;: null, // 链路调用的完整类名 &quot;InvokerClassFullName&quot;: null, // 链路调用的类名 &quot;InvokerClassName&quot;: null, // 调用的方法名 &quot;InvokerMethodName&quot;: null, // 本次链路的需要 从小到大排序 &quot;LinkSort&quot;: 0&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324394790883328, &quot;LinkStatusEnum&quot;: 1, // 链路状态描述 Invoker 表示链路调用中 &quot;LinkStatusStr&quot;: &quot;Invoker&quot;, // 与上一层链路的 LinkNext 对应 &quot;LinkPrevious&quot;: 206324387245330433, &quot;InvokerReturnStatusEnum&quot;: 0, &quot;InvokerReturnStatusStr&quot;: null, &quot;LinkNext&quot;: 206324394790883329, &quot;ElapsedTime&quot;: null, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.ITestService&quot;, &quot;InvokerClassName&quot;: &quot;ITestService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 1&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324394962849792, &quot;LinkStatusEnum&quot;: 1, &quot;LinkStatusStr&quot;: &quot;Invoker&quot;, &quot;LinkPrevious&quot;: 206324394790883329, &quot;InvokerReturnStatusEnum&quot;: 0, &quot;InvokerReturnStatusStr&quot;: null, &quot;LinkNext&quot;: 206324394962849793, &quot;ElapsedTime&quot;: null, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.IInerService&quot;, &quot;InvokerClassName&quot;: &quot;IInerService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 2&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324395122233344, &quot;LinkStatusEnum&quot;: 1, &quot;LinkStatusStr&quot;: &quot;Invoker&quot;, &quot;LinkPrevious&quot;: 206324394962849793, &quot;InvokerReturnStatusEnum&quot;: 0, &quot;InvokerReturnStatusStr&quot;: null, &quot;LinkNext&quot;: 206324395122233345, &quot;ElapsedTime&quot;: null, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.ITTService&quot;, &quot;InvokerClassName&quot;: &quot;ITTService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 3&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324395277422592, &quot;LinkStatusEnum&quot;: 3, // 链路状态描述 ToEndReturn 表示链路调用返回 &quot;LinkStatusStr&quot;: &quot;ToEndReturn&quot;, &quot;LinkPrevious&quot;: 206324395122233345, &quot;InvokerReturnStatusEnum&quot;: 2, // 链路调用返回的状态描述 CatchReturn 表示调用出现异常 但是被catch捕获 &quot;InvokerReturnStatusStr&quot;: &quot;CatchReturn&quot;, &quot;LinkNext&quot;: 206324395277422593, &quot;ElapsedTime&quot;: 37, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.ITTService&quot;, &quot;InvokerClassName&quot;: &quot;ITTService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 4&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324395520692224, &quot;LinkStatusEnum&quot;: 3, &quot;LinkStatusStr&quot;: &quot;ToEndReturn&quot;, &quot;LinkPrevious&quot;: 206324395277422593, &quot;InvokerReturnStatusEnum&quot;: 2, &quot;InvokerReturnStatusStr&quot;: &quot;CatchReturn&quot;, &quot;LinkNext&quot;: 206324395520692225, &quot;ElapsedTime&quot;: 133, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.IInerService&quot;, &quot;InvokerClassName&quot;: &quot;IInerService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 5&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324395667492864, &quot;LinkStatusEnum&quot;: 3, &quot;LinkStatusStr&quot;: &quot;ToEndReturn&quot;, &quot;LinkPrevious&quot;: 206324395520692225, &quot;InvokerReturnStatusEnum&quot;: 2, &quot;InvokerReturnStatusStr&quot;: &quot;CatchReturn&quot;, &quot;LinkNext&quot;: 206324395667492865, &quot;ElapsedTime&quot;: 210, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.ITestService&quot;, &quot;InvokerClassName&quot;: &quot;ITestService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 6&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324396925784064, &quot;LinkStatusEnum&quot;: 2, // 链路状态描述 Over 表示本次链路调用结束 &quot;LinkStatusStr&quot;: &quot;Over&quot;, &quot;LinkPrevious&quot;: 206324395667492865, &quot;InvokerReturnStatusEnum&quot;: 1, // 调用成功结束 &quot;InvokerReturnStatusStr&quot;: &quot;Success&quot;, &quot;LinkNext&quot;: 0, // 本次调用 2558 ms &quot;ElapsedTime&quot;: 2558, &quot;InvokerClassFullName&quot;: null, &quot;InvokerClassName&quot;: null, &quot;InvokerMethodName&quot;: null, &quot;LinkSort&quot;: 7&#125; 解析 通过链路数据得出结论： 本次 api 调用： 首先 调用 OdinCore.Services.InterfaceServices.ITestService 类的 show 方法,方法内部调用 OdinCore.Services.InterfaceServices.IInerService 类的 show 方法， 然后又调用 OdinCore.Services.InterfaceServices.ITTService 类的 show 方法，结果调用出错，但是被 catch 捕获最后返回。 swagger 调用返回信息如下: 1234567891011121314151617181920&#123; &quot;SnowFlakeId&quot;: &quot;206324387228553216&quot;, &quot;Data&quot;: &#123; &quot;ClassName&quot;: &quot;System.Exception&quot;, &quot;Message&quot;: &quot;ttservice throw&quot;, &quot;Data&quot;: null, &quot;InnerException&quot;: null, &quot;HelpURL&quot;: null, &quot;StackTraceString&quot;: &quot; at OdinPlugs.OdinMvcCore.OdinFilter.ApiInvokerFilterAttribute.OnActionExecuted(ActionExecutedContext context) in /Users/odin/workSpace/github/odinmaf/OdinPlugs/OdinMvcCore/OdinFilter/ApiInvokFilterAttribute.cs:line 109\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeNextActionFilterAsync()\\n--- End of stack trace from previous location ---\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeInnerFilterAsync()\\n--- End of stack trace from previous location ---\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeNextExceptionFilterAsync&gt;g__Awaited|25_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ExceptionContextSealed context)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeNextResourceFilter()\\n--- End of stack trace from previous location ---\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ResourceExecutedContextSealed context)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeFilterPipelineAsync()\\n--- End of stack trace from previous location ---\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Logged|17_1(ResourceInvoker invoker)\\n at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at OdinPlugs.ApiLinkMonitor.OdinMiddleware.OdinExceptionMiddleware.Invoke(HttpContext context) in /Users/odin/workSpace/github/odinmaf/OdinPlugs.ApiLinkMonitor/OdinMiddleware/OdinExceptionMiddleware.cs:line 34&quot;, &quot;RemoteStackTraceString&quot;: null, &quot;RemoteStackIndex&quot;: 0, &quot;ExceptionMethod&quot;: null, &quot;HResult&quot;: -2146233088, &quot;Source&quot;: &quot;AspectCore.Core&quot;, &quot;WatsonBuckets&quot;: null &#125;, &quot;StatusCode&quot;: &quot;sys-error&quot;, &quot;ErrorMessage&quot;: &quot;系统异常，请联系管理员&quot;, &quot;Message&quot;: &quot;系统异常:[sys-error]&quot;&#125; 通过相同的雪花 Id 最后会清晰的分析出整个调用过程中的过程，并且如果能够结合 OdinPlugs 框架,可以监控到 controller 中 api 的调用记录，包括入参、时间、返回信息等会更加详细。 具体的代码在 GitHub","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":"链路追踪","slug":"链路追踪","permalink":"https://www.odinsam.com/tags/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"},{"name":"ApiLinkMonitor","slug":"ApiLinkMonitor","permalink":"https://www.odinsam.com/tags/ApiLinkMonitor/"}],"author":"OdinSam"},{"title":"利用BackgroundService封装后台服务","slug":"用BackgroundService封装后台服务","date":"2021-07-22T15:21:00.000Z","updated":"2021-07-24T11:59:28.373Z","comments":true,"path":"/articles/c075.html","link":"","permalink":"https://www.odinsam.com/articles/c075.html","excerpt":"在之前的文章 使用 BackgroundService 类在微服务中实现后台任务 中有介绍到如何利用 BackgroundService 来实现后台服务，这里我们依旧利用 BackgroundService 来进行类似 hangfire 的封装。","text":"在之前的文章 使用 BackgroundService 类在微服务中实现后台任务 中有介绍到如何利用 BackgroundService 来实现后台服务，这里我们依旧利用 BackgroundService 来进行类似 hangfire 的封装。 OdinPlugs.OdinHostedService 使用方法 1.1 后台任务 - 普通任务，立即执行，只执行一次 123456789services.AddOdinBgServiceNomalJob(opt =&gt;&#123; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - Nomal - Job - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;;&#125;); 1.2 后台任务 - 延迟调用，只执行一次 12345678910services.AddOdinBgServiceScheduleJob(opt =&gt;&#123; opt.DueTime = 5000; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - ScheduleJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;;&#125;); 1.3 后台任务 - 循环任务执行：重复执行的任务，使用常见的时间循环模式 12345678910services.AddOdinBgServiceScheduleJob(opt =&gt;&#123; opt.DueTime = 5000; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - ScheduleJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;;&#125;); 1.4 后台任务 - 循环任务执行：重复执行的任务(任务执行完后继续自动执行) 12345678910services.AddOdinBgServiceLoopJob(opt =&gt;&#123; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - LoopJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif Thread.Sleep(1000); &#125;;&#125;); 1.5 后台任务 - 自定义任务 1234567891011121314151617181920212223242526services.AddOdinBgServiceJob(opt =&gt;&#123; Timer timer = null; void worker(object state) &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125; opt.StartAsyncAction = () =&gt; &#123; timer = new Timer(worker, null, 0, 2000); &#125;; opt.ExecuteAsyncAction = () =&gt; &#123; &#125;; opt.StopAsyncAction = () =&gt; &#123; timer?.Change(Timeout.Infinite, 0); &#125;; opt.DisposeAction = () =&gt; &#123; timer?.Dispose(); &#125;;&#125;); 1.6 后台任务 - 多任务执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768services .AddOdinBgServiceJob(opt =&gt; &#123; Timer timer = null; void worker(object state) &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125; opt.StartAsyncAction = () =&gt; &#123; timer = new Timer(worker, null, 0, 2000); &#125;; opt.ExecuteAsyncAction = () =&gt; &#123; &#125;; opt.StopAsyncAction = () =&gt; &#123; timer?.Change(Timeout.Infinite, 0); &#125;; opt.DisposeAction = () =&gt; &#123; timer?.Dispose(); &#125;; &#125;) .AddOdinBgServiceLoopJob(opt =&gt; &#123; opt.ActionJob = () =&gt; &#123; // new ReceiveRabbitMQHelper().ReceiveMQ(_Options);#if DEBUG Log.Information($&quot;Service:【 BgService - LoopJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif Thread.Sleep(1000); &#125;; &#125;) .AddOdinBgServiceRecurringJob(opt =&gt; &#123; opt.Period = TimeSpan.FromSeconds(1); opt.ActionJob = () =&gt; &#123; // new ReceiveRabbitMQHelper().ReceiveMQ(_Options);#if DEBUG Log.Information($&quot;Service:【 BgService - RecurringJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;; &#125;) .AddOdinBgServiceNomalJob(opt =&gt; &#123; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - Nomal- Job - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;; &#125;) .AddOdinBgServiceScheduleJob(opt =&gt; &#123; opt.DueTime = 5000; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - ScheduleJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;; &#125;); 具体的代码在 GitHub","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"微服务","slug":"微服务","permalink":"https://www.odinsam.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"BackgroundService","slug":"BackgroundService","permalink":"https://www.odinsam.com/tags/BackgroundService/"},{"name":"后台服务","slug":"后台服务","permalink":"https://www.odinsam.com/tags/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/"}],"author":"OdinSam"},{"title":"关于Mapster对象映射器的封装和使用","slug":"关于Mapster对象映射器的封装和使用","date":"2021-07-15T11:41:00.000Z","updated":"2021-07-15T11:53:29.822Z","comments":true,"path":"/articles/9cc8.html","link":"","permalink":"https://www.odinsam.com/articles/9cc8.html","excerpt":"说到 .NET 中的对象映射框架，大部分人的第一映像就是 AutoMapper ，而 Mapster 相对知道的人较少。但其实 Mapster 是一个高性能的对象映射框架，与 AutoMapper 相比，Mapster 在速度和内存占用方面表现更加优秀，可以在只使用1/3内存的情况下获得4倍的性能提升。","text":"说到 .NET 中的对象映射框架，大部分人的第一映像就是 AutoMapper ，而 Mapster 相对知道的人较少。但其实 Mapster 是一个高性能的对象映射框架，与 AutoMapper 相比，Mapster 在速度和内存占用方面表现更加优秀，可以在只使用1/3内存的情况下获得4倍的性能提升。 基础类 12345678910public class Student&#123; public string StuName &#123; get; set; &#125; public string StuAddress &#123; get; set; &#125;&#125;public class Student_DbModel&#123; public string StudentName &#123; get; set; &#125; public string StudentAddress &#123; get; set; &#125;&#125; Startup.cs 注册全局映射Config，也可以不注册 123456789101112// 使用 OdinInjectCore 注入services.AddOdinTypeAdapter(opt =&gt; &#123; opt.ForType&lt;ErrorCode_DbModel, ErrorCode_Model&gt;() .Map(dest =&gt; dest.ShowMessage, src =&gt; src.CodeShowMessage); &#125;);// 使用 .net core DI 注入services.AddSingleton&lt;ITypeAdapterMapster&gt;(provider =&gt; new TypeAdapterMapster(opt =&gt; &#123; opt.ForType&lt;ErrorCode_DbModel, ErrorCode_Model&gt;() .Map(dest =&gt; dest.ShowMessage, src =&gt; src.CodeShowMessage); &#125;)); 使用时获取全局注册Config 1234// 使用 OdinInjectCore 获取 TypeAdapterMapstervar mapsterConfig = OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig();// 使用 .net core 默认 DI 获取 TypeAdapterMapstervar mapsterConfig = services.BuildServiceProvider().GetService&lt;ITypeAdapterMapster&gt;().GetConfig(); 获取数据准备映射转换对象 123// 通过 SqlSugar 获取数据库中的数据List&lt;Student_DbModel&gt; stuDbModels = DbScoped.Sugar.Queryable&lt;Student_DbModel&gt;().ToList();Student_DbModel stuDbModel = stuDbModels[0]; 对象映射转换 123456789101112131415161718192021222324// 使用全局映射配置转换目标对象类型var stu = stuDbModel.OdinTypeAdapterBuilder&lt;Student_DbModel, Student&gt;( OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig() );// 使用自定义映射配置转换目标对象类型// 需要注意的是: 因为没有传全局映射配置, 此时虽然全局配置也有 StudentName 属性映射 StuName 的配置，但是会以当前自定义配置为准var stu = stuDbModel.OdinTypeAdapterBuilder&lt;Student_DbModel, Student&gt;( opt =&gt; &#123; opt.Map(dest =&gt; dest.StuName, src =&gt; src.StudentName); &#125; );// 使用自定义映射+全局映射配置转换目标对象对象类型// 需要注意的是: 因为全局映射配置中有 StudentName 属性映射 StuName 的配置，所以当自定义配置与全局配置都存在时，以全局配置为准var stu = stuDbModel.OdinTypeAdapterBuilder&lt;Student_DbModel, Student&gt;( opt =&gt; &#123; opt.Map(dest =&gt; dest.StuName, src =&gt; src.StudentName); opt.Map(dest =&gt; dest.StuAddress, src =&gt; src.StudentAddress); &#125;, OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig() ); 集合映射转换 将 stuDbModels List&lt;ErrorCode_DbModel&gt; 集合映射转换为 stuLst List 类型的集合 泛型参数说明: 参数名称 说明 Student_DbModel 映射的源类型 Student 转换的目标类型 List 最终转换后的集合类型 123456789101112131415161718192021222324// 使用全局映射配置转换目标对象类型var stuLst = stuDbModels.OdinTypeAdapterBuilder&lt;Student_DbModel, Student, List&lt;Student&gt;&gt;( OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig() );// 使用自定义映射配置转换目标对象类型// 需要注意的是: 因为没有传全局映射配置, 此时虽然全局配置也有 StudentName 属性映射 StuName 的配置，但是会以当前自定义配置为准var stuLst = stuDbModels.OdinTypeAdapterBuilder&lt;Student_DbModel, Student, List&lt;Student&gt;&gt;( opt =&gt; &#123; opt.Map(dest =&gt; dest.StuName, src =&gt; src.StudentName); &#125; );// 使用自定义映射+全局映射配置转换目标对象对象类型// 需要注意的是: 因为全局映射配置中有 StudentName 属性映射 StuName 的配置，所以当自定义配置与全局配置都存在时，以全局配置为准var stuLst = stuDbModels.OdinTypeAdapterBuilder&lt;Student_DbModel, Student, List&lt;Student&gt;&gt;( opt =&gt; &#123; opt.Map(dest =&gt; dest.StuName, src =&gt; src.StudentName); opt.Map(dest =&gt; dest.StuAddress, src =&gt; src.StudentAddress); &#125;, OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig() ); 关于 Mapster 更详细的用法，请参照 Mapster 官网。 具体封装代码详见 Github","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"Mapster","slug":"Mapster","permalink":"https://www.odinsam.com/tags/Mapster/"}],"author":"OdinSam"},{"title":".Net中关于Json序列化Long类型数据的解决办法","slug":"Net中关于Json序列化Long类型数据的解决办法","date":"2021-07-06T15:11:09.000Z","updated":"2021-07-06T16:06:53.548Z","comments":true,"path":"/articles/4ad7.html","link":"","permalink":"https://www.odinsam.com/articles/4ad7.html","excerpt":"在分布式的项目中，我们的数据库Id不能再像以前一样使用int类型自动增长，这时候我们需要一个在网络当中都要能够保持唯一的值，通常情况我们会使用Guid来解决这个问题，但是作为string类型，他并不适合作为主键。尤其是在查询等需要索引操作的时候显得尤为重要。","text":"在分布式的项目中，我们的数据库Id不能再像以前一样使用int类型自动增长，这时候我们需要一个在网络当中都要能够保持唯一的值，通常情况我们会使用Guid来解决这个问题，但是作为string类型，他并不适合作为主键。尤其是在查询等需要索引操作的时候显得尤为重要。 这时候我们通常会选择使用雪花Id来解决这个问题，他是一个能在网络当中能够保证唯一的数值number类型的数字，对应在csharp中是long类型。具体雪花Id的原理网上都有，这里直接上生成雪花Id的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public class OdinSnowFlake : IOdinSnowFlake&#123; // 开始时间截((new DateTime(2020, 1, 1, 0, 0, 0, DateTimeKind.Utc)-Jan1st1970).TotalMilliseconds) private readonly long twepoch; // 机器id所占的位数 private const int workerIdBits = 5; // 数据标识id所占的位数 private const int datacenterIdBits = 5; // 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) private const long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 支持的最大数据标识id，结果是31 private const long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 序列在id中占的位数 private const int sequenceBits = 12; // 数据标识id向左移17位(12+5) private const int datacenterIdShift = sequenceBits + workerIdBits; // 机器ID向左移12位 private const int workerIdShift = sequenceBits; // 时间截向左移22位(5+5+12) private const int timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; // 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) private const long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); // 数据中心ID(0~31) public long datacenterId &#123; get; private set; &#125; // 工作机器ID(0~31) public long workerId &#123; get; private set; &#125; // 毫秒内序列(0~4095) public long sequence &#123; get; private set; &#125; // 上次生成ID的时间截 public long lastTimestamp &#123; get; private set; &#125; private static Dictionary&lt;long, long&gt; dicContainer = null; /// &lt;summary&gt; /// 雪花ID /// &lt;/summary&gt; /// &lt;param name=&quot;datacenterId&quot;&gt;数据中心ID&lt;/param&gt; /// &lt;param name=&quot;workerId&quot;&gt;工作机器ID&lt;/param&gt; public OdinSnowFlake(long datacenterId, long workerId) &#123; this.twepoch = (long)((new DateTime(2020, 1, 1, 0, 0, 0, DateTimeKind.Utc) - Jan1st1970).TotalMilliseconds); if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new Exception(string.Format(&quot;datacenter Id can&#x27;t be greater than &#123;0&#125; or less than 0&quot;, maxDatacenterId)); &#125; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new Exception(string.Format(&quot;worker Id can&#x27;t be greater than &#123;0&#125; or less than 0&quot;, maxWorkerId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; this.sequence = 0L; this.lastTimestamp = -1L; if (dicContainer == null) dicContainer = new Dictionary&lt;long, long&gt;(); &#125; public void InitDic() &#123; if (dicContainer == null) dicContainer = new Dictionary&lt;long, long&gt;(); &#125; public void ClearDic() &#123; if (dicContainer != null) dicContainer.Clear(); &#125; /// &lt;summary&gt; /// 获得下一个ID /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public long NextId() &#123; lock (this) &#123; long timestamp = GetCurrentTimestamp(); if (timestamp &gt; lastTimestamp) //时间戳改变，毫秒内序列重置 &#123; sequence = 0L; &#125; else if (timestamp == lastTimestamp) //如果是同一时间生成的，则进行毫秒内序列 &#123; sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) //毫秒内序列溢出 &#123; timestamp = GetNextTimestamp(lastTimestamp); //阻塞到下一个毫秒,获得新的时间戳 &#125; &#125; else //当前时间小于上一次ID生成的时间戳，证明系统时钟被回拨，此时需要做回拨处理 &#123; sequence = (sequence + 1) &amp; sequenceMask; if (sequence &gt; 0) &#123; timestamp = lastTimestamp; //停留在最后一次时间戳上，等待系统时间追上后即完全度过了时钟回拨问题。 &#125; else //毫秒内序列溢出 &#123; timestamp = lastTimestamp + 1; //直接进位到下一个毫秒 &#125; //throw new Exception(string.Format(&quot;Clock moved backwards. Refusing to generate id for &#123;0&#125; milliseconds&quot;, lastTimestamp - timestamp)); &#125; lastTimestamp = timestamp; //上次生成ID的时间截 //移位并通过或运算拼到一起组成64位的ID var id = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; if (!dicContainer.ContainsKey(id)) &#123; dicContainer.Add(id, id); return id; &#125; else &#123; Thread.Sleep(1); return NextId(); &#125; &#125; &#125; /// &lt;summary&gt; /// 解析雪花ID /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string AnalyzeId(long Id) &#123; StringBuilder sb = new StringBuilder(); var timestamp = (Id &gt;&gt; timestampLeftShift); var time = Jan1st1970.AddMilliseconds(timestamp + twepoch); sb.Append(time.ToLocalTime().ToString(&quot;yyyy-MM-dd HH:mm:ss:fff&quot;)); var datacenterId = (Id ^ (timestamp &lt;&lt; timestampLeftShift)) &gt;&gt; datacenterIdShift; sb.Append(&quot;_&quot; + datacenterId); var workerId = (Id ^ ((timestamp &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift))) &gt;&gt; workerIdShift; sb.Append(&quot;_&quot; + workerId); var sequence = Id &amp; sequenceMask; sb.Append(&quot;_&quot; + sequence); return sb.ToString(); &#125; /// &lt;summary&gt; /// 阻塞到下一个毫秒，直到获得新的时间戳 /// &lt;/summary&gt; /// &lt;param name=&quot;lastTimestamp&quot;&gt;上次生成ID的时间截&lt;/param&gt; /// &lt;returns&gt;当前时间戳&lt;/returns&gt; private static long GetNextTimestamp(long lastTimestamp) &#123; long timestamp = GetCurrentTimestamp(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = GetCurrentTimestamp(); &#125; return timestamp; &#125; /// &lt;summary&gt; /// 获取当前时间戳 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static long GetCurrentTimestamp() &#123; return (long)(DateTime.UtcNow - Jan1st1970).TotalMilliseconds; &#125; private static readonly DateTime Jan1st1970 = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);&#125; 代码解释： 提供了构造函数，其中datacenterId为当前数据中心Id:一般从1开始。workerId是机器Id,需要注意的是在网络节点当中的服务器，这个Id不能重复 代码的 NextId() 方法将会生成一个 18位长的long类型的雪花Id。 AnalyzeId() 方法可以简单的解析一个long的数值是不是符合雪花Id的规范。这个解析不精准，只能判断格式大致是否正确具体解析规则可以看代码。 有了这个Id，我们通常可以开心的在代码当中以application/json格式返回一个对象，比如 输出的结果是 这是因为 JavaScript 数值精度是32位，如果整数数度超过32位，就会被当作浮点数处理。换句话说，如果从服务端生成的JSON，某个值是64位整数，传到前端JavaScript，再传回服务端，不做任何运算，都可能出现失真。 解决问题的办法：将long作为string类型序列化输出 代码如下： 1234567public class Stu&#123; [JsonConverter(typeof(JsonConverterLong))] public long id &#123; get; set; &#125; public string name &#123; get; set; &#125; public int age &#123; get; set; &#125;&#125; JsonConverterLong 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class JsonConverterLong : JsonConverter&#123; /// &lt;summary&gt; /// 是否可以转换 /// &lt;/summary&gt; /// &lt;param name=&quot;objectType&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override bool CanConvert(Type objectType) &#123; return true; &#125; /// &lt;summary&gt; /// 读json /// &lt;/summary&gt; /// &lt;param name=&quot;reader&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;objectType&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;existingValue&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;serializer&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) &#123; if ((reader.ValueType == null || reader.ValueType == typeof(long?)) &amp;&amp; reader.Value == null) &#123; return null; &#125; else &#123; long.TryParse(reader.Value != null ? reader.Value.ToString() : &quot;&quot;, out long value); return value; &#125; &#125; /// &lt;summary&gt; /// 写json /// &lt;/summary&gt; /// &lt;param name=&quot;writer&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;serializer&quot;&gt;&lt;/param&gt; public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) &#123; if (value == null) writer.WriteValue(value); else writer.WriteValue(value + &quot;&quot;); &#125;&#125;","categories":[],"tags":[],"author":"OdinSam"},{"title":"vscode 使用 git-commit-plugin 插件规范提交 Git","slug":"vscode使用git-commit-plugin 插件规范提交Git","date":"2021-06-30T13:49:00.000Z","updated":"2021-07-06T16:02:07.022Z","comments":true,"path":"/articles/34fe.html","link":"","permalink":"https://www.odinsam.com/articles/34fe.html","excerpt":"在团队协作开发时，每个人提交代码时都会写 commit message。每个人都有自己的书写风格，翻看我们组的git log, 可以说是五花八门，十分不利于阅读和维护。本文将介绍 Git 提交的规范以及如何利用 git-commit-plugin 插件快速提交规范的commit。","text":"在团队协作开发时，每个人提交代码时都会写 commit message。每个人都有自己的书写风格，翻看我们组的git log, 可以说是五花八门，十分不利于阅读和维护。本文将介绍 Git 提交的规范以及如何利用 git-commit-plugin 插件快速提交规范的commit。 一般来说，大厂都有一套的自己的提交规范，尤其是在一些大型开源项目中，commit message 都是十分一致的。因此，我们需要制定统一标准，促使团队形成一致的代码提交风格，更好的提高工作效率，成为一名有追求的工程师。其中 AngularJS 在 github 上 的提交记录被业内许多人认可，逐渐被大家引用。 Commit message 的格式 每次提交，Commit message 都包括三个部分：header，body 和 footer。 12345type(scope):空格subject换行[body]换行[footer] 1. type 类型 type 是 commit 的类别，只允许如下几种标识： 12345678910111213141516# 主要typefeat: 增加新功能fix: 修复bug# 特殊type docs: 只改动了文档相关的内容style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号build: 构造工具的或者外部依赖的改动，例如webpack，npmrefactor: 代码重构时使用revert: 执行git revert打印的message# 暂不使用typetest: 添加测试或者修改现有测试perf: 提高性能的改动ci: 与CI（持续集成服务）有关的改动chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动 2. scope scope也为必填项，用于描述改动的范围，格式为项目名/模块名，例如：xxxServices 。如果一次commit修改多个模块，建议拆分成多次commit，以便更好追踪和维护。 3. subject commit 目的的简短描述，不超过50个字符。结尾一般是 #33224 这样的超链接。链接到本次提交的 url 但不强制 4. body 对本次 commit 的详细描述 5. footer Footer 部分只用于以下两种情况： 5.1. 不兼容变动: 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。例如下边这样： 1234567891011121314151617BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: &#x27;attribute&#x27;, &#125; After: scope: &#123; myAttr: &#x27;@&#x27;, &#125; The removed `inject` wasn&#x27;t generaly useful for directives so there should be no code using it. 5.2. 关闭 Issue: 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 完整的提交demo如下： 12345fix(dev-infra): remove bots from special thanks sectionWith this change we remove known used bots from special thanks section in the changelog.PR Close #42697 那么每次都这样编写提交的内容，还要注意对应的格式。我们有没有简单方便的办法呢，那就是使用对应工具的插件。git-commit-plugin 插件可以帮助我们快速的边写提交的信息，但是插件本身并不支持格式化。所以，我在该插件的基础上做了二次开发，具体使用如下： 下载安装对应的插件：git-commit-plugin-1.0.6.vsix 在插件的扩展配置中，进行对应的提交模板配置。可以配置多个，这是因为我公司和我自己的提交格式都不一样。具体可以参见项目的 readme.md 12345678910&quot;GitCommitPlugin.Templates&quot;: [ &#123; &quot;templateName&quot;: &quot;Angular&quot;, &quot;templateContent&quot;: &quot;&lt;icon&gt;&lt;space&gt;&lt;type&gt;(&lt;scope&gt;):&lt;space&gt;&lt;subject&gt;&lt;enter&gt;&lt;body&gt;&lt;enter&gt;&lt;footer&gt;&quot; &#125;, &#123; &quot;templateName&quot;: &quot;git-cz&quot;, &quot;templateContent&quot;: &quot;&lt;type&gt;(&lt;scope&gt;):&lt;space&gt;&lt;icon&gt;&lt;space&gt;&lt;subject&gt;&lt;enter&gt;&lt;body&gt;&lt;enter&gt;&lt;footer&gt;&quot; &#125;] 配置插件是否启用图标 1&quot;GitCommitPlugin.ShowEmoji&quot;: true 最后就可以方便的提交使用了。","categories":[{"name":"Git","slug":"Git","permalink":"https://www.odinsam.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.odinsam.com/tags/Git/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/tags/VsCode/"},{"name":"插件","slug":"插件","permalink":"https://www.odinsam.com/tags/%E6%8F%92%E4%BB%B6/"}],"author":"OdinSam"},{"title":".Net Core使用SqlSugar和Cap","slug":"Net-Core使用SqlSugar和Cap","date":"2021-06-16T15:21:00.000Z","updated":"2021-06-16T16:13:08.984Z","comments":true,"path":"/articles/ed30.html","link":"","permalink":"https://www.odinsam.com/articles/ed30.html","excerpt":"近期的一次面试当中聊起了 .Net Core 中的 EF 框架和分布式的事务，因为在项目中也遇到过并发导致 EF Core 性能和报错的各种问题，所以就和面试官吐槽了一下，面试官说他们公司用的 SqlSugar 。这个开源组件库我以前知道的，但很久没有关注。回家看了一下发现这个东西已经非常完善，特此将项目中的 EF Core 变更为了 SqlSugar并且加入了 Cap，顺便记录一下遇到的问题。","text":"近期的一次面试当中聊起了 .Net Core 中的 EF 框架和分布式的事务，因为在项目中也遇到过并发导致 EF Core 性能和报错的各种问题，所以就和面试官吐槽了一下，面试官说他们公司用的 SqlSugar 。这个开源组件库我以前知道的，但很久没有关注。回家看了一下发现这个东西已经非常完善，特此将项目中的 EF Core 变更为了 SqlSugar并且加入了 Cap，顺便记录一下遇到的问题。 1. SqlSugar简介 SqlSugar是一款 老牌 .NET 开源ORM框架，由果糖大数据科技团队维护和更新 ，Github star数仅次于EF 和 Dapper。优点： 简单易用、功能齐全、高性能、轻量级、服务齐全、有专业技术支持一天18小时服务。支持数据库有 MySql、SqlServer、Sqlite、Oracle 、 postgresql、达梦、人大金仓。我的项目习惯了Code First，第一次使用也不知道是否正确。 Startup.cs - SqlSugar 注入代码 123456789services.AddTransient&lt;OdinProjectSugarDbContext&gt;();OdinInjectHelper.ServiceProvider = services.BuildServiceProvider();var sugarEntity = OdinInjectHelper.GetService&lt;OdinProjectSugarDbContext&gt;();#region 初始化数据库//修改cnf.config Host配置的链接字符串 enable修改为true，即可自动化初识数据库if (_Options.DbEntity.InitDb)&#123; sugarEntity.CreateTable(&quot;db_odinCore&quot;, false);&#125; OdinProjectSugarDbContext.cs - DbContext定义以及初始化数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class OdinProjectSugarDbContext&#123; SqlSugarClient db; public OdinProjectSugarDbContext() &#123; db = DbScoped.Sugar; &#125; public void CreateTable(string databaseName, bool Backup = false) &#123; var flag = false; try &#123; // 判断数据库是否存在，如果不存在这里会有异常 flag = db.DbMaintenance.GetDataBaseList(db).Contains(databaseName); &#125; catch &#123; // 如果不存在 初始化创建数据库 db.DbMaintenance.CreateDatabase(databaseName); &#125; finally &#123; if (!flag) &#123; Log.Logger.Information($&quot;【 自动创建数据库 】&quot;); db.DbMaintenance.CreateDatabase(databaseName); // 我在所有的表后边都实现了一个自己的接口 IDbTable var dbTable = typeof(IDbTable); // 找到所有实现了 IDbTable 的类 就是Mysql中对应的表 var types = this.GetType().Assembly.GetTypes().Where(t =&gt; dbTable.IsAssignableFrom(t)); // 是否备份表 if (Backup) &#123; foreach (var item in types) &#123; // 判断表是否存在 如果不存在则新建表 if (!OdinSugarHelper.CheckTable(item)) &#123; DbScoped.Sugar.CodeFirst.BackupTable().InitTables(item); Log.Logger.Information($&quot;创建数据表【 &#123;item.ToString()&#125; 】&quot;); &#125; &#125; &#125; else &#123; foreach (var item in types) &#123; if (!OdinSugarHelper.CheckTable(item)) &#123; DbScoped.Sugar.CodeFirst.InitTables(item); Log.Logger.Information($&quot;创建数据表【 &#123;item.ToString()&#125; 】&quot;); &#125; &#125; &#125; Log.Logger.Information($&quot;启用【 数据库初始化 】---开始配置&quot;); SampleData.Init(); &#125; &#125; &#125; public OdinSugarDbSet&lt;Aop_ApiInvokerCatch_DbModel&gt; ApiInvokerCatchs &#123; get &#123; return new OdinSugarDbSet&lt;Aop_ApiInvokerCatch_DbModel&gt;(db); &#125; &#125; public OdinSugarDbSet&lt;Aop_ApiInvokerRecord_DbModel&gt; ApiInvokerRecords &#123; get &#123; return new OdinSugarDbSet&lt;Aop_ApiInvokerRecord_DbModel&gt;(db); &#125; &#125; public OdinSugarDbSet&lt;ErrorCode_DbModel&gt; ErrorCodes &#123; get &#123; return new OdinSugarDbSet&lt;ErrorCode_DbModel&gt;(db); &#125; &#125;&#125; OdinSugarHelper.cs 1234567891011121314151617181920212223242526272829303132333435public class OdinSugarHelper&#123; static SqlSugarClient Db = DbScoped.Sugar; /// &lt;summary&gt; /// 检查表是否存在 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool CheckTable(Type type) &#123; string tableName = Db.EntityMaintenance.GetTableName(type); return Db.DbMaintenance.IsAnyTable(tableName, false); &#125; /// &lt;summary&gt; /// 检查表是否存在 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool CheckTable&lt;T&gt;() &#123; string tableName = Db.EntityMaintenance.GetTableName(typeof(T)); return Db.DbMaintenance.IsAnyTable(tableName, false); &#125; /// &lt;summary&gt; /// 检查表是否存在 /// &lt;/summary&gt; /// &lt;param name=&quot;TableName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool CheckTable(string TableName) &#123; return Db.DbMaintenance.IsAnyTable(TableName, false); &#125;&#125; 这样程序在运行的时候就基于DbContext的定义可以在数据库新建表。 2. 基于 SqlSugar 使用 cap CAP 是一个在分布式系统中（SOA，MicroService）实现事件总线及最终一致性（分布式事务）的一个开源的 C# 库，她具有轻量级，高性能，易使用等特点。 Startup.cs - SqlSugar 注入代码 1services.AddOdinCapInject(_Options.DbEntity.ConnectionString, _Options.MongoDb.MongoConnection, _Options.RabbitMQ); AddOdinCapInject - 方法 1234567891011121314151617181920212223242526272829public static IServiceCollection AddOdinCapInject(this IServiceCollection services, string mysqlConnectionString, string mongoConnectionString, RabbitMQOptions rabbitMQOptions)&#123; services.AddCap(x =&gt; &#123; //如果你使用的ADO.NET，根据数据库选择进行配置： // x.UseSqlServer(&quot;数据库连接字符串&quot;); x.UseMySql(mysqlConnectionString); // x.UsePostgreSql(&quot;数据库连接字符串&quot;); //如果你使用的 MongoDB，你可以添加如下配置： // x.UseMongoDB(mongoConnectionString); //注意，仅支持MongoDB 4.0+集群 //CAP支持 RabbitMQ、Kafka、AzureServiceBus 等作为MQ，根据使用选择配置： x.UseRabbitMQ(rb =&gt; &#123; rb.HostName = rabbitMQOptions.HostNames[0]; rb.UserName = rabbitMQOptions.Account.UserName; rb.Password = rabbitMQOptions.Account.Password; rb.VirtualHost = rabbitMQOptions.VirtualHost; rb.Port = rabbitMQOptions.Port; &#125;); // x.UseKafka(&quot;ConnectionStrings&quot;); // x.UseAzureServiceBus(&quot;ConnectionStrings&quot;); x.UseDashboard(); &#125;); return services;&#125; OdinCapHelper.cs - 封装，注入到service中即可使用 12345678910111213141516171819202122public class OdinCapHelper : IOdinCapHelper&#123; public void CapPublish&lt;T&gt;(string publishName, T contentObj, Action action = null) &#123; var db = DbScoped.Sugar; var capBus = OdinInjectHelper.GetService&lt;ICapPublisher&gt;(); using (var connection = (MySqlConnection)db.Ado.Connection) &#123; using (var transaction = connection.BeginTransaction(capBus, autoCommit: false)) &#123; if (connection.State != ConnectionState.Open) &#123; connection.Open(); &#125; db.Ado.Transaction = (IDbTransaction)transaction.DbTransaction;//这行很重要 if (action != null) action(); capBus.Publish&lt;T&gt;(publishName, contentObj); transaction.Commit(); &#125; &#125; &#125;&#125; 这里需要注意的是，如果和我一样是使用mysql数据库，那么需要讲nuget包由 SqlSugarCore 替换为 SqlSugarCore.MySqlConnector 切记！！！ 切记！！！ ** Controller ** - Action方法中发布消息 12345var db = DbScoped.Sugar;OdinCapHelper.CapPublish(&quot;Sample.RabbitMQ.MySql&quot;, DateTime.Now, () =&gt; &#123; System.Console.WriteLine(&quot;to do something&quot;); &#125;); Controller - Action方法中订阅消费消息 123456[CapSubscribe(&quot;Sample.RabbitMQ.MySql&quot;)]public async Task&lt;Task&gt; CheckReceivedMessage(DateTime time)&#123; Console.WriteLine(time); return Task.CompletedTask;&#125; 完整代码可以在 GitHub中找到。","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":"SqlSugar","slug":"SqlSugar","permalink":"https://www.odinsam.com/tags/SqlSugar/"},{"name":"Cap","slug":"Cap","permalink":"https://www.odinsam.com/tags/Cap/"}],"author":"OdinSam"},{"title":"使用 BackgroundService 类在微服务中实现后台任务","slug":"使用-BackgroundService-类在微服务中实现后台任务","date":"2021-06-14T09:34:00.000Z","updated":"2021-06-14T10:18:51.943Z","comments":true,"path":"/articles/2893.html","link":"","permalink":"https://www.odinsam.com/articles/2893.html","excerpt":"任何应用程序中都可能需要使用后台任务和计划作业，无论应用程序是否遵循微服务体系结构模式均是如此。 使用微服务体系结构的区别在于，你可以在一个单独的用于托管的进程/容器中实现后台任务。一般在 .NET 中，我们将这些类型的任务称为托管服务，因为它们是托管在主机/应用程序/微服务中的服务/逻辑。 请注意，在这种情况下，托管服务仅表示具有后台任务逻辑的类。","text":"任何应用程序中都可能需要使用后台任务和计划作业，无论应用程序是否遵循微服务体系结构模式均是如此。 使用微服务体系结构的区别在于，你可以在一个单独的用于托管的进程/容器中实现后台任务。一般在 .NET 中，我们将这些类型的任务称为托管服务，因为它们是托管在主机/应用程序/微服务中的服务/逻辑。 请注意，在这种情况下，托管服务仅表示具有后台任务逻辑的类。 1. IHostedService介绍 自 .NET Core 2.0 开始，该框架提供名为 IHostedService 的新接口，有助于轻松实现托管服务。 基本理念是，可以注册多个后台任务（托管服务），在 Web 主机或主机运行时在后台运行具体介绍如下图： 但是，由于大多数后台任务在取消令牌管理和其他典型操作方面都有类似的需求，因此有一个非常方便且可以从中进行派生的抽象基类，名为 BackgroundService（自 .NET Core 2.1 起提供），该类提供设置后台任务所需的主要工作。从抽象基类派生时，只需在自定义的托管服务类中实现 ExecuteAsync() 方法，结合 利用Canal集合RabbitMQ实现数据和缓存同步 这篇文章，就可以搭建Canal + RabbitMQ + CacheManager 的基本架构，从而实现由 Canal 监控和发现 mysql 数据库的增量信息并推送到 RabbitMQ ，而我们使用BackgroundSerivce 搭建的后台托管服务消费 RabbitMQ 信息修改 Redis 中的缓存数据，而 CacheManager 设定 Redis 缓存为缓存挡板，故而内存中的二级缓存也会得到对应修改。 2. 具体实现 这里是以 ErrorCode 错误码为例，实现一系列操作。首先是 实现 BackgroundService 的子类 OdinBackgroundService ： 12345678910111213141516171819202122232425262728293031323334353637383940public class OdinBackgroundService : BackgroundService&#123; private readonly ProjectExtendsOptions apiOptions; private readonly ReceiveRabbitMQHelper receiveRabbitMQHelper; private int executionCount = 0; private Timer _timer; public OdinBackgroundService() &#123; this.apiOptions = OdinInjectHelper.GetService&lt;IOptionsSnapshot&lt;ProjectExtendsOptions&gt;&gt;().Value; this.receiveRabbitMQHelper = new ReceiveRabbitMQHelper(); &#125; private void DoWork(object state) &#123; receiveRabbitMQHelper.ReceiveMQ(apiOptions); &#125; public override Task StartAsync(CancellationToken cancellationToken) &#123; return ExecuteAsync(cancellationToken); &#125; protected override Task ExecuteAsync(CancellationToken stoppingToken) &#123; Log.Information($&quot;Service:【 Run 】\\tTime:【&#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;); _timer = new Timer(DoWork, null, TimeSpan.Zero, TimeSpan.FromMilliseconds(300)); return Task.CompletedTask; &#125; public override Task StopAsync(CancellationToken cancellationToken) &#123; Log.Information($&quot;Service:【 Stop 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;); _timer?.Change(Timeout.Infinite, 0); return base.StopAsync(cancellationToken); &#125; public override void Dispose() &#123; _timer?.Dispose(); &#125;&#125; 这里采用轮询机制，每300ms消费一次 RabbitMQ 的信息，具体的消费代码 ReceiveRabbitMQHelper 如下: 1234567891011121314151617181920212223242526272829303132333435363738public class ReceiveRabbitMQHelper&#123; private readonly IRabbitMQReceiveServer rabbitMQReceiveServer; private readonly IOdinCanalHelper canalHelper; private readonly IOdinCacheManager cacheManager; public ReceiveRabbitMQHelper() &#123; this.rabbitMQReceiveServer = OdinInjectHelper.GetService&lt;IRabbitMQReceiveServer&gt;(); this.canalHelper = OdinInjectHelper.GetService&lt;IOdinCanalHelper&gt;(); this.cacheManager = OdinInjectHelper.GetService&lt;IOdinCacheManager&gt;(); &#125; public void ReceiveMQ(ProjectExtendsOptions apiOptions) &#123; rabbitMQReceiveServer.ReceiveJsonMessage( apiOptions.RabbitMQ, new RabbitMQReceivedModel &#123; ExchangeName = &quot;canal-exchange&quot;, QueueName = &quot;canal-queues&quot;, AutoAck = false &#125;, (BasicGetResult result, IModel channel) =&gt; &#123; var msg = RabbitMQReceiveHandler.ReceiveJsonMessageHandler(result, channel); if (!string.IsNullOrEmpty(msg)) &#123; System.Console.WriteLine($&quot;Canal-WorkService:【 Run 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;); System.Console.WriteLine(msg); // 这里用来处理获取到的 RabbitMQ 的增量信息 ErrorCodeHelper.ErrorCodeCanalHandler(canalHelper, cacheManager, msg); System.Console.WriteLine(&quot;\\r\\n&quot;); &#125; &#125; ); &#125;&#125; ErrorCodeCanalHandler用来处理获取到的 RabbitMQ 的增量信息，具体封装如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ErrorCodeHelper&#123; public static void ErrorCodeCanalHandler(IOdinCanalHelper canalHelper, IOdinCacheManager cacheManager, string canalString) &#123; var obj = canalHelper.GetCanalInfo(canalString); var type = obj.type; switch (type.ToLower()) &#123; case &quot;insert&quot;: &#123; var model = ConvertCanalDataToErrorCodeModel(obj); var flag = cacheManager.Add(model.ErrorCode, model); if (flag) System.Console.WriteLine(&quot;cacheManager add success&quot;); else System.Console.WriteLine(&quot;cacheManager add fail&quot;); &#125; break; case &quot;update&quot;: &#123; var model = ConvertCanalDataToErrorCodeModel(obj); cacheManager.Cover&lt;ErrorCode_Model&gt;(model.ErrorCode, model); System.Console.WriteLine(&quot;cacheManager Cover success&quot;); &#125; break; case &quot;delete&quot;: &#123; var errorCode = GetErrorCode(obj); bool flag = cacheManager.Delete(errorCode); if (flag) System.Console.WriteLine(&quot;cacheManager delete success&quot;); else System.Console.WriteLine(&quot;cacheManager delete fail&quot;); &#125; break; default: break; &#125; &#125; private static string GetErrorCode(OdinCanalModel obj) &#123; var errorCode = obj.data[0].GetValue(&quot;ErrorCode&quot;).ToString(); return errorCode; &#125; private static ErrorCode_Model ConvertCanalDataToErrorCodeModel(OdinCanalModel obj) &#123; var errorCode = obj.data[0].GetValue(&quot;ErrorCode&quot;).ToString(); var codeShowMessage = obj.data[0].GetValue(&quot;CodeShowMessage&quot;).ToString(); var codeErrorMessage = obj.data[0].GetValue(&quot;CodeErrorMessage&quot;).ToString(); ErrorCode_Model model = new ErrorCode_Model() &#123; ErrorCode = errorCode, ErrorMessage = codeErrorMessage, ShowMessage = codeErrorMessage, &#125;; return model; &#125;&#125; 这样基本的搭建就完成了，完整代码可以在 GitHub 。","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"微服务","slug":"微服务","permalink":"https://www.odinsam.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"BackgroundService","slug":"BackgroundService","permalink":"https://www.odinsam.com/tags/BackgroundService/"}],"author":"OdinSam"},{"title":"基于HttpClientFactory的封装和使用","slug":"基于HttpClientFactory的封装和使用","date":"2021-06-10T22:08:00.000Z","updated":"2021-06-10T22:49:13.622Z","comments":true,"path":"/articles/4ff6.html","link":"","permalink":"https://www.odinsam.com/articles/4ff6.html","excerpt":".Net Core2.0 版本以前 HttpClient 还是挺坑的，我们需要操心怎么建立如何释放，而且代码质量不好还会影响 HttpClient 的性能和访问速度。2.0版本以后 HttpClientFactory 的出现解决了我们所有的痛点，我们不须要关心如何建立 HttpClient 又如何释放它。经过它能够建立具备特定业务的HttpClient，并且能够很友好的和 DI 容器结合使用。","text":".Net Core2.0 版本以前 HttpClient 还是挺坑的，我们需要操心怎么建立如何释放，而且代码质量不好还会影响 HttpClient 的性能和访问速度。2.0版本以后 HttpClientFactory 的出现解决了我们所有的痛点，我们不须要关心如何建立 HttpClient 又如何释放它。经过它能够建立具备特定业务的HttpClient，并且能够很友好的和 DI 容器结合使用。 1. 首先在 Startup.cs 文件的 ConfigureServices 方法中注入 HttpClient 123456789101112131415161718192021222324var handler = new HttpClientHandler();foreach (var cerItem in _Options.SslCers)&#123; if (!string.IsNullOrEmpty(cerItem.CerPath)) &#123; var clientCertificate = new X509Certificate2(cerItem.CerPath, cerItem.CerPassword); handler.ClientCertificates.Add(clientCertificate); &#125;&#125;var handlerWithCer = new HttpClientHandler();foreach (var cerItem in _Options.SslCers)&#123; if (!string.IsNullOrEmpty(cerItem.CerPath)) &#123; var clientCertificate = new X509Certificate2(cerItem.CerPath, cerItem.CerPassword); handlerWithCer.ClientCertificates.Add(clientCertificate); &#125;&#125;services.AddHttpClient(&quot;OdinClient&quot;, c =&gt;&#123;&#125;).ConfigurePrimaryHttpMessageHandler(() =&gt; handler);services.AddHttpClient(&quot;OdinClientCer&quot;, c =&gt;&#123;&#125;).ConfigurePrimaryHttpMessageHandler(() =&gt; handlerWithCer); 这里我注入了两个 HttpClient，一个是没有证书的，一个是有证书的。如何在 Post 和 Get 的时候动态传递证书，有知道的小伙伴可以留言告诉我一下（我没找到这个解决的办法）。 2. 接下来可以在拦截器里开启 Request.Body 重复读取。 1context.HttpContext.Request.EnableBuffering(); 3. 封装获取Request.Body的方法 12345678910public static class HttpRequestExtends&#123; public static string ReadRequestBody(this HttpRequest request) &#123; var reader = new StreamReader(request.Body); var data = reader.ReadToEndAsync(); request.Body.Seek(0, SeekOrigin.Begin); return data.Result; &#125;&#125; 4. 封装HttpClient方法(这里只是封装了 Get 和 Post 作为演示) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168public class OdinHttpClientFactory : IOdinHttpClientFactory&#123; public static async Task&lt;T&gt; GetRequestAsync&lt;T&gt;(string clientName, string uri, Dictionary&lt;string, string&gt; customHeaders = null, string mediaType = &quot;application/json&quot;) &#123; var clientFactory = OdinInjectHelper.GetService&lt;IHttpClientFactory&gt;(); var client = clientFactory.CreateClient(clientName); var request = new HttpRequestMessage() &#123; RequestUri = new Uri(uri), Method = HttpMethod.Get, &#125;; RequestHeaderAdd(request, customHeaders); request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(mediaType)); return await GetResponseResult&lt;T&gt;(client, request); &#125; public static async Task&lt;T&gt; PostRequestAsync&lt;T&gt;(string clientName, string uri, Object obj, Dictionary&lt;string, string&gt; customHeaders = null, string mediaType = &quot;application/json&quot;, Encoding encoder = null) &#123; var clientFactory = OdinInjectHelper.GetService&lt;IHttpClientFactory&gt;(); var client = clientFactory.CreateClient(clientName); var request = new HttpRequestMessage() &#123; RequestUri = new Uri(uri), Method = HttpMethod.Post, &#125;; RequestHeaderAdd(request, customHeaders); request.Content = GenerateContent(obj, mediaType, encoder); return await GetResponseResult&lt;T&gt;(client, request); &#125; private static HttpContent GenerateContent(Object obj, string mediaType, Encoding encoder) &#123; if (typeof(String) == obj.GetType()) &#123; return GenerateContent&lt;String&gt;(obj.ToString(), mediaType, encoder); &#125; else &#123; return GenerateContent&lt;Object&gt;(obj, mediaType, encoder); &#125; &#125; private static HttpContent GenerateContent&lt;T&gt;(T obj, string mediaType, Encoding encoder) &#123; StringBuilder jsonContent = new StringBuilder(); string sendContent = string.Empty; Dictionary&lt;string, string&gt; dic = ConvertPostDataToDictionary&lt;T&gt;(obj, encoder); if (mediaType == &quot;application/json&quot;) &#123; sendContent = JsonConvert.SerializeObject(dic); &#125; else &#123; sendContent = ConvertDictionaryToPostFormData(dic).ToString(); &#125; return new StringContent( sendContent, encoder == null ? Encoding.UTF8 : encoder, mediaType); &#125; private async static Task&lt;T&gt; PostResponseResult&lt;T&gt;(HttpClient client, HttpRequestMessage request) &#123; var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) &#123; return GetResult&lt;T&gt;(response); &#125; else throw new Exception(&quot;请求出错&quot;); &#125; private async static Task&lt;T&gt; GetResponseResult&lt;T&gt;(HttpClient client, HttpRequestMessage request) &#123; var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) &#123; return GetResult&lt;T&gt;(response); &#125; else throw new Exception(&quot;请求出错&quot;); &#125; private static void RequestHeaderAdd(HttpRequestMessage request, Dictionary&lt;string, string&gt; customHeaders) &#123; if (customHeaders != null) &#123; foreach (KeyValuePair&lt;string, string&gt; customHeader in customHeaders) &#123; request.Headers.Add(customHeader.Key, customHeader.Value); &#125; &#125; &#125; private static T GetResult&lt;T&gt;(HttpResponseMessage httpResponseMessage) &#123; // 确认响应成功，否则抛出异常 // result.EnsureSuccessStatusCode(); if (typeof(T) == typeof(byte[])) &#123; return (T)Convert.ChangeType(httpResponseMessage.Content.ReadAsByteArrayAsync(), typeof(T)); &#125; else if (typeof(T) == typeof(Stream)) &#123; return (T)Convert.ChangeType(httpResponseMessage.Content.ReadAsStreamAsync().Result, typeof(T)); &#125; else &#123; if (typeof(T) == typeof(string)) return (T)Convert.ChangeType(httpResponseMessage.Content.ReadAsStringAsync().Result, typeof(T)); return JsonConvert.DeserializeObject&lt;T&gt;(httpResponseMessage.Content.ReadAsStringAsync().Result); &#125; &#125; public static Dictionary&lt;string, string&gt; ConvertPostDataToDictionary&lt;T&gt;(T obj, Encoding encoder = null) &#123; Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;(); if (typeof(T) == typeof(String)) &#123; foreach (var item in obj.ToString().Split(&#x27;&amp;&#x27;)) &#123; dic.Add( item.Split(&#x27;=&#x27;)[0], encoder == null || encoder == Encoding.UTF8 ? item.Split(&#x27;=&#x27;)[1] : item.Split(&#x27;=&#x27;)[1].ConvertStringEncode(Encoding.UTF8, encoder) ); &#125; &#125; else &#123; foreach (var item in obj.GetType().GetRuntimeProperties()) &#123; dic.Add(item.Name, encoder == null || encoder == Encoding.UTF8 ? item.GetValue(obj).ToString() : item.GetValue(obj).ToString().ConvertStringEncode(Encoding.UTF8, encoder) ); &#125; &#125; return dic; &#125; private static StringBuilder ConvertDictionaryToPostFormData(Dictionary&lt;string, string&gt; dic) &#123; StringBuilder builder = new StringBuilder(); if (dic != null) &#123; bool hasParam = false; foreach (KeyValuePair&lt;string, string&gt; kv in dic) &#123; string name = kv.Key; string value = kv.Value; // 忽略参数名或参数值为空的参数 if (!string.IsNullOrEmpty(name) &amp;&amp; !string.IsNullOrEmpty(value)) &#123; if (hasParam) &#123; builder.Append(&quot;&amp;&quot;); &#125; builder.Append(name); builder.Append(&quot;=&quot;); builder.Append(value); hasParam = true; &#125; &#125; &#125; return builder; &#125;&#125; 5. 最后封装获取Request.Body内容后二次封装的方法，因为我会遇到 一个 Post 请求但是 Url 还带有参数的情况，所以这里封装的稍微复杂一些 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static RequestParamsModel GetRequestParams(this Controller controller, string paramFormat = null)&#123; HttpContext context = controller.HttpContext; var request = context.Request; JObject jobj = new JObject(); RequestParamsModel requestParams = new RequestParamsModel(); if (!string.IsNullOrEmpty(context.Request.QueryString.ToString())) &#123; string param = request.QueryString.ToString().Substring(1); requestParams.RequestQueryString = JsonConvert.DeserializeObject&lt;JObject&gt;(JsonConvert.SerializeObject(OdinHttpClientFactory.ConvertPostDataToDictionary&lt;string&gt;(param))); &#125; if (request.ContentType != null &amp;&amp; request.ContentType.StartsWith(&quot;application/json&quot;)) &#123; string param = request.ReadRequestBody(); requestParams.RequestFormData = JsonConvert.DeserializeObject&lt;JObject&gt;(param); &#125; if (request.ContentType != null &amp;&amp; (request.ContentType.StartsWith(&quot;text/plain&quot;) || request.ContentType.StartsWith(&quot;application/javascript&quot;) || request.ContentType.StartsWith(&quot;text/html&quot;) || request.ContentType.StartsWith(&quot;application/xml&quot;))) &#123; string param = request.ReadRequestBody(); requestParams.RequestFormDataString = param.Replace(&quot;\\r&quot;, &quot;&quot;).Replace(&quot;\\n&quot;, &quot;&quot;).Replace(&quot; &quot;, &quot;&quot;); &#125; if (request.ContentType != null &amp;&amp; request.ContentType.StartsWith(&quot;application/x-www-form-urlencoded&quot;)) &#123; string param = request.ReadRequestBody(); requestParams.RequestFormData = JsonConvert.DeserializeObject&lt;JObject&gt;(JsonConvert.SerializeObject(OdinHttpClientFactory.ConvertPostDataToDictionary&lt;string&gt;(param))); &#125; if (request.ContentType != null &amp;&amp; request.ContentType.StartsWith(&quot;multipart/form-data&quot;)) &#123; Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;(); foreach (var kv in request.Form) &#123; dic.Add(kv.Key, kv.Value); &#125; requestParams.RequestFormData = JsonConvert.DeserializeObject&lt;JObject&gt;(JsonConvert.SerializeObject(dic)); List&lt;Dictionary&lt;string, MemoryStream&gt;&gt; files = new List&lt;Dictionary&lt;string, MemoryStream&gt;&gt;(); long filesize = 0; foreach (var file in request.Form.Files) &#123; filesize += file.Length; if (filesize &gt; 1024 * 1024 * 4) throw new Exception(&quot;文件过大无法上传，请联系管理员申请使用大文件上传服务器&quot;); var fileBytes = new Byte[file.Length]; MemoryStream fileStream = new MemoryStream(fileBytes); file.CopyTo(fileStream); files.Add(new Dictionary&lt;string, MemoryStream&gt;() &#123; &#123; file.Name, fileStream &#125; &#125;); &#125; requestParams.RequestUploadFile = files; &#125; return requestParams;&#125; 其中文件上传大小可以通过配置文件限制，现在及时我们遇到有Get请求，但是带着FormData文件的情况，我们也可以正常获取所有信息，其中信息内容格式如下： 1234567891011121314151617181920212223public class RequestParamsModel&#123; /// &lt;summary&gt; /// Url 地址栏参数信息 自动转化为 JObject /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public JObject RequestQueryString &#123; get; set; &#125; /// &lt;summary&gt; /// 当 请求内容包含 application/text application/xml text/plain 和 application/javascript 是，获取内容一律视为 string，后期再自行处理 /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public String RequestFormDataString &#123; get; set; &#125; /// &lt;summary&gt; /// FormData 请求时所有的键值对，自动转化为 JObject /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public JObject RequestFormData &#123; get; set; &#125; /// &lt;summary&gt; /// FormData 请求时附带的文件，key为文件名 value为文件的stream格式 /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public List&lt;Dictionary&lt;string, MemoryStream&gt;&gt; RequestUploadFile &#123; get; set; &#125;&#125; 6. 其中，这个封装并没有处理Body包含 binary 格式和 GraphQL 格式，如有需要可以自行扩展。此时，当我们遇到 123var obj = OdinHttpClientFactory.PostRequestAsync&lt;OdinActionResult&gt;(&quot;OdinClient&quot;, &quot;http://127.0.0.1:20303/api/v1/LinkTrack/pfda?id=4&amp;name=admin&quot;, new &#123; User = &quot;odinsam&quot; &#125;); 这样的请求时，我们就会得到如下内容:(OdinActionResult是我自己定义的一个统一返回格式而已) 123456RequestQueryString - null&#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;admin&quot;&#125;RequestFormDataString - nullRequestFormData&#123;&quot;User&quot;:&quot;odinsam&quot;&#125;RequestUploadFile - null","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"HttpClientFactory","slug":"HttpClientFactory","permalink":"https://www.odinsam.com/tags/HttpClientFactory/"}],"author":"OdinSam"},{"title":"Hexo Pure主题给Post页面添加keywords","slug":"Hexo-Pure主题给Post页面添加keywords","date":"2021-06-09T00:51:00.000Z","updated":"2021-06-10T10:15:38.606Z","comments":true,"path":"/articles/409f.html","link":"","permalink":"https://www.odinsam.com/articles/409f.html","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。https://hexo.io/zh-cn/ 这里是他的中文文档，无论是结合 Github、Gitee 或者是在私人的云端都可以快速部署，非常高效快捷。为了更好的seo优化，使用pure主题给每一个post页面添加keywords 关键字。","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。https://hexo.io/zh-cn/ 这里是他的中文文档，无论是结合 Github、Gitee 或者是在私人的云端都可以快速部署，非常高效快捷。为了更好的seo优化，使用pure主题给每一个post页面添加keywords 关键字。 找到主题 pure/layout/_common/head.ejs 文件，在 title 标签后添加以下代码: 123456&lt;% if (post.tags &amp;&amp; post.tags.length) &#123; %&gt; &lt;% var kw = &quot;&quot;;post.tags.forEach(t=&gt;&#123; kw+=t.name+&#x27;,&#x27; &#125;);kw = kw.substr(0,kw.length-1) %&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= kw %&gt;&quot; /&gt; &lt;% &#125; else if (config.keywords)&#123; %&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= config.keywords %&gt;&quot; /&gt;&lt;%&#125; %&gt; 这样每一个页面都可以依据发布时的tag生成keywords标签 1&lt;meta name=&quot;keywords&quot; content=&quot;Hexo,Seo,Pure&quot;&gt; 如果发布时没有tag，那么会依据hexo的配置文件(注意不是pure的配置文件) _config.yml 中的 keywords 生成对应的 meta 标签 1&lt;meta name=&quot;keywords&quot; content=&quot;.Net Core,javascript,typescript,html5,css,css3,linux,react,vue,js&quot;&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.odinsam.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.odinsam.com/tags/Hexo/"},{"name":"Seo","slug":"Seo","permalink":"https://www.odinsam.com/tags/Seo/"},{"name":"Pure","slug":"Pure","permalink":"https://www.odinsam.com/tags/Pure/"}],"author":"OdinSam"},{"title":"利用Canal集合RabbitMQ实现数据和缓存同步","slug":"利用Canal集合RabbitMQ实现数据和缓存同步","date":"2021-06-08T21:34:00.000Z","updated":"2021-07-06T15:04:30.781Z","comments":true,"path":"/articles/a3b9.html","link":"","permalink":"https://www.odinsam.com/articles/a3b9.html","excerpt":"Canal的主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。他可以模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议。MySQL master收到dump请求，开始推送 binary log 给 slave (即canal)，canal解析binary log 对象(原始为 byte 流)。","text":"Canal的主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。他可以模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议。MySQL master收到dump请求，开始推送 binary log 给 slave (即canal)，canal解析binary log 对象(原始为 byte 流)。 Canal介绍 Canal 的 Github：https://github.com/alibaba/canal 里边有详细介绍说明以及安装方法。具体不在叙述。 MySql改动 首先需要给mysql创建对应的canal用户 123CREATE USER canal IDENTIFIED BY &#x27;canal&#x27;;GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27;;FLUSH PRIVILEGES; 其次修改 my.cnf 文件并 重启数据库 1234[mysqld]log-bin=mysql-bin # 开启 binlogbinlog-format=ROW # 选择 ROW 模式server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 Canal配置 Canal单机环境(开发代码测试)主要配置两个文件，分别是 conf/canal.properties 文件和 conf/example/instance.properties 文件。具体配置如下: canal.properties 12345678910111213######################################################################################################### 这部分结构是配置文件自带的 只需要写清楚即可，其中 exchange 为 rabbitMQ的exchange的名字####### username 和 password 是 rabbitMQ 的 用户名和密码 (我自己新建了一个rabbitMQ用户)################################################################################################## ######### RabbitMQ ###############################################################rabbitmq.host = 127.0.0.1rabbitmq.virtual.host = /rabbitmq.exchange = canal-exchangerabbitmq.username = canalConsumerrabbitmq.password = canalConsumerrabbitmq.deliveryMode = 最为主要的是要找到配置文件中 canal.serverMode = rabbitMQ 他的默认值是 tcp 切记要改为 rabbitMQ instance.properties 1234567891011121314canal.instance.master.address=127.0.0.1:3306 #数据库的 ip:port canal.instance.dbUsername=canal #数据库的 用户名canal.instance.dbPassword=173Canal~ #数据库的 密码 canal.instance.tsdb.dir=$&#123;canal.file.data.dir:../conf&#125;/$&#123;canal.instance.destination:&#125;canal.instance.tsdb.url=jdbc:h2:$&#123;canal.instance.tsdb.dir&#125;/h2;CACHE_SIZE=1000;MODE=MYSQL;#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb # canal.instance.filter.regex=.*\\\\..* # https://github.com/alibaba/canal/wiki/AdminGuide 搜索 canal.instance.filter.regex 有详细说明canal.instance.filter.regex=db_OdinOIS.Logs # 要监控的库和表 https://github.com/alibaba/canal/wiki/AdminGuide 搜索 canal.instance.filter.regex 有详细说明 canal.mq.topic=canal-routingkey # rabbitMQ 创建 queues 时的 routing key 的值 数据解析 至此如果以上步骤都没有问题的话，执行 ./bin/startup.sh 启动，并在你监控的表中设置增量数据，rabbitMQ 就会有对应数据。获取到的数据为json格式，具体说明如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; // data内为获取到的增量数据 key是数据库对应的字段 value是数据库的值 &quot;data&quot;: [&#123; &quot;id&quot;: &quot;1487&quot;, &quot;Timestamp&quot;: &quot;2021-06-09 05:23:12.538+08:00&quot;, &quot;Level&quot;: &quot;Information&quot;, &quot;Message&quot;: &quot;Entity Framework Core&quot;, &quot;Exception&quot;: null, &quot;Properties&quot;: &quot;&quot;, &quot;_ts&quot;: null &#125;], // 库名 &quot;database&quot;: &quot;db_OdinOIS&quot;, &quot;es&quot;: 1623187400000, &quot;id&quot;: 1, &quot;isDdl&quot;: false, // 字段对应mysql的数据类型 &quot;mysqlType&quot;: &#123; &quot;id&quot;: &quot;int&quot;, &quot;Timestamp&quot;: &quot;varchar(100)&quot;, &quot;Level&quot;: &quot;varchar(15)&quot;, &quot;Message&quot;: &quot;text&quot;, &quot;Exception&quot;: &quot;text&quot;, &quot;Properties&quot;: &quot;text&quot;, &quot;_ts&quot;: &quot;timestamp&quot; &#125;, // 如果是 update 操作这里会是更新前的数据 &quot;old&quot;: null, // 主键 &quot;pkNames&quot;: [&quot;id&quot;], &quot;sql&quot;: &quot;&quot;, &quot;sqlType&quot;: &#123; &quot;id&quot;: 4, &quot;Timestamp&quot;: 12, &quot;Level&quot;: 12, &quot;Message&quot;: 2005, &quot;Exception&quot;: -4, &quot;Properties&quot;: 2005, &quot;_ts&quot;: 93 &#125;, // 表名字 &quot;table&quot;: &quot;Logs&quot;, // 时间戳 &quot;ts&quot;: 1623187530269, // 操作类型 &quot;type&quot;: &quot;INSERT&quot;&#125; 这样我们就可以利用代码从 rabbitMQ 中消费对应的信息，然后再做其他操作。当然也可以利用 Canal 结合 redis 实现 mysql 和缓存数据同步，在利用CacheManager类库，利用redis做挡板，就可以同时实现 redis 缓存和内存缓存同步。这样整个分布式项目就可以实现读写分离、缓存同步。","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.odinsam.com/tags/Mysql/"},{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"Canal","slug":"Canal","permalink":"https://www.odinsam.com/tags/Canal/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://www.odinsam.com/tags/RabbitMQ/"}],"author":"OdinSam"},{"title":"Serilog封装扩展并写入Mysql","slug":"Serilog封装扩展并写入Mysql","date":"2021-06-06T20:45:00.000Z","updated":"2021-06-09T05:36:20.358Z","comments":true,"path":"/articles/b919.html","link":"","permalink":"https://www.odinsam.com/articles/b919.html","excerpt":"Serilog是 .NET 中最著名的结构化日志类库。大多数情况下，中小型项目会将日志直接记录在一个对应的文件夹中比如Logs文件夹，并且可以按照日志的等级创建子文件夹比如errror、debug等等，再按照日期创建子文件最后按照日志文件大小上限做日志文件的划分。在一些大型项目中需要将日志写入数据库，文章讲述如何使用Serilog日志类库在mysql数据库中自动创建logs表并将日志写入表中。","text":"Serilog是 .NET 中最著名的结构化日志类库。大多数情况下，中小型项目会将日志直接记录在一个对应的文件夹中比如Logs文件夹，并且可以按照日志的等级创建子文件夹比如errror、debug等等，再按照日期创建子文件最后按照日志文件大小上限做日志文件的划分。在一些大型项目中需要将日志写入数据库，文章讲述如何使用Serilog日志类库在mysql数据库中自动创建logs表并将日志写入表中。 封装模型： LogWriteFileModel.cs 123456789public class LogWriteFileModel&#123; public string FileName &#123; get; set; &#125; public int FileSizeLimitBytes &#123; get; set; &#125; = 1000000; public bool RollOnFileSizeLimit &#123; get; set; &#125; = true; public bool Shared &#123; get; set; &#125; = true; public TimeSpan FlushToDiskInterval &#123; get; set; &#125; = TimeSpan.FromSeconds(1);&#125; LogWriteToConsoleModel.cs 12345public class LogWriteToConsoleModel&#123; public string OutputTemplate &#123; get; set; &#125; public SystemConsoleTheme ConsoleTheme &#123; get; set; &#125; = SystemConsoleTheme.Colored;&#125; LogWriteMySqlModel.cs 1234public class LogWriteMySqlModel&#123; public string ConnectionString &#123; get; set; &#125;&#125; 扩展类 安装package Serilog.Sinks.MySQL, Version=4.0.0.0，LoggerConfigurationExtends.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243public static class LoggerConfigurationExtends &#123; public static LoggerConfiguration OdinWriteLog(this LoggerConfiguration loggerConfiguration, LogWriteFileModel logWriteFileModel, LogWriteToConsoleModel logWriteToConsole, LogWriteMySqlModel logWriteMySqlModel) &#123; return loggerConfiguration .WriteTo.OdinWrite( LogEventLevel.Debug, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ) .WriteTo.OdinWrite( LogEventLevel.Error, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ) .WriteTo.OdinWrite( LogEventLevel.Fatal, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ) .WriteTo.OdinWrite( LogEventLevel.Information, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ) .WriteTo.OdinWrite( LogEventLevel.Warning, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ); &#125; public static LoggerConfiguration OdinWrite(this LoggerSinkConfiguration loggerSinkConfiguration, LogEventLevel logLevel, LogWriteFileModel logWriteFileModel, LogWriteToConsoleModel logWriteToConsole, LogWriteMySqlModel logWriteMySqlModel) &#123; return loggerSinkConfiguration.Logger(fileLogger =&gt; &#123; var config = SerilogHelper.OdinWriteToFile(fileLogger, logLevel, logWriteFileModel); if (logWriteToConsole != null) &#123; config.WriteTo.Console( outputTemplate: string.IsNullOrEmpty(logWriteToConsole.OutputTemplate) ? &quot;&#123;Timestamp:yyyy-MM-dd HH:mm:ss&#125; [&#123;Level&#125;] &#123;Message&#125;&#123;NewLine&#125;&#123;Exception&#125;&quot; : logWriteToConsole.OutputTemplate, theme: logWriteToConsole.ConsoleTheme ); &#125; if (logWriteMySqlModel != null) config.WriteTo.MySQL(connectionString: logWriteMySqlModel.ConnectionString); &#125;); &#125; &#125; 封装类: SerilogHelper.cs 1234567891011121314151617181920public class SerilogHelper&#123; public static LoggerConfiguration OdinWriteToFile(LoggerConfiguration fileLogger, LogEventLevel logLevel, LogWriteFileModel logWriteModel) &#123; return fileLogger.Filter .ByIncludingOnly(p =&gt; p.Level.Equals(logLevel)) .WriteTo.File( path: string.IsNullOrEmpty(logWriteModel.FileName) ? $&quot;logs/&#123;DateTime.Now.ToString(&quot;yyyyMMdd&quot;)&#125;/log-&#123;DateTime.Now.ToString(&quot;yyyyMMdd&quot;)&#125;-&#123;logLevel.ToString()&#125;.txt&quot; : logWriteModel.FileName, fileSizeLimitBytes: logWriteModel.FileSizeLimitBytes, rollOnFileSizeLimit: logWriteModel.RollOnFileSizeLimit, shared: logWriteModel.Shared, flushToDiskInterval: logWriteModel.FlushToDiskInterval ); &#125;&#125; 使用 1234567891011121314#region Log设置Log.Logger = new LoggerConfiguration() // 最小的日志输出级别 .MinimumLevel.Information() //.MinimumLevel.Information () // 日志调用类命名空间如果以 System 开头，覆盖日志输出最小级别为 Information .MinimumLevel.Override(&quot;System&quot;, LogEventLevel.Information) // 日志调用类命名空间如果以 Microsoft 开头，覆盖日志输出最小级别为 Information .MinimumLevel.Override(&quot;Microsoft&quot;, LogEventLevel.Information) .OdinWriteLog( new LogWriteFileModel &#123; &#125;, new LogWriteToConsoleModel &#123; &#125;, new LogWriteMySqlModel &#123; ConnectionString = Configuration.GetSection(&quot;ProjectConfigOptions:DbEntity:ConnectionString&quot;).Value &#125; ) .CreateLogger();#endregion","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"Serilog","slug":"Serilog","permalink":"https://www.odinsam.com/tags/Serilog/"},{"name":"Log","slug":"Log","permalink":"https://www.odinsam.com/tags/Log/"}],"author":"odinsam"},{"title":"vscode控制台中文乱码","slug":"vscode控制台中文乱码","date":"2021-06-06T03:27:00.000Z","updated":"2021-07-06T15:01:34.061Z","comments":true,"path":"/articles/cda.html","link":"","permalink":"https://www.odinsam.com/articles/cda.html","excerpt":"vscode是现在较为流行的一款开发工具，他可以按照用户对应需要的语言插件进行自定义安装和配置，在使用vscode的过程中发现终端输出控制台输出稳重会出现中文乱码的情况，网上搜索很多的解决方案都是修改系统的GBK，但是发现在修改了GBK以后可能会造成其他程序出现中文乱码以及其他的一些问题，这里我们使用修改PowerShell的OutputEncoding来解决这个问题。仅win10系统测试有效。","text":"vscode是现在较为流行的一款开发工具，他可以按照用户对应需要的语言插件进行自定义安装和配置，在使用vscode的过程中发现终端输出控制台输出稳重会出现中文乱码的情况，网上搜索很多的解决方案都是修改系统的GBK，但是发现在修改了GBK以后可能会造成其他程序出现中文乱码以及其他的一些问题，这里我们使用修改PowerShell的OutputEncoding来解决这个问题。仅win10系统测试有效。 正确方法： 1.打开 Windows PowerShell (管理员)，执行命令： Set-ExecutionPolicy Unrestricted 2.新建文档 profile.ps1 3.用记事本编辑，粘贴以下代码并保存： $OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = New-Object System.Text.UTF8Encoding 4.把 profile.ps1 保存到以下路径： C:\\Windows\\System32\\WindowsPowerShell\\v1.0 5.完成。 6.检测是否成功 打开 PowerShell，执行：chcp 结果为 Active code page: 65001，说明设置成功了","categories":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/categories/VsCode/"}],"tags":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/tags/VsCode/"},{"name":"中文乱码","slug":"中文乱码","permalink":"https://www.odinsam.com/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"}],"author":"odinsam"},{"title":"IdentityServer结合Mysql","slug":"IdentityServer结合Mysql","date":"2021-06-06T03:23:00.000Z","updated":"2021-06-09T05:36:28.805Z","comments":true,"path":"/articles/7094.html","link":"","permalink":"https://www.odinsam.com/articles/7094.html","excerpt":"IdentityServer4 是为 Asp.Net Core 2.0+ 系列量身打造的一款基于 OpenID Connect 和 OAuth 2.0 认证框架，官网提供了对应持久化到SQL Server数据库的方法。但是在持久化到Mysql数据库时，会出现 Specified key was too long 的错误。我们可以通过重写 OnModelCreating 方法的方式解决问题。","text":"IdentityServer4 是为 Asp.Net Core 2.0+ 系列量身打造的一款基于 OpenID Connect 和 OAuth 2.0 认证框架，官网提供了对应持久化到SQL Server数据库的方法。但是在持久化到Mysql数据库时，会出现 Specified key was too long 的错误。我们可以通过重写 OnModelCreating 方法的方式解决问题。 使用 MySql.EntityFrameworkCore ConfigureServices 添加代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041const string connectionString = @&quot;Server=ip;database=databasename;uid=userid;pwd=password;&quot;;var migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name;var mysqlVersion = new MySqlServerVersion(new Version(8, 0, 21));services.AddIdentityServer() .AddDeveloperSigningCredential() // 客户端和资源的数据库存储 // ConfigurationDbContext // dotnet ef migrations add ConfigDbContext -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfiguragtionDb // dotnet ef database update -c ConfigurationDbContext .AddConfigurationStore(opt =&gt; &#123; opt.ConfigureDbContext = context =&gt; &#123; context.UseMySQL(_Options.DbEntity.ConnectionString, sql =&gt; sql.MigrationsAssembly(migrationsAssembly)); &#125;; &#125;) // 令牌和授权码的数据库存储 // PersistedGrantDbContext // dotnet ef migrations add OperationContext -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/OperationDb // dotnet ef database update -c PersistedGrantDbContext .AddOperationalStore(opt =&gt; &#123; opt.ConfigureDbContext = context =&gt; context.UseMySQL(_Options.DbEntity.ConnectionString, sql =&gt; sql.MigrationsAssembly(migrationsAssembly)); opt.EnableTokenCleanup = true; opt.TokenCleanupInterval = 30; &#125;); services.AddIdentityServerDbContext&lt;ConfigurationDbContext&gt;(options =&gt; &#123; options.ConfigureDbContext = builder =&gt; builder.UseMySQL(_Options.DbEntity.ConnectionString, db =&gt; db.MigrationsAssembly(migrationsAssembly)); &#125;) .AddIdentityServerDbContext&lt;PersistedGrantDbContext&gt;(options =&gt; &#123; options.ConfigureDbContext = builder =&gt; builder.UseMySQL(_Options.DbEntity.ConnectionString, db =&gt; db.MigrationsAssembly(migrationsAssembly)); &#125;); // 更改Identity中关于用户和角色的处理到Entityframework // dotnet ef migrations add UserStoreContext -c OdinIdentityEntities -o Data/Migrations/IdentityServer/UserDb // dotnet ef database update -c OdinIdentityEntities &#125; 安装包如下 IdentityServer4 IdentityServer4.EntityFramework Microsoft.EntityFrameworkCore.Tools Microsoft.AspNet.Identity.EntityFramework Microsoft.EntityFrameworkCore IdentityServer4.AspNetIdentity 添加 ApplicationDbContext.cs、ApplicationUser.cs 和 ApplicationRole.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ApplicationDbContext : Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext&lt;ApplicationUser, ApplicationRole, Guid&gt;&#123; public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options) &#123; &#125; public DbSet&lt;IdUser&gt; IdentityUsers &#123; get; set; &#125; public DbSet&lt;IdUser&gt; IdentityRoles &#123; get; set; &#125; public DbSet&lt;IdentityUserClaim&gt; IdentityUserClaim &#123; get; set; &#125; // 其他表 protected override void OnModelCreating(ModelBuilder builder) &#123; base.OnModelCreating(builder); // mysql 修改索引长度 解决 Specified key was too long; max key length is 3072 bytes builder.Entity(&quot;Microsoft.AspNetCore.Identity.IdentityRole&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;Id&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); builder.Entity(&quot;Microsoft.AspNetCore.Identity.IdentityUser&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;Id&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); builder.Entity(&quot;Microsoft.AspNetCore.Identity.IdentityUserLogin&lt;string&gt;&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;LoginProvider&quot;) .HasColumnType(&quot;varchar(256)&quot;); b.Property&lt;string&gt;(&quot;ProviderKey&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); builder.Entity(&quot;Microsoft.AspNetCore.Identity.IdentityUserToken&lt;string&gt;&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;LoginProvider&quot;) .HasColumnType(&quot;varchar(256)&quot;); b.Property&lt;string&gt;(&quot;Name&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); builder.Entity(&quot;OdinOIS.Models.DbModels.IdentityUserStore.IdentityUserClaim&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;ClaimId&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); &#125;&#125; 1234public class ApplicationUser : Microsoft.AspNetCore.Identity.IdentityUser&lt;Guid&gt;&#123; //可以在这里扩展&#125; 1234public class ApplicationRole : Microsoft.AspNetCore.Identity.IdentityRole&lt;Guid&gt;&#123;&#125; 控制台输入 dotnet ef migrations add ConfigDbContext -c ConfigurationDbContext -o Date\\Migrations\\IdentityServer\\ConfiguragtionDb dotnet ef database update ConfigDbContext -c ConfigurationDbContext dotnet ef migrations add ConfigDbContext -c PersistedGrantDbContext -o Date\\Migrations\\IdentityServer\\PersistedGrantDb dotnet ef database update ConfigDbContext -c PersistedGrantDbContext dotnet ef migrations add UserStoreContext -c OdinIdentityEntities -o Data/Migrations/IdentityServer/UserDb dotnet ef database update -c OdinIdentityEntities","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"https://www.odinsam.com/tags/IdentityServer4/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.odinsam.com/tags/Mysql/"},{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"}],"author":"odinsam"},{"title":"vscode无法使用nuget的小问题","slug":"vscode无法使用nuget的小问题","date":"2021-05-28T21:29:00.000Z","updated":"2021-07-06T15:01:28.797Z","comments":true,"path":"/articles/80b6.html","link":"","permalink":"https://www.odinsam.com/articles/80b6.html","excerpt":"在使用vscode的过程使用NuGet Package Manager插件安装Package包的时候会出现 &quot;Versioning information could not be retrieved from the NuGet package repository. &quot; 的错误导致无法安装Package包，可以修改fetchPackageVersions.js解决问题。","text":"在使用vscode的过程使用NuGet Package Manager插件安装Package包的时候会出现 &quot;Versioning information could not be retrieved from the NuGet package repository. &quot; 的错误导致无法安装Package包，可以修改fetchPackageVersions.js解决问题。 问题： “Versioning information could not be retrieved from the NuGet package repository. Please try again later.” 解决方式： 打开 /Users/用户名/.vscode/extensions/jmrog.vscode-nuget-package-manager-1.1.6/out/src/actions/add-methods/fetchPackageVersions.js 修改后的代码 加上 .toLowerCase() 1...node_fetch_1.default(`$&#123;versionsUrl&#125;$&#123;selectedPackageName.toLowerCase()&#125;/index.json`, utils_1.getFetchOptions(vscode.workspace.getConfiguration(&#x27;http&#x27;)))","categories":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/categories/VsCode/"}],"tags":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/tags/VsCode/"},{"name":"Nuget","slug":"Nuget","permalink":"https://www.odinsam.com/tags/Nuget/"}],"author":"odinsam"},{"title":"关于net core动态加载配置文件的小问题","slug":"关于net-core动态加载配置文件的小问题","date":"2021-05-27T13:57:00.000Z","updated":"2021-06-10T09:57:40.509Z","comments":true,"path":"/articles/8950.html","link":"","permalink":"https://www.odinsam.com/articles/8950.html","excerpt":"在我的项目当中配置文件较多，例如包括 项目自身的配置文件、consul.config、redis.cofing、identityServer.config 等等，要在项目启动的时候动态加载所有的配置文件。在我的项目中有 serverConfig 文件夹中有对应的所有的配置文件需要动态加载所有文件，在加载过程中发现按照文件路径无法加载 win10 环境。最后发现加载时不能使用绝对路径需要使用相对路径。","text":"在我的项目当中配置文件较多，例如包括 项目自身的配置文件、consul.config、redis.cofing、identityServer.config 等等，要在项目启动的时候动态加载所有的配置文件。在我的项目中有 serverConfig 文件夹中有对应的所有的配置文件需要动态加载所有文件，在加载过程中发现按照文件路径无法加载 win10 环境。最后发现加载时不能使用绝对路径需要使用相对路径。 需求场景: serverConfig 中有对应的一系列配置文件。其中 cnf.json 为主配置文件,里边有当前项目的运行环境的配置，还有其他的文件夹以及对应的其他的配置文件。 现在需要在Config Builder之前递归加载所有的配置文件。 问题: 在编码后运行发现，总是找不对对应的配置文件（win 10 环境），代码如下: 1234567891011121314151617181920public void LoadConfigFiles(string currentPath, IConfigurationBuilder config)&#123; foreach (var item in Directory.GetFiles(currentPath)) &#123; if (Path.GetFileName(item) != &quot;cnf.json&quot;) &#123; if (File.Exists(item)) config.Add(new JsonConfigurationSource &#123; Path = item, Optional = false, ReloadOnChange = true &#125;); &#125; &#125; var dir = Directory.GetDirectories(currentPath); if (dir != null &amp;&amp; dir.Length &gt; 0) &#123; foreach (var dirItem in dir) &#123; if (!Path.GetDirectoryName(dirItem).EndsWith(Path.Combine(FileHelper.DirectorySeparatorChar, &quot;envConfig&quot;))) LoadConfigFiles(dirItem, config); &#125; &#125;&#125; 代码总是报错，提示找不对config文件 解决: 最后发现 config.add 加载的文件路径需要是相对路径而不能是绝对路径，解决代码如下: 12345678910111213141516171819202122public void LoadConfigFiles(string currentPath, IConfigurationBuilder config, string rootPath)&#123; foreach (var item in Directory.GetFiles(currentPath)) &#123; if (Path.GetFileName(item) != &quot;cnf.json&quot;) &#123; var configPath = item.Replace(rootPath, &quot;&quot;); if (File.Exists(item)) config.Add(new JsonConfigurationSource &#123; Path = configPath, Optional = false, ReloadOnChange = true &#125;); //config.add 加载的文件 路径需要是相对路径 而不能是绝对路径 &#125; &#125; var dir = Directory.GetDirectories(currentPath); if (dir != null &amp;&amp; dir.Length &gt; 0) &#123; foreach (var dirItem in dir) &#123; if (!Path.GetDirectoryName(dirItem).EndsWith(Path.Combine(FileHelper.DirectorySeparatorChar, &quot;envConfig&quot;))) LoadConfigFiles(dirItem, config, rootPath); &#125; &#125;&#125;","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"}],"author":"odinsam"}],"categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"},{"name":"mysql","slug":"mysql","permalink":"https://www.odinsam.com/categories/mysql/"},{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"},{"name":"Git","slug":"Git","permalink":"https://www.odinsam.com/categories/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.odinsam.com/categories/Hexo/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/categories/VsCode/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"原型链","slug":"原型链","permalink":"https://www.odinsam.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://www.odinsam.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"name":"mysql","slug":"mysql","permalink":"https://www.odinsam.com/tags/mysql/"},{"name":"链路追踪","slug":"链路追踪","permalink":"https://www.odinsam.com/tags/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"},{"name":"ApiLinkMonitor","slug":"ApiLinkMonitor","permalink":"https://www.odinsam.com/tags/ApiLinkMonitor/"},{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"微服务","slug":"微服务","permalink":"https://www.odinsam.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"BackgroundService","slug":"BackgroundService","permalink":"https://www.odinsam.com/tags/BackgroundService/"},{"name":"后台服务","slug":"后台服务","permalink":"https://www.odinsam.com/tags/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/"},{"name":"Mapster","slug":"Mapster","permalink":"https://www.odinsam.com/tags/Mapster/"},{"name":"Git","slug":"Git","permalink":"https://www.odinsam.com/tags/Git/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/tags/VsCode/"},{"name":"插件","slug":"插件","permalink":"https://www.odinsam.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"SqlSugar","slug":"SqlSugar","permalink":"https://www.odinsam.com/tags/SqlSugar/"},{"name":"Cap","slug":"Cap","permalink":"https://www.odinsam.com/tags/Cap/"},{"name":"HttpClientFactory","slug":"HttpClientFactory","permalink":"https://www.odinsam.com/tags/HttpClientFactory/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.odinsam.com/tags/Hexo/"},{"name":"Seo","slug":"Seo","permalink":"https://www.odinsam.com/tags/Seo/"},{"name":"Pure","slug":"Pure","permalink":"https://www.odinsam.com/tags/Pure/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.odinsam.com/tags/Mysql/"},{"name":"Canal","slug":"Canal","permalink":"https://www.odinsam.com/tags/Canal/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://www.odinsam.com/tags/RabbitMQ/"},{"name":"Serilog","slug":"Serilog","permalink":"https://www.odinsam.com/tags/Serilog/"},{"name":"Log","slug":"Log","permalink":"https://www.odinsam.com/tags/Log/"},{"name":"中文乱码","slug":"中文乱码","permalink":"https://www.odinsam.com/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"},{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"https://www.odinsam.com/tags/IdentityServer4/"},{"name":"Nuget","slug":"Nuget","permalink":"https://www.odinsam.com/tags/Nuget/"}]}