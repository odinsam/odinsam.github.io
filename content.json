{"meta":{"title":"OdinSam's blogs-一个热爱编程性格开朗的Coder","subtitle":"","description":"OdinSam的博客，记录和分享.Net Core后端框架、React、Vue等前端框架在工作和学习过程中使用的点点滴滴。坚定的.Net Core拥护者，性格开朗喜欢折腾，爱写代码也喜欢看老电影，老电视剧，听老歌。并将这些作为一种生活乐趣。","author":"OdinSam","url":"https://www.odinsam.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-07-07T09:14:55.114Z","updated":"2021-07-02T17:07:05.000Z","comments":false,"path":"/404.html","permalink":"https://www.odinsam.com/404.html","excerpt":"","text":"404"},{"title":"书单","date":"2022-07-07T09:14:55.111Z","updated":"2021-05-23T16:01:47.000Z","comments":false,"path":"books/index.html","permalink":"https://www.odinsam.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-07T09:14:55.108Z","updated":"2021-05-25T13:01:43.000Z","comments":false,"path":"about/index.html","permalink":"https://www.odinsam.com/about/index.html","excerpt":"","text":"一个热爱编程性格开朗的 Coder，喜欢折腾，爱写代码，并将它作为一种生活乐趣，标准技术宅一个。也喜欢看老电影，老电视剧，有精力的老年 Coder。 sequenceDiagram participant z as today participant l as tomorrow loop day after day z->>l: coding？ l-->>z: yeah,happy coding activate z Note left of z: think await alt not yet coding z-xl: no else conding z-xl: happy end opt find happy l-->z: Coding makes us happy Work end end"},{"title":"分类","date":"2022-07-07T09:14:55.115Z","updated":"2021-05-23T16:01:47.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.odinsam.com/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2019-11-23T13:10:10.000Z","updated":"2021-07-02T16:57:53.000Z","comments":true,"path":"404.html","permalink":"https://www.odinsam.com/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-07T09:14:55.112Z","updated":"2021-05-23T16:01:47.000Z","comments":true,"path":"links/index.html","permalink":"https://www.odinsam.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-07-07T09:14:55.091Z","updated":"2021-05-23T16:01:47.000Z","comments":false,"path":"repository/index.html","permalink":"https://www.odinsam.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-07T09:14:55.112Z","updated":"2021-05-23T16:01:47.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.odinsam.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue2.0进阶 - 10. nextTick与props传递函数","slug":"Vue2-0进阶-10-nextTick与props传递函数","date":"2022-10-19T14:39:00.000Z","updated":"2022-10-19T14:43:00.124Z","comments":true,"path":"/articles/fc6a.html","link":"","permalink":"https://www.odinsam.com/articles/fc6a.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 10 章: nextTick与props传递函数","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 10 章: nextTick与props传递函数 完整代码可以在 GitHub 。 nextTick与props传递函数 this.$nextTick(回调函数) 下一次dom更新结束后执行回调函数 使用时机： 当改变数据后，要基于更新后的新dom进行某些操作时，使用nextTick利用回调函数执行操作 父组件可以通过props给子组件传递函数，当子组件执行函数回调时，回传数据达到子组件向父组件传递数据的目的 student.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;!-- nextTick与props传递函数 1. this.$nextTick(回调函数) 下一次dom更新结束后执行回调函数 2. 使用时机： 当改变数据后，要基于更新后的新dom进行某些操作时，使用nextTick利用回调函数执行操作 3. 父组件可以通过props给子组件传递函数，当子组件执行函数回调时，回传数据达到子组件向父组件传递数据的目的 --&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;span v-if=&quot;!isEdit&quot;&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt; &lt;span v-else&gt;&lt;input ref=&quot;txtStuName&quot; type=&quot;text&quot; v-model=&quot;stuName&quot;&gt;&lt;/span&gt; &lt;br/&gt; &lt;button @click=&quot;editOrOkClick&quot;&gt;&#123;&#123;btnText[isEdit]&#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isEdit:false, stuName: &#x27;odinsam&#x27;, btnText:&#123;true:&#x27;确定&#x27;,false:&#x27;编辑&#x27;&#125; &#125; &#125;, //app组件传递的回调函数 props:[&#x27;getStuName&#x27;], methods: &#123; editOrOkClick() &#123; if (this.isEdit) &#123; //子组件调用父组件通过props传递的回调函数向父组件传递数据 this.getStuName(&#123;stuName:this.stuName&#125;); &#125; this.isEdit = !this.isEdit; // 在本次操作执行完成dom修改后，执行回调函数，使新出现的文本框获得焦点 this.$nextTick(function () &#123; if (this.isEdit) &#123; this.$refs.txtStuName.focus(); &#125; &#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:200px; padding:50px; margin-left:50px;&#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div class=&quot;dvapp&quot;&gt; &lt;h2&gt;app组件&lt;/h2&gt; &lt;br/&gt; &lt;span&gt;学生的姓名是:&#123;&#123;stuName&#125;&#125;&lt;/span&gt; &lt;Student :getStuName=&quot;getStuName&quot;&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; stuName:&#x27;&#x27; &#125; &#125;, components: &#123; Student &#125;, methods: &#123; getStuName(param) &#123; console.log(param); this.stuName = param.stuName; &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.dvapp&#123; background-color: aquamarine;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"props","slug":"props","permalink":"https://www.odinsam.com/tags/props/"},{"name":"nextTick","slug":"nextTick","permalink":"https://www.odinsam.com/tags/nextTick/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 09. 消息订阅与发布","slug":"Vue2-0进阶-09-消息订阅与发布","date":"2022-10-19T13:51:00.000Z","updated":"2022-10-19T14:09:18.490Z","comments":true,"path":"/articles/ac9b.html","link":"","permalink":"https://www.odinsam.com/articles/ac9b.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 09 章: 消息订阅与发布","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 09 章: 消息订阅与发布 完整代码可以在 GitHub 。 消息订阅与发布 yarn add pubsub-js 安装消息订阅与发布框架 订阅消息 mounted时 this.pubId = pubsub.subscribe(‘消息名称’, (消息名称, 消息传递数据) =&gt; {}); 消息传递数据可以是字符串、数据、数据或对象 取消订阅消息 beforeDestroy时 pubsub.unsubscribe(this.pubId) 组件发布消息 pubsub.publish(‘消息名称’,消息传递数据}) app.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=&quot;dvapp&quot;&gt; &lt;!-- 消息订阅与发布 1. yarn add pubsub-js 安装消息订阅与发布框架 2. 订阅消息 mounted时 this.pubId = pubsub.subscribe(&#x27;消息名称&#x27;, (消息名称, 消息传递数据) =&gt; &#123;&#125;); 消息传递数据可以是字符串、数据、数据或对象 3. 取消订阅消息 beforeDestroy时 pubsub.unsubscribe(this.pubId) 4. 组件发布消息 pubsub.publish(&#x27;消息名称&#x27;,消息传递数据&#125;) --&gt; &lt;h2&gt;app组件&lt;/h2&gt;&lt;br/&gt; &lt;span&gt;学生的姓名是:&#123;&#123;stuName&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;Student ref=&quot;stu&quot;&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import pubsub from &#x27;pubsub-js&#x27;;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; stuName:&#x27;&#x27; &#125; &#125;, components: &#123; Student &#125;, methods: &#123; &#125;, mounted() &#123; this.pubId = pubsub.subscribe(&#x27;subMessage&#x27;, (messasgeName, param) =&gt; &#123; console.log(&#x27;messasgeName&#x27;,messasgeName); this.stuName = param.stuName &#125;); &#125;, beforeDestroy() &#123; pubsub.unsubscribe(this.pubId) &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.dvapp&#123; background-color: aquamarine;&#125;&lt;/style&gt; student.vue1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;span&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;button @click=&quot;publishMessageClick&quot;&gt;发布消息传递数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import pubsub from &#x27;pubsub-js&#x27;;export default &#123; data() &#123; return &#123; stuName:&#x27;odinsam&#x27; &#125; &#125;, methods: &#123; publishMessageClick() &#123; pubsub.publish(&#x27;subMessage&#x27;,&#123;stuName:this.stuName&#125;) &#125; &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:200px; padding:50px; margin-left:50px;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"消息订阅","slug":"消息订阅","permalink":"https://www.odinsam.com/tags/%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85/"},{"name":"消息发布","slug":"消息发布","permalink":"https://www.odinsam.com/tags/%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83/"},{"name":"subscribe","slug":"subscribe","permalink":"https://www.odinsam.com/tags/subscribe/"},{"name":"unsubscribe","slug":"unsubscribe","permalink":"https://www.odinsam.com/tags/unsubscribe/"},{"name":"publish","slug":"publish","permalink":"https://www.odinsam.com/tags/publish/"},{"name":"pubsub-js","slug":"pubsub-js","permalink":"https://www.odinsam.com/tags/pubsub-js/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 08. 全局事件总线","slug":"Vue2-0进阶-08-全局事件总线","date":"2022-10-19T13:41:00.000Z","updated":"2022-10-19T13:54:08.135Z","comments":true,"path":"/articles/10d9.html","link":"","permalink":"https://www.odinsam.com/articles/10d9.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 08 章: 全局事件总线","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 08 章: 全局事件总线 完整代码可以在 GitHub 。 vue全局事件总线 一种组件间通信的方式，适用于任意组件通信 在main.js中通过 beforeCreate(){ Vue.prototype.$bus = this; } 安装全局事件总线 主要利用的原理是 VueComponent.prototype.__proto__ === Vue.prototype vc可以使用在vm的原型上添加的属性、方法来实现. 通信方式主要依靠自定义事件，在需要通信的双方(app.vue/student.vue)添加自定义事件和处理自定义事件. main.js123456789101112131415161718import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;Vue.config.productionTip = false;/** 全局事件总线: 1. 一种组件间通信的方式，适用于任意组件通信 2. 在main.js中通过 beforeCreate()&#123; Vue.prototype.$bus = this; &#125; 安装全局事件总线 3. 主要利用的原理是 VueComponent.prototype.__proto__ === Vue.prototype vc可以使用在vm的原型上添加的属性、方法来实现. 4. 通信方式主要依靠自定义事件，在需要通信的双方(app.vue/student.vue)添加自定义事件和处理自定义事件. */new Vue(&#123; render: (h) =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this; &#125;&#125;).$mount(&#x27;#app&#x27;); app.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div class=&quot;dvapp&quot;&gt; &lt;!-- --&gt; &lt;h2&gt;app组件&lt;/h2&gt;&lt;br/&gt; &lt;span&gt;学生的姓名是:&#123;&#123;stuName&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;Student ref=&quot;stu&quot;&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; stuName:&#x27;&#x27;, &#125; &#125;, components: &#123; Student &#125;, mounted() &#123; //给student添加自定义事件 this.$bus.$on(&#x27;customEvent&#x27;, (param) =&gt; &#123; this.stuName = param.name; &#125;); &#125;, beforeDestroy() &#123; this.$bus.off(&#x27;customEvent&#x27;); &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.dvapp&#123; background-color: aquamarine;&#125;&lt;/style&gt; student.vue1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;span&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt; &lt;button @click=&quot;busEventClick&quot;&gt;通过全局事件总线触发事件传递数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; stuName:&#x27;odinsam-eventBus&#x27; &#125; &#125;, methods: &#123; busEventClick() &#123; console.log(&#x27;function busEventClick&#x27;); this.$bus.$emit(&#x27;customEvent&#x27;,&#123;name:this.stuName&#125;); &#125; &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:200px; padding:50px; margin-left:50px;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"eventbus","slug":"eventbus","permalink":"https://www.odinsam.com/tags/eventbus/"},{"name":"全局事件总线","slug":"全局事件总线","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 07. vue自定义事件","slug":"Vue2-0进阶-07-自定义事件","date":"2022-10-19T13:14:00.000Z","updated":"2022-10-19T13:18:48.260Z","comments":true,"path":"/articles/e1f2.html","link":"","permalink":"https://www.odinsam.com/articles/e1f2.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 07 章: vue自定义事件","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 07 章: vue自定义事件 完整代码可以在 GitHub 。 vue自定义事件 可以给组件使用 v-on:自定义事件=“事件处理方法” 或者 @自定义事件=“事件处理方法” 来绑定并处理自定义事件.适用于子组件给父组件传递数据 在组件中 使用 this.$emit(‘自定义事件’,参数) 的形式触发自定义事件.参数可以是 字符串、数值、数组或者对象。 也可以通过 ref=‘refName’ 在mounted中 使用 $on 的方式绑定并处理自定义事件 mounted中使用 this.refs.refName.refs.refName.refs.refName.on(‘自定义事件’,function(参数){ })的方式绑定并处理 ref结合mounted与$on的写法更灵活，比如延迟触发、axios后再处理事件 在绑定的组件可以使用 this.$off() 解绑自定义事件. this.$off(‘eventName’) 解绑一个自定义事件 this.$off([‘eventName1’,‘eventName2’]) 解绑多个自定义事件 this.$off() 解绑所有的自定义事件 如果组件被销毁，那么绑定的自定义事件不再有效果。 注意: mounted 中 $on的回调函数中,this是当前绑定自定事件的组件对象vc，而不是vue对象vm。 如果需要vm则需要将回调函数写为箭头函数 student.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;span&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;button @click=&quot;sendStuName&quot;&gt;自定义事件-回传学生的名字&lt;/button&gt;&lt;br/&gt; &lt;button @click=&quot;unbind&quot;&gt;解绑自定义事件&lt;/button&gt;&lt;br/&gt; &lt;button @click=&quot;destoryStu&quot;&gt;销毁组件&lt;/button&gt;&lt;br/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; stuName:&#x27;odinsam&#x27; &#125; &#125;, props:[&#x27;title&#x27;], methods: &#123; sendStuName() &#123; console.log(&#x27;function sendStuName&#x27;); //触发自定义事件 customEvent,传参对象 this.$emit(&#x27;customEvent&#x27;,&#123;name:this.stuName&#125;) &#125;, unbind() &#123; //解绑一个自定义事件 this.$off(&#x27;customEvent&#x27;) //解绑多个自定义事件 this.$off([&#x27;customEvent&#x27;]) // 解绑所有的自定义事件 this.$off() &#125;, destoryStu() &#123; // 销毁当前组件对象 this.$destroy(); &#125; &#125;, unbind: &#123; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:300px; padding:50px; margin-left:50px;&#125;&lt;/style&gt; app.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;template&gt; &lt;div class=&quot;dvapp&quot;&gt; &lt;!-- vue自定义事件 1. 可以给组件使用 v-on:自定义事件=&quot;事件处理方法&quot; 或者 @自定义事件=&quot;事件处理方法&quot; 来绑定并处理自定义事件.适用于子组件给父组件传递数据 2. 在组件中 使用 this.$emit(&#x27;自定义事件&#x27;,参数) 的形式触发自定义事件.参数可以是 字符串、数值、数组或者对象。 2. 也可以通过 ref=&#x27;refName&#x27; 在mounted中 使用 $on 的方式绑定并处理自定义事件 3. mounted中使用 this.$refs.refName.$on(&#x27;自定义事件&#x27;,function(参数)&#123; &#125;)的方式绑定并处理 4. ref结合mounted与$on的写法更灵活，比如延迟触发、axios后再处理事件 5. 在绑定的组件可以使用 this.$off() 解绑自定义事件. this.$off(&#x27;eventName&#x27;) 解绑一个自定义事件 this.$off([&#x27;eventName1&#x27;,&#x27;eventName2&#x27;]) 解绑多个自定义事件 this.$off() 解绑所有的自定义事件 6. 如果组件被销毁，那么绑定的自定义事件不再有效果。 7. 注意: mounted 中 $on的回调函数中,this是当前绑定自定事件的组件对象vc，而不是vue对象vm。 如果需要vm则需要将回调函数写为箭头函数 --&gt; &lt;h2&gt;app组件&lt;/h2&gt; &lt;span&gt;学生组件的姓名是:&#123;&#123;stuName&#125;&#125;&lt;/span&gt; &lt;!--组件student 绑定自定义事件customEvent 事件处理方法getStuName --&gt; &lt;Student v-on:customEvent=&quot;getStuName&quot; title=&quot;v-on方式绑定自定义事件&quot;&gt;&lt;/Student&gt; &lt;Student @customEvent=&quot;getStuName&quot; title=&quot;@ 方式绑定自定义事件&quot;&gt;&lt;/Student&gt; &lt;Student ref=&quot;stu&quot; title=&quot;ref emit方式绑定自定义事件&quot;&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; stuName:&#x27;&#x27; &#125; &#125;, components: &#123; Student &#125;, methods: &#123; // 直接处理自定义事件 getStuName(param) &#123; console.log(&#x27;param&#x27;, param); this.stuName = param.name; &#125; &#125;, mounted() &#123; // 通过 mounted+$refs+$on 的方式处理自定时间。方式更灵活。 例如延迟处理、axios后处理等等. // 回调函数的this是绑定自定事件的组件即stu组件，无法获取到当前app组件的stuName，需要改为箭头函数或者使用注释行的代码 this.$refs.stu.$on(&#x27;customEvent&#x27;,(param)=&gt; &#123; console.log(&#x27;this.stu.$on&#x27;, param); this.stuName = param.name; &#125;) // this.$refs.stu.$on(&#x27;customEvent&#x27;,getStuName) &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.dvapp&#123; background-color: aquamarine; display: flex; justify-content: space-evenly;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"mounted","slug":"mounted","permalink":"https://www.odinsam.com/tags/mounted/"},{"name":"emit","slug":"emit","permalink":"https://www.odinsam.com/tags/emit/"},{"name":"on","slug":"on","permalink":"https://www.odinsam.com/tags/on/"},{"name":"off","slug":"off","permalink":"https://www.odinsam.com/tags/off/"},{"name":"refs","slug":"refs","permalink":"https://www.odinsam.com/tags/refs/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 06. webStorage浏览器的本地存储","slug":"Vue2-0进阶-06-webStorage浏览器的本地存储","date":"2022-10-19T07:53:00.000Z","updated":"2022-10-19T07:58:10.051Z","comments":true,"path":"/articles/fef3.html","link":"","permalink":"https://www.odinsam.com/articles/fef3.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 06 章: webStorage浏览器的本地存储","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 06 章: webStorage浏览器的本地存储 完整代码可以在 GitHub 。 webStorage浏览器的本地存储 浏览器通过 window.sessionStorage 和 window.localStorage 属性实现本地存储 相关api xxxStorage.setItem(‘key’,‘value’) 存储数据 xxxStorage.getItem(‘key’) 读取数据 xxxStorage.removeItem(‘key’) 删除某个数据 xxxStorage.clear() 清空所有数据 sessionStorage 存储的内容会随着浏览器的关闭而消失. localStorage 存储的内容需要手动调用api清除 xxxStorage.getItem(‘key’) 如果key不存在，则返回null JSON.parse(null) 返回的依然是null Student.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model.lazy=&quot;addStuName&quot; @keyup.enter=&quot;addStu&quot;&gt;&lt;br/&gt; &lt;ul&gt; &lt;li v-for=&quot;stu in stus&quot; :key=&quot;stu.id&quot;&gt;&#123;&#123;stu.stuName&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;changeStuName&quot;&gt;修改第一个学生的姓名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; addStuName: &#x27;&#x27;, //从localStorage中获取数据 如果为null则返回空数组。确保用户打开浏览器时显示的是上次保存在localStorage中的数据 stus: JSON.parse(localStorage.getItem(&#x27;stu&#x27;)) || [] &#125; &#125;, methods: &#123; addStu() &#123; const newStu = &#123; id: this.stus.length, stuName: this.addStuName &#125;; this.stus.push(newStu); this.addStuName=&#x27;&#x27; &#125;, //修改第一个学生的姓名，此时需要开启深度监视，否则无法watch无法监视到stu内部的元素属性的修改，就无法触发监视事件（修改localStorage中的数据） changeStuName() &#123; this.stus[0].stuName = this.stus[0].stuName+&#x27;change&#x27; &#125; &#125;, watch: &#123; stus: &#123; //放弃watch的简写方式开启深度监视，确保当修改了stu数组内部元素的属性后依旧可以监视到数据改变并存储到localStorage中 deep: true, handler(value) &#123; localStorage.setItem(&#x27;stu&#x27;,JSON.stringify(value)) &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:200px; padding:50px; margin-left:50px;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"localStorage","slug":"localStorage","permalink":"https://www.odinsam.com/tags/localStorage/"},{"name":"sessionStorage","slug":"sessionStorage","permalink":"https://www.odinsam.com/tags/sessionStorage/"},{"name":"本地存储","slug":"本地存储","permalink":"https://www.odinsam.com/tags/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"},{"name":"webStorage","slug":"webStorage","permalink":"https://www.odinsam.com/tags/webStorage/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 05. vue的style","slug":"Vue2-0进阶-05-vue的style","date":"2022-10-18T12:43:00.000Z","updated":"2022-10-18T12:45:55.536Z","comments":true,"path":"/articles/4576.html","link":"","permalink":"https://www.odinsam.com/articles/4576.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 05 章: vue的style","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 05 章: vue的style 完整代码可以在 GitHub 。 vue的style 多个组件的style可能会出现class重名的情况，当class重名，后引入的组件样式会覆盖之前的同名样式 可以在组件的 style 标签中添加 scoped属性，让当前style仅作用于当前组件(app的style不加scoped) style 标签还有lang属性，默认是css。若要修改less，需注意:需要添加 less-loader. npm view webpack version 可以查看对应版本 vue2 webpack使用的4.46 less-load 8以后得版本是为了迎合webpack5 所以需要安装less-loader 7版本 安装 npm i less-loader@7 student.vue12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;span class=&quot;namecls&quot;&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;span class=&quot;lessname&quot;&gt;less 样式&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; stuName:&#x27;odinsam&#x27; &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.studv&#123; background-color:bisque; width:400px; padding:50px; margin-left:50px; .lessname &#123; font-size:30px; &#125;&#125;.namecls &#123; color:blue; &#125;&lt;/style&gt; school.vue1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;schooldv&quot;&gt; &lt;h2&gt;School组件&lt;/h2&gt; &lt;span class=&quot;namecls&quot;&gt;姓名：&#123;&#123;schoolName&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; schoolName:&#x27;vue学校&#x27; &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped lang=&quot;css&quot;&gt;.schooldv&#123; background-color:cadetblue; width:200px; padding:50px; margin-left:50px;&#125;.namecls&#123; color:red;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"style","slug":"style","permalink":"https://www.odinsam.com/tags/style/"},{"name":"less","slug":"less","permalink":"https://www.odinsam.com/tags/less/"},{"name":"scoped","slug":"scoped","permalink":"https://www.odinsam.com/tags/scoped/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 04. plugins插件","slug":"Vue2-0进阶-04-plugins插件","date":"2022-10-18T12:18:00.000Z","updated":"2022-10-18T13:06:35.109Z","comments":true,"path":"/articles/ec79.html","link":"","permalink":"https://www.odinsam.com/articles/ec79.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 04 章: plugins插件","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 04 章: plugins插件 完整代码可以在 GitHub 。 plugins插件 包含install方法的对象，install的第一个参数是vue，第二个以后得参数是插件使用者传递的数据 插件可以给vue添加实例方法、实例属性 使用插件： 在创建Vue实例前 Vue.use(plugins, { value1: ‘value1’, value2: ‘value2’ }); 插件也可以 添加全局过滤器、添加全局指令、添加全局混入 示例代码 plugins1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* vue插件 1. 包含install方法的对象，install的第一个参数是vue，第二个以后得参数是插件使用者传递的数据 2. 插件可以给vue添加实例方法、实例属性 3. 使用插件： 在创建Vue实例前 Vue.use(plugins, &#123; value1: &#x27;value1&#x27;, value2: &#x27;value2&#x27; &#125;); 4. 插件也可以 添加全局过滤器、添加全局指令、添加全局混入*/export default &#123; install(Vue, options) &#123; console.log(&#x27;install 插件&#x27;); console.log(&#x27;options&#x27;, options); //添加实例方法、实例属性 Vue.prototype.pluginMethod = function (value) &#123; console.log(&#x27;invoke plugins myMethod&#x27;); console.log(&#x27;myMethod param value&#x27;, value); &#125;; Vue.prototype.pluginPrototype = &#x27;odinsam plugins&#x27;; //添加全局过滤器 Vue.filter(&#x27;odinFilter&#x27;, function (value) &#123; console.log(&#x27;odinFilter 被调用&#x27;); return value + &#x27;-odinFilter 被调用&#x27;; &#125;); //添加全局指令 Vue.directive(&#x27;big&#x27;, &#123; bind(ele, binding) &#123; console.log( &#x27;1次调用 - 当指令与元素绑定成功时调用，在内存，页面并没有元素&#x27; ); console.log(&#x27;binding&#x27;, binding); ele.innerText = &#x27;v-big指令显示&#x27; + binding.value; &#125;, inserted(ele, binding) &#123; console.log(&#x27;1或n次调用 - 指令所在的元素被插入页面时调用&#x27;); &#125;, update(ele, binding) &#123; console.log(&#x27;1或n次调用: 当指令所在模板被重新解析时&#x27;); &#125; &#125;); //添加全局混入 Vue.mixin(&#123; data() &#123; return &#123; pluginMixinValue: &#x27;plugins mixin data&#x27; &#125;; &#125; &#125;); &#125;&#125;; main.js12345678910import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import plugins from &#x27;./plugins&#x27;;Vue.config.productionTip = false;//使用插件Vue.use(plugins, &#123; value1: &#x27;value1&#x27;, value2: &#x27;value2&#x27; &#125;);new Vue(&#123; render: (h) =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;); student.vue12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;span&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;插件混入+插件过滤器:&#123;&#123;pluginMixinValue | odinFilter&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;插件v-big指令:&lt;/span&gt;&lt;span v-big=&quot;value&quot;&gt;&lt;/span&gt;&lt;br/&gt; &lt;button @click=&quot;invokeMyMethod&quot;&gt;调用插件中的myMethod方法&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; stuName: &#x27;odinsam&#x27;, value:&#x27;组件value&#x27; &#125; &#125;, methods: &#123; invokeMyMethod() &#123; this.pluginMethod(this.pluginPrototype); &#125; &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:500px; padding:50px; margin-left:50px;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"全局指令","slug":"全局指令","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4/"},{"name":"directive","slug":"directive","permalink":"https://www.odinsam.com/tags/directive/"},{"name":"filter","slug":"filter","permalink":"https://www.odinsam.com/tags/filter/"},{"name":"全局过滤器","slug":"全局过滤器","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"mixin","slug":"mixin","permalink":"https://www.odinsam.com/tags/mixin/"},{"name":"全局混入","slug":"全局混入","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5/"},{"name":"全局混合","slug":"全局混合","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%B7%B7%E5%90%88/"},{"name":"插件","slug":"插件","permalink":"https://www.odinsam.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"plugin","slug":"plugin","permalink":"https://www.odinsam.com/tags/plugin/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 03. mixins混入配置项","slug":"Vue2-0进阶-03-mixins混入","date":"2022-10-18T10:00:00.000Z","updated":"2022-10-18T12:47:38.594Z","comments":true,"path":"/articles/6426.html","link":"","permalink":"https://www.odinsam.com/articles/6426.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 01 章: props配置项","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 01 章: props配置项 完整代码可以在 GitHub 。 mixins混入配置项 可以吧多个组件公用的配置提取成一个混入对象 定义见 mixin.js 使用分为局部混合和全局混合。 局部混合：引入混合对象 import {mixin,mixinData} from ‘…/mixin’;在vueComponent配置项中 mixins:[mixin,mixinData] 全局混合：在main.js中 引入 import {mixin,mixinData} from ‘…/mixin’; 使用 Vue.mixin({ mixin, mixinData });混合 当混入配置与组件配置冲突时，如果是data、methods等，以组件自身数据、方法为主。但如果是有冲突的生命周期钩子，则都会运行。且现执行混合中的钩子函数后执行组件自身的钩子函数 示例代码 main.js12345678910import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import &#123; mixin, mixinData &#125; from &#x27;./mixin&#x27;;Vue.config.productionTip = false;//全局混入Vue.mixin(&#123; mixin, mixinData &#125;);new Vue(&#123; render: (h) =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;); mixin.js12345678910111213141516171819export const mixin = &#123; methods: &#123; showName() &#123; alert(this.name); &#125; &#125;, mounted() &#123; console.log(this.name + &#x27;组件挂载了&#x27;); &#125;&#125;;export const mixinData = &#123; data() &#123; return &#123; value: &#x27;mixin数据&#x27; &#125;; &#125;&#125;; school.vue12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;mixindata与组件data冲突时:&#123;&#123;value&#125;&#125;&lt;/h2&gt; &lt;span&gt;学校名：&#123;&#123;schoolName&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;button @click=&quot;showName&quot;&gt;showName&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mixin,mixinData&#125; from &#x27;../mixin&#x27;;export default &#123; data() &#123; return &#123; value:&#x27;组件data&#x27;, name:&#x27;School组件&#x27;, schoolName:&#x27;vue学院&#x27; &#125; &#125;, mixins:[mixin,mixinData]&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:500px; padding:50px; margin-left:50px;&#125;&lt;/style&gt; student.vue123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;span&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt;&lt;br/&gt; &lt;button @click=&quot;showName&quot;&gt;showName&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mixin&#125; from &#x27;../mixin.js&#x27;;export default &#123; data() &#123; return &#123; name:&#x27;Student组件&#x27;, stuName:&#x27;odinsam&#x27; &#125; &#125;, mixins: [mixin], mounted() &#123; console.log(&#x27;student自身的mounted&#x27;); &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:500px; padding:50px; margin-left:50px;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"mixin","slug":"mixin","permalink":"https://www.odinsam.com/tags/mixin/"},{"name":"混入","slug":"混入","permalink":"https://www.odinsam.com/tags/%E6%B7%B7%E5%85%A5/"},{"name":"混合","slug":"混合","permalink":"https://www.odinsam.com/tags/%E6%B7%B7%E5%90%88/"},{"name":"全局混入","slug":"全局混入","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5/"},{"name":"全局混合","slug":"全局混合","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%B7%B7%E5%90%88/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 02. props配置项","slug":"Vue2-0进阶-02-props配置项","date":"2022-10-18T09:28:00.000Z","updated":"2022-10-19T14:38:04.227Z","comments":true,"path":"/articles/40e6.html","link":"","permalink":"https://www.odinsam.com/articles/40e6.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 01 章: props配置项","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 01 章: props配置项 完整代码可以在 GitHub 。 props配置项 让组件接收外部传过来的数据 &lt;Student stuName=“odinsam” :age=“10”&gt;&lt;/Student&gt; 如果使用props传递数组、对象、方法等数据时，应该是 &lt;Student :getStudentName=“getStudentName”&gt;&lt;/Student&gt;通过props传递函数getStudentName 接收数据 简单接收1props: [&#x27;stuName&#x27;, &#x27;age&#x27;] 接收的同时限制数据类型1234props: &#123; stuName: String, age: Number,&#125; 接收的同时 限制数据类型、限制必要性、指定默认值1234567891011121314props: &#123; stuName: &#123; type: String, required:true, &#125;, age: &#123; type: Number, required:true, &#125;, className: &#123; type: String, default:&quot;1班&quot;, &#125;&#125; props是只读的，Vue底层会检测对props的修改。如果进行了修改，会发出警告。如果业务需要修改，name复制props内容到data中，修改data中的数据 示例代码 app.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;div class=&quot;dvapp&quot;&gt; &lt;!-- props配置项 1. 让组件接收外部传过来的数据 &lt;Student stuName=&quot;odinsam&quot; :age=&quot;10&quot;&gt;&lt;/Student&gt; 2. 接收数据 简单接收 props: [&#x27;stuName&#x27;, &#x27;age&#x27;] 接收的同时限制数据类型 props: &#123; stuName: String, age: Number, &#125; 接收的同时 限制数据类型、限制必要性、指定默认值 props: &#123; stuName: &#123; type: String, required:true, &#125;, age: &#123; type: Number, required:true, &#125;, className: &#123; type: String, default:&quot;1班&quot;, &#125; &#125; 3. props是制度的，Vue底层会检测对props的修改。如果进行了修改，会发出警告。如果业务需要修改，name复制props内容到data中，修改data中的数据 --&gt; &lt;h2&gt;app组件&lt;/h2&gt; &lt;Student stuName=&quot;odinsam&quot; :age=&quot;10&quot;&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, components: &#123; Student &#125;, methods: &#123; &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.dvapp&#123; background-color: aquamarine;&#125;&lt;/style&gt; student.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;span&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt;&lt;br /&gt; &lt;span&gt;年龄：&#123;&#123;myAge&#125;&#125;&lt;/span&gt;&lt;br /&gt; &lt;span&gt;班级：&#123;&#123;className&#125;&#125;&lt;/span&gt;&lt;br /&gt; &lt;button @click=&quot;changeAge&quot;&gt;修改姓名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; myAge:this.age &#125; &#125;, methods: &#123; changeAge() &#123; this.myAge++ &#125; &#125;, // 简单接收 // props: [&#x27;stuName&#x27;, &#x27;age&#x27;] // 接收的同时限制数据类型 /* props: &#123; stuName: String, age: Number, &#125; */ props: &#123; stuName: &#123; type: String, required:true, &#125;, age: &#123; type: Number, required:true, &#125;, className: &#123; type: String, default:&quot;1班&quot;, &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.studv&#123; background-color:bisque; width:200px; padding:50px; margin-left:50px;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"props","slug":"props","permalink":"https://www.odinsam.com/tags/props/"}],"author":"OdinSam"},{"title":"Vue2.0进阶学习","slug":"Vue2-0进阶学习","date":"2022-10-18T08:57:00.000Z","updated":"2022-10-19T14:43:40.002Z","comments":true,"path":"/articles/e255.html","link":"","permalink":"https://www.odinsam.com/articles/e255.html","excerpt":"Vue2.0进阶学习目录. vue2.0 基础学习目录","text":"Vue2.0进阶学习目录. vue2.0 基础学习目录 完整代码可以在 GitHub 。 目录 [01] ref属性 [02] props配置项 [03] mixin混入配置项 [04] plugins插件 [05] vue的style [06] webStorage浏览器的本地存储 [07] vue自定义事件 [08] 全局事件总线 [09] 消息订阅与发布 [10] nextTick与props传递函数","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"Vue2.0进阶 - 01. ref属性","slug":"Vue2-0进阶-ref属性","date":"2022-10-18T08:55:00.000Z","updated":"2022-10-18T12:46:37.434Z","comments":true,"path":"/articles/821d.html","link":"","permalink":"https://www.odinsam.com/articles/821d.html","excerpt":"【Vue2.0】进阶学习系列 Vue2.0进阶第 01 章: ref属性","text":"【Vue2.0】进阶学习系列 Vue2.0进阶第 01 章: ref属性 完整代码可以在 GitHub 。 ref属性 被用来给元素或者子组件注册引用信息(id的替代) 应用在html标签上获取到的是真实的dom元素，应用在组件标签上获取到的是组件对象实例vc 使用方法 &lt;h1 ref=“title”&gt;…&lt;/h1&gt; 或者 &lt;Student ref=“stu”&gt;&lt;/Student&gt; 获取 this.refs.title 真实dom对象 或者 this.refs.stu stu组件对象实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;!-- ref属性 1. 被用来给元素或者子组件注册引用信息(id的替代) 2. 应用在html标签上获取到的是真实的dom元素，应用在组件标签上获取到的是组件对象实例vc 3. 使用方法 &lt;h1 ref=&quot;title&quot;&gt;.....&lt;/h1&gt; 或者 &lt;Student ref=&quot;stu&quot;&gt;&lt;/Student&gt; 4. 获取 this.$refs.title 真实dom对象 或者 this.$refs.stu stu组件对象实例 --&gt; &lt;h2 ref=&quot;title&quot;&gt;app组件&lt;/h2&gt; &lt;Student ref=&quot;stu&quot;&gt;&lt;/Student&gt; &lt;button @click=&quot;getDomClick&quot;&gt;使用ref获取dom元素&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, components: &#123; Student &#125;, methods: &#123; getDomClick() &#123; console.log(&#x27;function getDomClick&#x27;); console.log(this.$refs.title); //获取到真实的dom元素 console.log(this.$refs.stu); // student组件对象 vc &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"ref","slug":"ref","permalink":"https://www.odinsam.com/tags/ref/"}],"author":"OdinSam"},{"title":"macos 小指令","slug":"macos-小指令","date":"2022-10-18T07:16:00.000Z","updated":"2022-10-18T07:17:25.546Z","comments":true,"path":"/articles/ade6.html","link":"","permalink":"https://www.odinsam.com/articles/ade6.html","excerpt":"macos 中的一些小指令","text":"macos 中的一些小指令 生成markdownde的目录树 find . -print | sed -e ‘s;[^/]*/;|;g;s;|; |;g’","categories":[{"name":"macos","slug":"macos","permalink":"https://www.odinsam.com/categories/macos/"},{"name":"杂项","slug":"macos/杂项","permalink":"https://www.odinsam.com/categories/macos/%E6%9D%82%E9%A1%B9/"}],"tags":[],"author":"OdinSam"},{"title":"Vue2.0 - 19. Vue脚手架","slug":"Vue2-0-19-Vue脚手架","date":"2022-10-18T07:03:00.000Z","updated":"2022-10-18T13:03:48.874Z","comments":true,"path":"/articles/d49a.html","link":"","permalink":"https://www.odinsam.com/articles/d49a.html","excerpt":"【Vue2.0】学习系列 第 19 章: Vue脚手架","text":"【Vue2.0】学习系列 第 19 章: Vue脚手架 完整代码可以在 GitHub 。 全局安装 npm install -g @vue/cli 切换到需要创建项目的目录，然后创建项目 vue create 项目名称 进入项目目录，启动项目 npm serve vue.js 与 vue.runtime.mini.js 的区别 vue.js 是完整版的 vue，包含核心功能+模板解析器 vue.runtime.mini.js 是运行时版本，只包含核心功能，没有模板解析器 vue.runtime.mini.js 因为没有模板解析器，所以不能使用 template 配置项，需要 render 函数接收到的 createElement 函数去指定具体内容 123new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 使用 vue inspect &gt; output.js 可以查看到vue脚手架的默认配置 使用 vue.config.js 可以对脚手架进行个性化定制。详情 https://cli.vuejs.org/zh","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"cli","slug":"cli","permalink":"https://www.odinsam.com/tags/cli/"}],"author":"OdinSam"},{"title":"Vue2.0 - 18.4 Vue组件-单文件组件","slug":"Vue2-0-18-4-Vue组件-单文件组件","date":"2022-10-18T06:46:00.000Z","updated":"2022-10-18T12:51:39.184Z","comments":true,"path":"/articles/9c18.html","link":"","permalink":"https://www.odinsam.com/articles/9c18.html","excerpt":"【Vue2.0】学习系列 第 18.4 章: vue组件-单文件组件","text":"【Vue2.0】学习系列 第 18.4 章: vue组件-单文件组件 完整代码可以在 GitHub 。 index.html12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;18.4.单文件组件&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.config.productionTip = false; &lt;/script&gt;&lt;/html&gt; main.js123456789import App from &#x27;App&#x27;;const vm = new Vue(&#123; el: &#x27;#root&#x27;, components: &#123; App &#125;, template: `&lt;App&gt;&lt;/App&gt;`&#125;); app.vue123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h2&gt;App组件&lt;/h2&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, components:&#123; Student &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.studv&#123; background-color:aquamarine; padding: 20px; &#125;&lt;/style&gt; student.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;studv&quot;&gt; &lt;h2&gt;Studen组件&lt;/h2&gt; &lt;span&gt;&#123;&#123;stuName&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Student&#x27;, data() &#123; return &#123; stuName:&#x27;odinsam&#x27; &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt;.studv&#123; margin-left:50px; background-color: bisque; padding: 20px; &#125;&lt;/style&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"component","slug":"component","permalink":"https://www.odinsam.com/tags/component/"}],"author":"OdinSam"},{"title":"Vue2.0 - 18.3 Vue组件-内置关系","slug":"Vue2-0-18-3-Vue组件-内置关系","date":"2022-10-18T06:43:00.000Z","updated":"2022-10-18T12:52:49.412Z","comments":true,"path":"/articles/e7e4.html","link":"","permalink":"https://www.odinsam.com/articles/e7e4.html","excerpt":"【Vue2.0】学习系列 第 18.3 章: vue组件-内置关系","text":"【Vue2.0】学习系列 第 18.3 章: vue组件-内置关系 完整代码可以在 GitHub 。 vue的内置关系 VueComponent.prototype.__proto__ === Vue.prototype 通过这关系，组件实例对象vc可以访问到Vue原型上的属性、方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;18.3.vue的内置关系&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. vue的内置关系 VueComponent.prototype.__proto__ === Vue.prototype 2. 通过这关系，组件实例对象vc可以访问到Vue原型上的属性、方法 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; function Demo() &#123; this.a = 1; this.b = 2; &#125; const d = new Demo(); //显示原型属性 console.log(&#x27;Demo.prototype&#x27;, Demo.prototype); //隐式原型属性 console.log(&#x27;d.__proto__&#x27;, d.__proto__); // 显示原型属性 和 隐式原型属性 都指向了原型对象 Demo.prototype.x = 100; //通过显示原型属性操作原型对象，添加x属性 100 console.log(&#x27;d.__proto__.x&#x27;, d.__proto__.x); // 可以输出 100 console.log( &#x27;Demo.prototype == d.__proto__&#x27;, Demo.prototype == d.__proto__ ); //返回true Vue.prototype.testProto = 100; const Student = &#123; name: &#x27;Student&#x27;, data() &#123; return &#123; name: &#x27;odinsam&#x27;, proto: 0 &#125;; &#125;, template: ` &lt;div&gt; &lt;h2&gt;student组件&lt;/h2&gt; &lt;div&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;Vue.prototype.testProto = 100; 获取结果为: &#123;&#123;proto&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;getVmTestProto&quot;&gt;获取vm上的testProto&lt;/button&gt; &lt;/div&gt;`, methods: &#123; getVmTestProto() &#123; console.log(this.testProto); this.proto = this.testProto; &#125; &#125; &#125;; const vm = new Vue(&#123; el: &#x27;#root&#x27;, data() &#123; return &#123; test: &#x27;test proto&#x27; &#125;; &#125;, components: &#123; Student &#125; &#125;); console.log( &#x27;Vue.prototype === vm.__proto__&#x27;, Vue.prototype === vm.__proto__ ); // VueComponent.prototype.__proto__ === Vue.prototype // 组件实例对象vc可以访问到Vue原型上的属性、方法 console.log( &#x27;Student.prototype === vm.___proto__&#x27;, Student.prototype === vm.___proto__ ); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"prototype","slug":"prototype","permalink":"https://www.odinsam.com/tags/prototype/"},{"name":"__proto__","slug":"proto","permalink":"https://www.odinsam.com/tags/proto/"}],"author":"OdinSam"},{"title":"Vue2.0 - 18.2 Vue组件-组件嵌套","slug":"Vue2-0-18-2-Vue组件-组件嵌套","date":"2022-10-18T06:41:00.000Z","updated":"2022-10-18T12:53:17.025Z","comments":true,"path":"/articles/ff66.html","link":"","permalink":"https://www.odinsam.com/articles/ff66.html","excerpt":"【Vue2.0】学习系列 第 18.2 章: vue组件-组件嵌套","text":"【Vue2.0】学习系列 第 18.2 章: vue组件-组件嵌套 完整代码可以在 GitHub 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;18.2.组件嵌套&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- --&gt; &lt;div id=&quot;root&quot;&gt; &lt;App&gt;&lt;/App&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const Student = Vue.extend(&#123; name: &#x27;Student&#x27;, data() &#123; return &#123; stuName: &#x27;odinsam&#x27;, stuAge: 20 &#125;; &#125;, template: ` &lt;div style=&#x27;margin-left:50px;&#x27;&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;span&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt; &lt;span&gt;年龄：&#123;&#123;stuAge&#125;&#125;&lt;/span&gt; &lt;/div&gt; ` &#125;); const School = &#123; name: &#x27;school&#x27;, components: &#123; Student &#125;, data() &#123; return &#123; schName: &#x27;vue学校&#x27;, schAddress: &#x27;南京&#x27; &#125;; &#125;, template: ` &lt;div&gt; &lt;h2&gt;School组件&lt;/h2&gt; &lt;span&gt;课程：&#123;&#123;schName&#125;&#125;&lt;/span&gt; &lt;span&gt;地址：&#123;&#123;schAddress&#125;&#125;&lt;/span&gt; &lt;div&gt;在校学生&lt;/div&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt; ` &#125;; const Hello = &#123; name: &#x27;Hello&#x27;, template: `&lt;h2&gt;hello组件&lt;/h2&gt;` &#125;; const App = &#123; name: &#x27;App&#x27;, components: &#123; Hello, school: School &#125;, template: ` &lt;div&gt; &lt;h2&gt;App组件&lt;/h2&gt; &lt;Hello style=&#x27;margin-left:50px;&#x27;&gt;&lt;/Hello&gt; &lt;school style=&#x27;margin-left:50px;&#x27;&gt;&lt;/school&gt; &lt;/div&gt; ` &#125;; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 components: &#123; App &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"component","slug":"component","permalink":"https://www.odinsam.com/tags/component/"},{"name":"嵌套","slug":"嵌套","permalink":"https://www.odinsam.com/tags/%E5%B5%8C%E5%A5%97/"}],"author":"OdinSam"},{"title":"Vue2.0 - 18.1 vue组件-非单文件组件","slug":"Vue2-0-18.1-vue组件-非单文件组件","date":"2022-10-18T04:54:00.000Z","updated":"2022-10-18T13:04:20.602Z","comments":true,"path":"/articles/fd0a.html","link":"","permalink":"https://www.odinsam.com/articles/fd0a.html","excerpt":"【Vue2.0】学习系列 第 18.1 章: vue组件-非单文件组件","text":"【Vue2.0】学习系列 第 18.1 章: vue组件-非单文件组件 完整代码可以在 GitHub 。 1. 使用vue组件的步骤: 创建组件 单文件组件、非单位件组件 注册组件 使用组件（组件标签） 定义组件: 使用Vue.extend({options}) 或者 const cpt = {options} 创建,其中options和new Vue({options})传入的options略有区别 组件的 options 不需要el， 最终的el由new Vue({options})决定 data必须写成函数，避免组件被服用时，数据存在引用关系。示例代码如下: 1234567891011let data=&#123;a:1,b:2&#125;const x1 = dataconst x2 = data// 以上代码会导致数据存在引用关系，当x1修改 a或b 的值，x2也会改变function data()&#123; return &#123;a:1,b:2&#125;&#125;const x1 = data()const x2 = data()//通过函数形式可以巧妙的避开上边代码的问题 x1修改 x2不会改变 使用 template: 来配置组件结构 关于组件名 一个单词组成: 首字母小写 student 或者 首字母大写 School 多个单词组成: kebab-case命名 my-school 或者 CamelCase大驼峰 MyStudent(需要vue脚手架支持) 不可以使用 html已有元素名称 h1 div span 等 尽量使用 name 配置项指定组件在开发者工具中呈现的名字 2. 注册组件 局部注册 new Vue({ components:{ 组件名:组件 } }) 全局注册 Vue.component(‘组件名’，组件) 3. 使用组件 &lt;组件 /&gt; 或者 &lt;组件&gt;&lt;/组件&gt; &lt;组件 /&gt; 不使用脚手架，会导致后续组件无法渲染 4. 说明: 组件本质是VueComponent的构造函数，并且是由Vue.extend生成的 当使用组件时，vue会帮助我们创建组件的对象实例（自动调用方法new VueComponent(options)创建组件实例） 每次调用Vue.extend返回的都是一个全新的VueComponent this指向： 1.组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数都指向VueComponent对象实例 2.new Vue配置中：data函数、methods中的函数、watch中的函数、computed中的函数都指向Vue对象实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;18.1.非单文件组件&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 使用vue组件的步骤: 1. 创建组件 单文件组件、非单位件组件 2. 注册组件 3. 使用组件（组件标签） 定义组件: 1. 使用Vue.extend(&#123;options&#125;) 或者 const cpt = &#123;options&#125; 创建,其中options和new Vue(&#123;options&#125;)传入的options略有区别 组件的 options 不需要el， 最终的el由new Vue(&#123;options&#125;)决定 data必须写成函数，避免组件被服用时，数据存在引用关系。示例代码如下: let data=&#123;a:1,b:2&#125; const x1 = data const x2 = data // 以上代码会导致数据存在引用关系，当x1修改 a或b 的值，x2也会改变 function data()&#123; return &#123;a:1,b:2&#125; &#125; const x1 = data() const x2 = data() //通过函数形式可以巧妙的避开上边代码的问题 x1修改 x2不会改变 2. 使用 template:`` 来配置组件结构 3. 关于组件名 一个单词组成: 首字母小写 student 或者 首字母大写 School 多个单词组成: kebab-case命名 my-school 或者 CamelCase大驼峰 MyStudent(需要vue脚手架支持) 不可以使用 html已有元素名称 h1 div span 等 尽量使用 name 配置项指定组件在开发者工具中呈现的名字 注册组件 1. 局部注册 new Vue(&#123; components:&#123; 组件名:组件 &#125; &#125;) 2. 全局注册 Vue.component(&#x27;组件名&#x27;，组件) 使用组件 1. &lt;组件 /&gt; 或者 &lt;组件&gt;&lt;/组件&gt; 2. &lt;组件 /&gt; 不使用脚手架，会导致后续组件无法渲染 说明: 1. 组件本质是VueComponent的构造函数，并且是由Vue.extend生成的 2. 当使用组件时，vue会帮助我们创建组件的对象实例（自动调用方法new VueComponent(options)创建组件实例） 3. 每次调用Vue.extend返回的都是一个全新的VueComponent 4. this指向： 1.组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数都指向VueComponent对象实例 2.new Vue配置中：data函数、methods中的函数、watch中的函数、computed中的函数都指向Vue对象实例 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;school&gt;&lt;/school&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const Student = Vue.extend(&#123; name: &#x27;Student&#x27;, data() &#123; return &#123; stuName: &#x27;odinsam&#x27;, stuAge: 20 &#125;; &#125;, template: ` &lt;div&gt; &lt;h2&gt;Student组件&lt;/h2&gt; &lt;span&gt;姓名：&#123;&#123;stuName&#125;&#125;&lt;/span&gt; &lt;span&gt;年龄：&#123;&#123;stuAge&#125;&#125;&lt;/span&gt; &lt;/div&gt; ` &#125;); const School = &#123; name: &#x27;school&#x27;, data() &#123; return &#123; schName: &#x27;vue学校&#x27;, schAddress: &#x27;南京&#x27; &#125;; &#125;, template: ` &lt;div&gt; &lt;h2&gt;School组件&lt;/h2&gt; &lt;span&gt;课程：&#123;&#123;schName&#125;&#125;&lt;/span&gt; &lt;span&gt;地址：&#123;&#123;schAddress&#125;&#125;&lt;/span&gt; &lt;/div&gt; ` &#125;; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 components: &#123; Student, school: School &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"component","slug":"component","permalink":"https://www.odinsam.com/tags/component/"}],"author":"OdinSam"},{"title":"Vue2.0 - 17. 生命周期","slug":"Vue2-0-17-生命周期","date":"2022-10-17T17:04:00.000Z","updated":"2022-10-18T13:03:14.000Z","comments":true,"path":"/articles/5bf8.html","link":"","permalink":"https://www.odinsam.com/articles/5bf8.html","excerpt":"【Vue2.0】学习系列 第 17 章: 生命周期","text":"【Vue2.0】学习系列 第 17 章: 生命周期 完整代码可以在 GitHub 。","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"生命周期","slug":"生命周期","permalink":"https://www.odinsam.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"挂载","slug":"挂载","permalink":"https://www.odinsam.com/tags/%E6%8C%82%E8%BD%BD/"},{"name":"销毁","slug":"销毁","permalink":"https://www.odinsam.com/tags/%E9%94%80%E6%AF%81/"},{"name":"更新","slug":"更新","permalink":"https://www.odinsam.com/tags/%E6%9B%B4%E6%96%B0/"},{"name":"beforeCreate","slug":"beforeCreate","permalink":"https://www.odinsam.com/tags/beforeCreate/"},{"name":"created","slug":"created","permalink":"https://www.odinsam.com/tags/created/"},{"name":"beforeMount","slug":"beforeMount","permalink":"https://www.odinsam.com/tags/beforeMount/"},{"name":"mounted","slug":"mounted","permalink":"https://www.odinsam.com/tags/mounted/"},{"name":"beforeUpdate","slug":"beforeUpdate","permalink":"https://www.odinsam.com/tags/beforeUpdate/"},{"name":"update","slug":"update","permalink":"https://www.odinsam.com/tags/update/"},{"name":"beforeDestroy","slug":"beforeDestroy","permalink":"https://www.odinsam.com/tags/beforeDestroy/"},{"name":"destroyed","slug":"destroyed","permalink":"https://www.odinsam.com/tags/destroyed/"}],"author":"OdinSam"},{"title":"Vue2.0 - 16. Filter过滤器","slug":"Vue2-0-16-过滤器","date":"2022-10-17T15:58:00.000Z","updated":"2022-10-18T12:55:38.974Z","comments":true,"path":"/articles/4c6a.html","link":"","permalink":"https://www.odinsam.com/articles/4c6a.html","excerpt":"【Vue2.0】学习系列 第 16 章: Filter过滤器","text":"【Vue2.0】学习系列 第 16 章: Filter过滤器 完整代码可以在 GitHub 。 Filter过滤器: 对现实的数据进行特性格式化后再显示(适用于一些简单的逻辑处理) 注册过滤器 Vue.filter(‘name’,function(){}); 或 new Vue(filters:{ filtername([params]){} }) 使用过滤器 {{name | filtername1[ | filtername2]}} 或者 v-bind:属性=“name | filtername1[ | filtername2]” 过滤器可以接受额外参数，多个过滤器可以串联 并没有改变元数据，只是产生新的对应数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;16.过滤器&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 过滤器: 1. 对现实的数据进行特性格式化后再显示(适用于一些简单的逻辑处理) 2. 注册过滤器 Vue.filter(&#x27;name&#x27;,function()&#123;&#125;); 或 new Vue(filters:&#123; filtername([params])&#123;&#125; &#125;) 3. 使用过滤器 &#123;&#123;name | filtername1[ | filtername2]&#125;&#125; 或者 v-bind:属性=&quot;name | filtername1[ | filtername2]&quot; 4. 过滤器可以接受额外参数，多个过滤器可以串联 5. 并没有改变元数据，只是产生新的对应数据 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;无参过滤器:&#123;&#123; username | usernameFormater&#125;&#125;&lt;/h2&gt; &lt;h2&gt; 带参过滤器:&#123;&#123; username | usernameFormaterWithParams(&#x27;参数&#x27;)&#125;&#125; &lt;/h2&gt; &lt;h2&gt; 串联过滤器:&#123;&#123; username | usernameFormater | usernameFormaterWithParams(&#x27;参数&#x27;)&#125;&#125; &lt;/h2&gt; &lt;h2&gt;无参全局过滤器:&#123;&#123; username | globalFilter&#125;&#125;&lt;/h2&gt; &lt;h2&gt; 带参全局过滤器:&#123;&#123; username | globalFilterWithParams(&#x27;global&#x27;)&#125;&#125; &lt;/h2&gt; &lt;h2&gt; 全局过滤器+局部过滤器:&#123;&#123; username | usernameFormaterWithParams(&#x27;参数&#x27;) | globalFilterWithParams(&#x27;global&#x27;)&#125;&#125; &lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; Vue.filter(&#x27;globalFilter&#x27;, function (value) &#123; return value + &#x27;-无参全局过滤器&#x27;; &#125;); Vue.filter(&#x27;globalFilterWithParams&#x27;, function (value, param) &#123; return value + &#x27;-带参全局过滤器-&#x27; + param; &#125;); const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; username: &#x27;odinsam&#x27; &#125;; &#125;, methods: &#123;&#125;, filters: &#123; usernameFormater(value) &#123; return value + &#x27;-无参数&#x27;; &#125;, usernameFormaterWithParams(value, param) &#123; return value + &#x27;-带参数&#x27;; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"filter","slug":"filter","permalink":"https://www.odinsam.com/tags/filter/"},{"name":"filters","slug":"filters","permalink":"https://www.odinsam.com/tags/filters/"},{"name":"过滤器","slug":"过滤器","permalink":"https://www.odinsam.com/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"全局过滤器","slug":"全局过滤器","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8/"}],"author":"OdinSam"},{"title":"Vue2.0 - 15. 表单数据的收集","slug":"Vue2-0-15-表单数据的收集","date":"2022-10-17T14:56:00.000Z","updated":"2022-10-18T12:51:03.443Z","comments":true,"path":"/articles/d63a.html","link":"","permalink":"https://www.odinsam.com/articles/d63a.html","excerpt":"【Vue2.0】学习系列 第15章: 表单数据的收集","text":"【Vue2.0】学习系列 第15章: 表单数据的收集 完整代码可以在 GitHub 。 表单数据收集: &lt;input type=“text” v-model=“userName”/&gt; v-model收集的是value值,即用户输入的值 &lt;input type=“radio” name=“sex” value=‘male’ v-model=“sex” /&gt; v-model收集的是value值, 需要给标签配置value &lt;input type=“checkbox” value=‘game’ v-model=“hobby” /&gt; 如果没有配置value 则收集的是checked true or false 如果配置了value v-model的初始值是非数组，则收集的是checked true or false 如果配置了value v-model的初始值是数组，则收集的是value组成的数组 v-model 有三个修饰符,可连续使用 v-model.trim.lazy=‘password’ lazy 延迟收集，失去焦点再收集数据 trim 过滤收尾空格 number 将输入的字符串转换为数值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;15.表单数据的收集&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 表单数据收集: 1. &lt;input type=&quot;text&quot; v-model=&quot;userName&quot;/&gt; v-model收集的是value值,即用户输入的值 2. &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&#x27;male&#x27; v-model=&quot;sex&quot; /&gt; v-model收集的是value值, 需要给标签配置value 3. &lt;input type=&quot;checkbox&quot; value=&#x27;game&#x27; v-model=&quot;hobby&quot; /&gt; 如果没有配置value 则收集的是checked true or false 如果配置了value v-model的初始值是非数组，则收集的是checked true or false 如果配置了value v-model的初始值是数组，则收集的是value组成的数组 4. v-model 有三个修饰符 lazy 延迟收集，失去焦点再收集数据 trim 过滤收尾空格 number 将输入的字符串转换为数值 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;表单数据的收集&lt;/h3&gt; &lt;div&gt; &lt;form @submit.prevent=&quot;submitForm&quot;&gt; &lt;div&gt; &lt;span&gt;账号&lt;/span &gt;&lt;input type=&quot;text&quot; v-model.lazy.trim=&quot;userInfo.account&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码&lt;/span &gt;&lt;input type=&quot;password&quot; v-model=&quot;userInfo.pwd&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;年龄&lt;/span &gt;&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;性别&lt;/span&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot; /&gt; &lt;span&gt;男&lt;/span&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot; /&gt;&lt;span&gt;女&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;爱好&lt;/span&gt; &lt;input type=&quot;checkbox&quot; value=&quot;study&quot; v-model=&quot;userInfo.hobby&quot; /&gt;学习 &lt;input type=&quot;checkbox&quot; value=&quot;game&quot; v-model=&quot;userInfo.hobby&quot; /&gt;游戏 &lt;input type=&quot;checkbox&quot; value=&quot;eat&quot; v-model=&quot;userInfo.hobby&quot; /&gt;吃饭 &lt;/div&gt; &lt;div&gt; &lt;span&gt;地址&lt;/span&gt; &lt;select name=&quot;address&quot; id=&quot;address&quot; v-model=&quot;userInfo.address&quot; &gt; &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;nanjing&quot;&gt;南京&lt;/option&gt; &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;其他信息&lt;/span&gt; &lt;textarea name=&quot;other&quot; id=&quot;other&quot; cols=&quot;30&quot; rows=&quot;10&quot; v-model=&quot;userInfo.other&quot; &gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot; /&gt; &lt;span&gt; 阅读并接受&lt;a href=&quot;https://odinsam.com&quot; &gt;《用户协议》&lt;/a &gt; &lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; userInfo: &#123; account: &#x27;&#x27;, pwd: &#x27;&#x27;, age: 0, sex: &#x27;&#x27;, hobby: [], address: &#x27;nanjing&#x27;, other: &#x27;&#x27;, agree: false &#125; &#125;; &#125;, methods: &#123; submitForm() &#123; console.log(&#x27;function submitForm&#x27;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"v-model","slug":"v-model","permalink":"https://www.odinsam.com/tags/v-model/"},{"name":"value","slug":"value","permalink":"https://www.odinsam.com/tags/value/"}],"author":"OdinSam"},{"title":"Vue2.0 - 14. vue.set方法","slug":"Vue2-0-14-vue-set方法","date":"2022-10-17T14:05:00.000Z","updated":"2022-10-18T12:55:50.903Z","comments":true,"path":"/articles/c533.html","link":"","permalink":"https://www.odinsam.com/articles/c533.html","excerpt":"【Vue2.0】学习系列 第14章: vue.set方法","text":"【Vue2.0】学习系列 第14章: vue.set方法 完整代码可以在 GitHub 。 vue监视数据的原理 vue会监视data中所有层次的数据 通过setter实现数据监视，并且要在new vue时就传入需要监视的数据 对象中后续追加的属性，vue默认不做响应式处理 如果需要给添加的属性做响应式处理 需要使用 set api Vue.set(data.target,‘prototypeName’/index,‘prototypeValue’) this.$set(data.target,‘prototypeName’/index,‘prototypeValue’) 对于数组的更新 需要使用api push、pop、shift、unshift、splice、sort、reverse 或者 Vue.set() | this.$set() Vue.set() | vm.$set() 不能给vm的根数即data直接添加属性 核心是使用 Object.defineProperty 实现了数据劫持 方法 使用 描述 push const length = arrayObj. push([item1 [item2 [. . . [itemN ]]]]) 将一个或多个新元素添加到数组结尾，并返回数组新长度 pop const obj = arrayObj.pop() 移除最后一个元素并返回该元素值 shift const obj = arrayObj.shift() 移除最前一个元素并返回该元素值，数组中元素自动前移 unshift const length = arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]) 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度 splice const deleteArr = arrayObj.splice(deletePos,deleteCount,[newItem1,newItem2]) 删除从指定位置deletePos开始的指定数量deleteCount的元素[并添加一个或多个新的元素]，数组形式返回所移除的元素 sort const sortArr = arrayObj.sort() 反转元素（最前的排到最后、最后的排到最前），返回数组地址 reverse const reverseArr = arrayObj.reverse() 反转元素（最前的排到最后、最后的排到最前），返回数组地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;14.vue_set方法&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; #root &#123; display: flex; justify-content: space-evenly; &#125; .conditiondv &#123; width: 200px; height: 200px; background-color: bisque; &#125; [v-cloak] &#123; display: none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- vue监视数据的原理 1. vue会监视data中所有层次的数据 2. 通过setter实现数据监视，并且要在new vue时就传入需要监视的数据 3. 对象中后续追加的属性，vue默认不做响应式处理 4. 如果需要给添加的属性做响应式处理 需要使用 set api Vue.set(data.target,&#x27;prototypeName&#x27;/index,&#x27;prototypeValue&#x27;) this.$set(data.target,&#x27;prototypeName&#x27;/index,&#x27;prototypeValue&#x27;) 5. 对于数组的更新 需要使用api push、pop、shift、unshift、splice、sort、reverse 或者 Vue.set() | this.$set() 6, Vue.set() | vm.$set() 不能给vm的根数即data直接添加属性 --&gt; &lt;div&gt; &lt;span&gt;对象动态添加属性&lt;/span&gt; &lt;br /&gt; &lt;span &gt;this.$set(data.object,&#x27;prototypeName&#x27;,&#x27;prototypeValue&#x27;)&lt;/span &gt; &lt;span &gt;Vue.set(data.object,&#x27;prototypeName&#x27;,&#x27;prototypeValue&#x27;)&lt;/span &gt; &lt;ul&gt; &lt;li v-for=&quot;(v,k) in student&quot;&gt; &lt;span&gt;key:&#123;&#123;k&#125;&#125;&lt;/span&gt;----&lt;span&gt;value:&#123;&#123;v&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;addPrototypeClick&quot;&gt;add prototype&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;对象动态修改数组属性&lt;/span&gt;&lt;br /&gt; &lt;span &gt;this.$set(data.object,&#x27;prototypeName&#x27;,&#x27;prototypeValue&#x27;)&lt;/span &gt; &lt;ul&gt; &lt;li v-for=&quot;(v,k) in student&quot;&gt; &lt;span&gt;key:&#123;&#123;k&#125;&#125;&lt;/span&gt;----&lt;span&gt;value:&#123;&#123;v&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;addHobbyClick&quot;&gt;add prototype&lt;/button&gt; &lt;br /&gt; &lt;button @click=&quot;changeHobbyClick&quot;&gt;使用数组的变更方法&lt;/button&gt; &lt;table border=&quot;1&quot;&gt; &lt;thead&gt; &lt;td&gt;方法&lt;/td&gt; &lt;td&gt;使用&lt;/td&gt; &lt;td&gt;描述&lt;/td&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;push&lt;/td&gt; &lt;td&gt; const length = arrayObj. push([item1 [item2 [. . . [itemN ]]]]) &lt;/td&gt; &lt;td&gt; 将一个或多个新元素添加到数组结尾，并返回数组新长度 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;pop&lt;/td&gt; &lt;td&gt;const obj = arrayObj.pop()&lt;/td&gt; &lt;td&gt;移除最后一个元素并返回该元素值&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;shift&lt;/td&gt; &lt;td&gt;const obj = arrayObj.shift()&lt;/td&gt; &lt;td&gt; 移除最前一个元素并返回该元素值，数组中元素自动前移 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;unshift&lt;/td&gt; &lt;td&gt; const length = arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]) &lt;/td&gt; &lt;td&gt; 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;splice&lt;/td&gt; &lt;td&gt; const deleteArr = arrayObj.splice(deletePos,deleteCount,[newItem1,newItem2]) &lt;/td&gt; &lt;td&gt; 删除从指定位置deletePos开始的指定数量deleteCount的元素[并添加一个或多个新的元素]，数组形式返回所移除的元素 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sort&lt;/td&gt; &lt;td&gt;const sortArr = arrayObj.sort()&lt;/td&gt; &lt;td&gt; 反转元素（最前的排到最后、最后的排到最前），返回数组地址 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;reverse&lt;/td&gt; &lt;td&gt;const reverseArr = arrayObj.reverse()&lt;/td&gt; &lt;td&gt; 反转元素（最前的排到最后、最后的排到最前），返回数组地址 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; student: &#123; name: &#x27;odinsam&#x27;, age: 20, hobby: [&#x27;抽烟&#x27;, &#x27;喝酒&#x27;, &#x27;烫头&#x27;] &#125; &#125;; &#125;, methods: &#123; addPrototypeClick() &#123; console.log(&#x27;function addPClick&#x27;); this.$set(this.student, &#x27;sex&#x27;, &#x27;男&#x27;); &#125;, addHobbyClick() &#123; console.log(&#x27;function addHobbyClick&#x27;); this.$set( this.student.hobby, this.student.hobby.length, &#x27;学习-&#x27; + this.student.hobby.length ); &#125;, changeHobbyClick() &#123; console.log(&#x27;function changeHobbyClick&#x27;); this.student.hobby.push( &#x27;push new hobby-&#x27; + this.student.hobby.length ); &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"vue.set","slug":"vue-set","permalink":"https://www.odinsam.com/tags/vue-set/"}],"author":"OdinSam"},{"title":"Vue2.0 - 13.  vue指令","slug":"Vue2-0-13-vue指令","date":"2022-10-17T13:50:00.000Z","updated":"2022-10-18T12:54:32.060Z","comments":true,"path":"/articles/9cac.html","link":"","permalink":"https://www.odinsam.com/articles/9cac.html","excerpt":"【Vue2.0】学习系列 第13章: vue指令","text":"【Vue2.0】学习系列 第13章: vue指令 数据绑定 完整代码可以在 GitHub 。 v-text 向所在的节点渲染文本内容，html 会原样输出不解析。 并且节点的原始内容会被替换相对于插值语法在此显得更加灵活 v-html 在指定节点中渲染包含 html 结构的内容 容易导致xss攻击 v-cloak 当 vue 实例创建完毕并接管容器后会移除 v-cloak 属性。可搭配样式 [v-cloak]{ display:none; } 解决网速过慢页面展示{{xxx}}的问题 v-once 所在节点在初始动态渲染后，就视为静止内容，以后数据的改动不会引起 v-once 所在的结构的更新，可用于优化性能。 v-pre 跳过所在节点的编译过程，vue不在编译节点内容提升性能 v-show 条件渲染 v-show=“bool值或者返回bool类型的表达式” 。 适用于切换较高的场景。DOM 未被移除，只是通过样式 display:none 隐藏 v-if 条件渲染 v-if=“bool值或者返回bool类型的表达式” 。 适用于切换较低的场景。DOM 被移除，可能无法获取dom元素 v-if 可搭配 v-else-if v-else 但是整体结构不能打断 整体渲染可以使用 但是只能使用 v-if 不能使用v-show v-for 列表渲染 遍历数组 v-for=“item in array” :key=“item.id” v-for 列表渲染 遍历对象 v-for=&quot;(v,k) in object&quot; :key=“k” v-for 列表渲染 遍历字符串 v-for=&quot;(char,index) in string&quot; :key=“index” v-for 列表渲染 遍历数值(次数) v-for=&quot;(num,index) in number&quot; :key=“index” key是虚拟dom的标识，当数据发生变化时，会依据key做dom的diff比较运行。如果key使用index在数组进行了逆序的添加、删除等操作破坏了原有顺序会发生bug key一般最好使用id、手机号、身份证号等唯一标识 如果没有逆序操作，使用index作为key的值夜没有问题 自定义指令 示例： 指令名定义时不加 v- ，使用时加 v- 指令名如果是多个单词，需要使用 kebab-case 命名方式，不要用驼峰命名 第一种写法 new vue中配置1234567directives: &#123; big(ele, binding) &#123; // 第一次调用: 当指令与元素成功绑定 第n次调用: 当指令所在模板被重新解析时 ele.innerText = binding.value * 10; &#125; //对象是&#125; 第二种写法123456789101112131415big: &#123; bind() &#123; console.log( &#x27;1次调用 - 当指令与元素绑定成功时调用，在内存，页面并没有元素&#x27; ); &#125;, inserted() &#123; console.log( &#x27;1或n次调用 - 指令所在的元素被插入页面时调用&#x27; ); &#125;, update() &#123; console.log(&#x27;1或n次调用: 当指令所在模板被重新解析时&#x27;); &#125;&#125; 全局写法 vm.directive('指令名',配置对象) 或 vm.directive(‘指令名’,回调函数) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;13.内置指令&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; #root &#123; display: flex; justify-content: space-evenly; &#125; .conditiondv &#123; width: 200px; height: 200px; background-color: bisque; &#125; [v-cloak] &#123; display: none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- ### 数据绑定 1. v-text 向所在的节点渲染文本内容，html 会原样输出不解析。 并且节点的原始内容会被替换（ &#123;&#123;&#125;&#125; 插值语法在此显得更加灵活 ） 2. v-html 在指定节点中渲染包含 html 结构的内容 容易导致xss攻击 3. v-cloak 当 vue 实例创建完毕并接管容器后会移除 v-cloak 属性。可搭配样式 [v-cloak]&#123; display:none; &#125; 解决网速过慢页面展示&#123;&#123;xxx&#125;&#125;的问题 4. v-once 所在节点在初始动态渲染后，就视为静止内容，以后数据的改动不会引起 v-once 所在的结构的更新，可用于优化性能。 5. v-pre 跳过所在节点的编译过程，vue不在编译节点内容提升性能 --&gt; &lt;div&gt; &lt;span&gt;v-text&lt;/span&gt; &lt;span v-text=&quot;vtext&quot;&gt;span原有内容&lt;/span&gt; &lt;br /&gt; &lt;span&gt;v-html&lt;/span&gt; &lt;span v-html=&quot;vhtml&quot;&gt;&lt;/span&gt; &lt;br /&gt; &lt;span&gt;v-cloak&lt;/span&gt; &lt;span v-cloak &gt;当 vue 实例创建完毕并接管容器后会移除 v-cloak 属性&lt;/span &gt; &lt;br /&gt; &lt;span&gt;v-once&lt;/span&gt; &lt;span v-once&gt;初始onceNum为 &#123;&#123;onceNum&#125;&#125;&lt;/span&gt; &lt;span&gt;onceNum当前值为 &#123;&#123;onceNum&#125;&#125;&lt;/span&gt; &lt;button @click=&quot;btnAddNum&quot;&gt;btnAddNum&lt;/button&gt; &lt;br /&gt; &lt;span v-pre &gt;跳过所在节点的编译过程，vue不在编译节点内容提升性能&lt;/span &gt; &lt;/div&gt; &lt;!-- ### 条件渲染 6. v-show 条件渲染 v-show=&quot;bool值或者返回bool类型的表达式&quot; 。 适用于切换较高的场景。DOM 未被移除，只是通过样式 display:none 隐藏 7. v-if 条件渲染 v-if=&quot;bool值或者返回bool类型的表达式&quot; 。 适用于切换较低的场景。DOM 被移除，可能无法获取dom元素 8. v-if 可搭配 v-else-if v-else 但是整体结构不能打断 9. 整体渲染可以使用 &lt;template&gt;&lt;/template&gt; 但是只能使用 v-if 不能使用v-show --&gt; &lt;div&gt; &lt;span&gt;条件渲染&lt;/span&gt; &lt;div v-show=&quot;vshow&quot; class=&quot;conditiondv&quot;&gt;v-show=&quot;vshow&quot;&lt;/div&gt; &lt;button @click=&quot;vshowBtnClick&quot;&gt;v-show&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;div v-if=&quot;vif&quot; class=&quot;conditiondv&quot;&gt;v-if=&quot;vif&quot;&lt;/div&gt; &lt;button @click=&quot;vifBtnClick&quot;&gt;v-show&lt;/button&gt; &lt;div v-if=&quot;num===1&quot; class=&quot;conditiondv&quot;&gt;v-if=&quot;num===1&quot;&lt;/div&gt; &lt;!--&lt;div&gt;整体结构不能打断&lt;/div&gt;--&gt; &lt;div v-else-if=&quot;num===2&quot; class=&quot;conditiondv&quot;&gt; v-else-if=&quot;num===2&quot; &lt;/div&gt; &lt;div v-else class=&quot;conditiondv&quot;&gt;v-else&lt;/div&gt; &lt;button @click=&quot;conditionClick&quot;&gt;conditionClick&lt;/button&gt; &lt;/div&gt; &lt;!-- ### 列表渲染 10. v-for 列表渲染 遍历数组 v-for=&quot;item in array&quot; :key=&quot;item.id&quot; 11. v-for 列表渲染 遍历对象 v-for=&quot;(v,k) in object&quot; :key=&quot;k&quot; 12. v-for 列表渲染 遍历字符串 v-for=&quot;(char,index) in string&quot; :key=&quot;index&quot; 13. v-for 列表渲染 遍历数值(次数) v-for=&quot;(num,index) in number&quot; :key=&quot;index&quot; 14. key是虚拟dom的标识，当数据发生变化时，会依据key做dom的diff比较运行。如果key使用index在数组进行了逆序的添加、删除等操作破坏了原有顺序会发生bug 15. key一般最好使用id、手机号、身份证号等唯一标识 16. 如果没有逆序操作，使用index作为key的值夜没有问题 --&gt; &lt;div&gt; &lt;span&gt;遍历数组 v-for=&quot;item in array&quot; :key=&quot;item.id&quot; &lt;/span&gt; &lt;ul&gt; &lt;li v-for=&quot;(user,index) in users&quot; :key=&quot;user.id&quot;&gt; index:&#123;&#123;index&#125;&#125; id:&#123;&#123;user.id&#125;&#125; 姓名:&#123;&#123;user.name&#125;&#125; 年龄:&#123;&#123;user.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;span&gt;遍历对象 v-for=&quot;(v,k) in object&quot; :key=&quot;k&quot;&lt;/span&gt; &lt;ul&gt; &lt;li v-for=&quot;(v,k) in users[0]&quot; :key=&quot;k&quot;&gt; key:&#123;&#123;k&#125;&#125; value:&#123;&#123;v&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;span &gt;遍历字符串 v-for=&quot;(char,index) in string&quot; :key=&quot;index&quot;&lt;/span &gt; &lt;ul&gt; &lt;li v-for=&quot;(char,index) in users[0].name&quot; :key=&quot;index&quot;&gt; char:&#123;&#123;char&#125;&#125; index:&#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;span &gt;遍历数值(次数) v-for=&quot;(num,index) in number&quot; :key=&quot;index&quot;&lt;/span &gt; &lt;ul&gt; &lt;li v-for=&quot;(number,index) in 5&quot; :key=&quot;index&quot;&gt; number:&#123;&#123;number&#125;&#125; index:&#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- 17. 自定义指令 示例： &lt;span v-big=&quot;customNum&quot;&gt;&lt;/span&gt; 指令名定义时不加 v- ，使用时加 v- 指令名如果是多个单词，需要使用 kebab-case 命名方式，不要用驼峰命名 第一种写法 new vue中配置 directives: &#123; big(ele, binding) &#123; // 第一次调用: 当指令与元素成功绑定 第n次调用: 当指令所在模板被重新解析时 ele.innerText = binding.value * 10; &#125; //对象是 &#125; 第二种写法 big: &#123; bind(ele, binding) &#123; console.log( &#x27;1次调用 - 当指令与元素绑定成功时调用，在内存，页面并没有元素&#x27; ); &#125;, inserted(ele, binding) &#123; console.log( &#x27;1或n次调用 - 指令所在的元素被插入页面时调用&#x27; ); &#125;, update(ele, binding) &#123; console.log(&#x27;1或n次调用: 当指令所在模板被重新解析时&#x27;); &#125; &#125; 全局写法 vm.$directive(&#x27;指令名&#x27;,配置对象) 或 vm.$directive(&#x27;指令名&#x27;,回调函数) --&gt; &lt;span&gt;自定义指令&lt;/span&gt; &lt;span&gt;customNum:&#123;&#123;customNum&#125;&#125;&lt;/span&gt; &lt;br /&gt; &lt;span&gt;放大10倍后的值:&lt;/span&gt;&lt;span v-big=&quot;customNum&quot;&gt;&lt;/span&gt; &lt;br /&gt; &lt;button @click=&quot;btnCustomNumAdd&quot;&gt;btnCustomNumAdd&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; customNum: 5, onceNum: 1, num: 1, vtext: &#x27;&lt;span&gt;vtext指令&lt;/span&gt;&#x27;, vhtml: &#x27;&lt;a href=&quot;http://odinsam.com&quot;&gt;v-html容易导致xss攻击&lt;/a&gt;&#x27;, vshow: true, vif: true, users: [ &#123; id: &#x27;no1&#x27;, name: &#x27;odinsam1&#x27;, age: 29 &#125;, &#123; id: &#x27;no2&#x27;, name: &#x27;odinsam2&#x27;, age: 14 &#125;, &#123; id: &#x27;no3&#x27;, name: &#x27;odinsam3&#x27;, age: 26 &#125; ] &#125;; &#125;, methods: &#123; vshowBtnClick() &#123; console.log(&#x27;function vshowBtnClick&#x27;); this.vshow = !this.vshow; &#125;, vifBtnClick() &#123; console.log(&#x27;function vifBtnClick&#x27;); this.vif = !this.vif; &#125;, conditionClick() &#123; this.num++; if (this.num &gt; 3) this.num = 1; &#125;, btnAddNum() &#123; this.onceNum++; &#125;, btnCustomNumAdd() &#123; this.customNum++; &#125; &#125;, directives: &#123; // big(ele, binding) &#123; // ele.innerText = binding.value * 10; // &#125; big: &#123; bind(ele, binding) &#123; console.log( &#x27;1次调用 - 当指令与元素绑定成功时调用，在内存，页面并没有元素&#x27; ); &#125;, inserted(ele, binding) &#123; console.log( &#x27;1或n次调用 - 指令所在的元素被插入页面时调用&#x27; ); &#125;, update(ele, binding) &#123; console.log(&#x27;1或n次调用: 当指令所在模板被重新解析时&#x27;); &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"全局指令","slug":"全局指令","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4/"},{"name":"指令","slug":"指令","permalink":"https://www.odinsam.com/tags/%E6%8C%87%E4%BB%A4/"},{"name":"directives","slug":"directives","permalink":"https://www.odinsam.com/tags/directives/"},{"name":"directive","slug":"directive","permalink":"https://www.odinsam.com/tags/directive/"},{"name":"v-text","slug":"v-text","permalink":"https://www.odinsam.com/tags/v-text/"},{"name":"v-html","slug":"v-html","permalink":"https://www.odinsam.com/tags/v-html/"},{"name":"v-cloak","slug":"v-cloak","permalink":"https://www.odinsam.com/tags/v-cloak/"},{"name":"v-once","slug":"v-once","permalink":"https://www.odinsam.com/tags/v-once/"},{"name":"v-pre","slug":"v-pre","permalink":"https://www.odinsam.com/tags/v-pre/"},{"name":"v-show","slug":"v-show","permalink":"https://www.odinsam.com/tags/v-show/"},{"name":"v-if","slug":"v-if","permalink":"https://www.odinsam.com/tags/v-if/"},{"name":"v-else-if","slug":"v-else-if","permalink":"https://www.odinsam.com/tags/v-else-if/"},{"name":"v-else","slug":"v-else","permalink":"https://www.odinsam.com/tags/v-else/"},{"name":"v-for","slug":"v-for","permalink":"https://www.odinsam.com/tags/v-for/"},{"name":"key","slug":"key","permalink":"https://www.odinsam.com/tags/key/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://www.odinsam.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"}],"author":"OdinSam"},{"title":"Vue2.0 - 12. 样式的绑定","slug":"Vue2-0-12-样式的绑定","date":"2022-10-15T15:39:00.000Z","updated":"2022-10-18T12:51:19.663Z","comments":true,"path":"/articles/5a60.html","link":"","permalink":"https://www.odinsam.com/articles/5a60.html","excerpt":"【Vue2.0】学习系列 第12章: 样式的绑定","text":"【Vue2.0】学习系列 第12章: 样式的绑定 完整代码可以在 GitHub 。 :class=’’ 可以绑定对应的class样式 可以是 字符串、数组、对象 :style=’’ 可以绑定对应的style样式 可以是 直接绑定或者是数组、对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;12.样式绑定&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .dvbasic &#123; width: 400px; height: 200px; border: 1px solid black; &#125; .dv1 &#123; background-color: cadetblue; &#125; .dv2 &#123; background-color: coral; &#125; .dv3 &#123; background-color: rgb(222, 216, 50); &#125; .ddvv1 &#123; background-color: rgb(30, 33, 32); &#125; .ddvv2 &#123; color: rgb(241, 227, 227); &#125; .ddvv3 &#123; font-size: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. :class=&#x27;&#x27; 可以绑定对应的class样式 可以是 字符串、数组、对象 2. :style=&#x27;&#x27; 可以绑定对应的style样式 可以是 直接绑定或者是数组、对象 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;div class=&quot;dvbasic&quot; :class=&quot;dvClass&quot; @click=&quot;dv1Click&quot;&gt; div1 - click :class 绑定class样式 &lt;/div&gt; &lt;br /&gt; &lt;div class=&quot;dvbasic&quot; :class=&quot;dv2Class&quot; @click=&quot;dv2Click&quot;&gt; div2 - click :class 绑定class样式 数组形式绑定 &lt;/div&gt; &lt;br /&gt; &lt;div class=&quot;dvbasic&quot; :class=&quot;dv3Class&quot; @click=&quot;dv3Click&quot;&gt; div3 - click :class 绑定class样式 对象形式绑定 &lt;/div&gt; &lt;br /&gt; &lt;div class=&quot;dvbasic&quot; :style=&quot;&#123;fontSize: fsize+&#x27;px&#x27;&#125;&quot;&gt; div4 - :style=&quot;&#123;fontSize: fsize+&#x27;px&#x27;&#125;&quot; 绑定style样式 &lt;/div&gt; &lt;br /&gt; &lt;div class=&quot;dvbasic&quot; :style=&quot;styleObject&quot;&gt; div4 - :style=&quot;styleObject&quot; 绑定style样式 &lt;/div&gt; &lt;br /&gt; &lt;div class=&quot;dvbasic&quot; :style=&quot;styleArr&quot;&gt; div5 - :style=&quot;styleArr&quot; 绑定style样式 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; styleArr: [ &#123; fontSize: &#x27;30px&#x27; &#125;, &#123; backgroundColor: &#x27;green&#x27; &#125; ], styleObject: &#123; fontSize: &#x27;20px&#x27;, backgroundColor: &#x27;red&#x27; &#125;, fsize: 40, dvClass: &#x27;&#x27;, dv2Class: [], dv3Class: &#123; ddvv1: false, ddvv2: false, ddvv3: false &#125;, dv1ArrClass: [&#x27;dv1&#x27;, &#x27;dv2&#x27;, &#x27;dv3&#x27;] &#125;; &#125;, methods: &#123; dv1Click() &#123; const index = Math.floor(Math.random() * 3); console.log(index); this.dvClass = this.dv1ArrClass[index]; &#125;, dv2Click() &#123; if (this.dv2Class.length === 0) &#123; this.dv2Class.push(&#x27;ddvv1&#x27;); this.dv2Class.push(&#x27;ddvv2&#x27;); this.dv2Class.push(&#x27;ddvv3&#x27;); &#125; else &#123; this.dv2Class.shift(); this.dv2Class.shift(); this.dv2Class.shift(); &#125; &#125;, dv3Click() &#123; this.dv3Class.ddvv1 = !this.dv3Class.ddvv1; this.dv3Class.ddvv2 = !this.dv3Class.ddvv2; this.dv3Class.ddvv3 = !this.dv3Class.ddvv3; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"class","slug":"class","permalink":"https://www.odinsam.com/tags/class/"},{"name":"style","slug":"style","permalink":"https://www.odinsam.com/tags/style/"}],"author":"OdinSam"},{"title":"Vue2.0 - 11. Watch监视属性","slug":"Vue2-0-11-监视属性","date":"2022-10-15T14:11:00.000Z","updated":"2022-10-18T12:56:12.317Z","comments":true,"path":"/articles/88f9.html","link":"","permalink":"https://www.odinsam.com/articles/88f9.html","excerpt":"【Vue2.0】学习系列 第11章: 监视属性","text":"【Vue2.0】学习系列 第11章: 监视属性 完整代码可以在 GitHub 。 Watch监视属性 当监视的属性发生变化时，回调函数 handler 会自动调用进行相关操作 监视的属性必须存在，才可以监视 监视属性两种写法 在new vue时配置watch 在new vue创建完成后，通过 vm.$watch(‘监视的属性’,{ //监视的配置内容 }) 监视多级结构中某个属性的变化 对象.属性 监视 watch 默认不检测对象内部值的改变,可以通过 deep:true 进行深度监视 监视属性不光可以监视data中的属性、对象也可以监视计算属性 监视属性可以简写，但代价是不能再配置 immediate、deep 监视属性简写12345678watch:&#123; personState(newValue,oldValue)&#123; //回调处理函数 &#125;&#125;vm.$watch(&#x27;personState&#x27;,function(newValue,oldValue)&#123; //回调处理函数&#125;) computed 计算属性能完成的watch都可以完成。watch可以完成的computed不一定能完成。例如：watch可以进行异步操作 所有被vue管理的函数最好写成普通函数，这样this指向才vm或者组件对象实例 所有不被vue管理的函数（定时器，ajax回调等）最好写成箭头函数，这样this指向才vm或者组件对象实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;11.监视属性&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;vue 监视属性&lt;/h2&gt; &lt;span&gt;人生真的是&#123;&#123;personState&#125;&#125;&lt;/span&gt; &lt;br /&gt;&lt;br /&gt; &lt;button @click=&quot;btnClick&quot;&gt;修改人生的状态&lt;/button&gt; &lt;hr /&gt; &lt;h3&gt;对象内容x &#123;&#123;obj.x&#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;button @click=&quot;btnXClick&quot;&gt;btn add&lt;/button&gt; &lt;hr /&gt; &lt;h3&gt;对象内容y &#123;&#123;obj.y&#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;button @click=&quot;btnYClick&quot;&gt;btn add&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; state: true, obj: &#123; x: 10, y: 20 &#125; &#125;; &#125;, methods: &#123; btnClick() &#123; this.state = !this.state; &#125;, btnXClick()&#123; this.obj.x ++; &#125;, btnYClick()&#123; this.obj.y++; &#125;, &#125;, computed: &#123; personState() &#123; return this.state ? &#x27;大起&#x27; : &#x27;大落&#x27;; &#125; &#125;, /* 1. 当监视的属性发生变化时，回调函数 handler 会自动调用进行相关操作 2. 监视的属性必须存在，才可以监视 3. 监视属性两种写法 1. 在new vue时配置watch 2. 在new vue创建完成后，通过 vm.$watch(&#x27;监视的属性&#x27;,&#123; //监视的配置内容 &#125;) 4. 监视多级结构中某个属性的变化 对象.属性 监视 5. watch 默认不检测对象内部值的改变,可以通过 deep:true 进行深度监视 6. 监视属性不光可以监视data中的属性、对象也可以监视计算属性 7. 监视属性可以简写，但代价是不能再配置 immediate、deep watch:&#123; personState(newValue,oldValue)&#123; //回调处理函数 &#125; &#125; vm.$watch(&#x27;personState&#x27;,function(newValue,oldValue)&#123; //回调处理函数 &#125;) 8. computed 计算属性能完成的watch都可以完成。watch可以完成的computed不一定能完成。例如：watch可以进行异步操作 备注： 所有被vue管理的函数最好写成普通函数，这样this指向才vm或者组件对象实例 所有不被vue管理的函数（定时器，ajax回调等）最好写成箭头函数，这样this指向才vm或者组件对象实例 */ watch: &#123; personState:&#123; handler(newValue, oldValue)&#123; console.log( `watch: 计算属性 personState 被修改了，原始值是:$&#123;oldValue&#125; 新值为:$&#123;newValue&#125;` ); &#125; &#125;, state: &#123; immediate: true, //初始化时让 handler 调用一次 handler(newValue, oldValue) &#123; console.log( `watch: state 被修改了，原始值是:$&#123;oldValue&#125; 新值为:$&#123;newValue&#125;` ); &#125; &#125;, // 监视多级结构中某个属性的变化 &#x27;obj.x&#x27;:&#123; immediate: true, //初始化时让 handler 调用一次 handler(newValue, oldValue) &#123; console.log( `watch: obj.x 被修改了，原始值是:$&#123;oldValue&#125; 新值为:$&#123;newValue&#125;` ); &#125; &#125;, // watch 默认不检测对象内部值的改变,可以通过 deep:true 进行深度监视 &#x27;obj&#x27;:&#123; deep:true, //进行深度监视 // immediate: true, //初始化时让 handler 调用一次 handler(newValue, oldValue) &#123; console.log(`watch: obj 被修改了 obj.x:$&#123;newValue.x&#125; obj.x:$&#123;newValue.y&#125;`); &#125; &#125;, //监视属性的简写 personState(newValue, oldValue)&#123; console.log( `watch: 计算属性 personState 被修改了，原始值是:$&#123;oldValue&#125; 新值为:$&#123;newValue&#125;` ); &#125; &#125; &#125;); //监视属性的第二种写法 首先保证vm创建完毕 // vm.$watch(&#x27;state&#x27;, &#123; // immediate: true, //初始化时让 handler 调用一次 // handler(newValue, oldValue) &#123; // console.log( // `state 被修改了，原始值是:$&#123;oldValue&#125; 新值为:$&#123;newValue&#125;` // ); // &#125; // &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"watch","slug":"watch","permalink":"https://www.odinsam.com/tags/watch/"}],"author":"OdinSam"},{"title":"Vue2.0 - 10. Computed计算属性","slug":"Vue2-0-10-计算属性","date":"2022-10-15T13:52:00.000Z","updated":"2022-10-18T13:01:04.268Z","comments":true,"path":"/articles/3442.html","link":"","permalink":"https://www.odinsam.com/articles/3442.html","excerpt":"【Vue2.0】学习系列 第10章: computed计算属性","text":"【Vue2.0】学习系列 第10章: computed计算属性 完整代码可以在 GitHub 。 Computed计算属性 get 当模板读取fullname时，get会被调用，且返回值作为fullname的值 get 的调用时机： 1. 初次读取fullname时 2.所有依赖的数据发生变化时 firstName lastName 相对于method实现，如果模板多个位置需要显示fullname时 method的方法会调用多次 而计算属性的get只调用一次 计算属性最终会出现在vm上可以直接使用，例如使用button直接修改fullname 如果修改计算属性，必须有set方法 如果计算属性只有get没有set则可以简写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;10.计算属性&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;vue 计算属性&lt;/h2&gt; &lt;span&gt;firstname&lt;/span &gt;&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt;&lt;br /&gt;&lt;br /&gt; &lt;span&gt;lastname&lt;/span &gt;&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt;&lt;br /&gt;&lt;br /&gt; &lt;span&gt;全名:&#123;&#123;fullname&#125;&#125;&lt;/span&gt; &lt;button @click=&quot;btnClick&quot;&gt;直接修改计算属性fullname&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; firstName: &#x27;odin&#x27;, lastName: &#x27;sam&#x27; &#125;; &#125;, methods: &#123; btnClick() &#123; this.fullname = &#x27;suiji-shu&#x27;; &#125; &#125;, computed: &#123; /* 1. get 当模板读取fullname时，get会被调用，且返回值作为fullname的值 2. get 的调用时机： 1. 初次读取fullname时 2.所有依赖的数据发生变化时 firstName lastName 3. 相对于method实现，如果模板多个位置需要显示fullname时 method的方法会调用多次 而计算属性的get只调用一次 4. 计算属性最终会出现在vm上可以直接使用，例如使用button直接修改fullname 5. 如果修改计算属性，必须有set方法 */ fullname: &#123; get() &#123; return this.firstName + &#x27;-&#x27; + this.lastName; &#125;, set(value) &#123; const arr = value.split(&#x27;-&#x27;); this.firstName = arr[0]; this.lastName = arr[1]; &#125; &#125; // 6. 如果计算属性只有get没有set则可以简写 // fullname()&#123; // return this.firstName + &#x27;-&#x27; + this.lastName; // &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"Vue2.0 - 09. 键盘事件","slug":"Vue2-0-09-键盘事件","date":"2022-10-15T13:22:00.000Z","updated":"2022-10-18T12:57:02.168Z","comments":true,"path":"/articles/42b7.html","link":"","permalink":"https://www.odinsam.com/articles/42b7.html","excerpt":"【Vue2.0】学习系列 第9章: 键盘事件","text":"【Vue2.0】学习系列 第9章: 键盘事件 完整代码可以在 GitHub 。 vue 中常用的按键别名 回车 enter 删除 delete 退格 backSpace 退出 esc 空格 space 换行 tab 上 up 下 down 左 left 右 right vue未提供别名的按键可以使用按键的原始的key去绑定，但要注意转换为 kebab-case 例如 CapsLock caps-lock 可以使用 @keyup.按键别名 绑定对应的按键事件 tab无法使用keyup绑定 需要使用keydown绑定 系统修饰按键 ctrl alt shift meta 如果配合keyup使用：按下系统修饰键，再按下其他键，随后释放其他键，事件才会触发 如果配合keydown使用 正常触发 也可以使用keyCode去绑定，但不推荐 @keyup.keyCode 有可能不同系统不同键盘的keycode不一样导致一些问题 Vue.config.keyCodes 可以自定义键名 Vue.config.keyCodes.自定义名 = 键码 Vue.config.keyCodes.huiche = 13 指定huiche 为按键13 即enter 按键别名可以组合使用 例如 @keyup.ctrl.y 即ctrl+y 触发事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;09.键盘事件&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. vue 中常用的按键别名 回车 enter 删除 delete 退格 backSpace 退出 esc 空格 space 换行 tab 上 up 下 down 左 left 右 right 2. vue未提供别名的按键可以使用按键的原始的key去绑定，但要注意转换为 kebab-case 例如 CapsLock caps-lock 3. 可以使用 @keyup.按键别名 绑定对应的按键事件 4. tab无法使用keyup绑定 需要使用keydown绑定 5. 系统修饰按键 ctrl alt shift meta 1. 如果配合keyup使用：按下系统修饰键，再按下其他键，随后释放其他键，事件才会触发 2. 如果配合keydown使用 正常触发 6. 也可以使用keyCode去绑定，但不推荐 @keyup.keyCode 有可能不同系统不同键盘的keycode不一样导致一些问题 7. Vue.config.keyCodes 可以自定义键名 Vue.config.keyCodes.自定义名 = 键码 Vue.config.keyCodes.huiche = 13 指定huiche 为按键13 即enter --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;vue 键盘事件&lt;/h2&gt; &lt;label for=&quot;lbl&quot;&gt;按键按下的是 &#123;&#123;inputKey&#125;&#125;&lt;/label&gt; &lt;input type=&quot;text&quot; @keyup=&quot;showinfo&quot; /&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; userName: &#x27;odinsam&#x27;, inputKey: &#x27;&#x27; &#125;; &#125;, methods: &#123; showinfo(e) &#123; this.inputKey = `e.key:$&#123;e.key&#125; e.keyCode=$&#123;e.keyCode&#125;`; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"keydown","slug":"keydown","permalink":"https://www.odinsam.com/tags/keydown/"},{"name":"keyup","slug":"keyup","permalink":"https://www.odinsam.com/tags/keyup/"}],"author":"OdinSam"},{"title":"Vue2.0 - 08. 事件修饰符","slug":"Vue2-0-07-事件修饰符","date":"2022-10-15T06:46:00.000Z","updated":"2022-10-18T12:57:40.143Z","comments":true,"path":"/articles/48de.html","link":"","permalink":"https://www.odinsam.com/articles/48de.html","excerpt":"【Vue2.0】学习系列 第8章: 事件修饰符","text":"【Vue2.0】学习系列 第8章: 事件修饰符 完整代码可以在 GitHub 。 prevent 阻止默认事件 stop 阻止事件冒泡 once 事件只触发一次 capture 事件捕获模式 和 冒泡模式刚好相反 self 是有event.target 是当前操作的元素时才触发 passive 事件的默认行为立即执行，无需等待回调完毕 移动端常用 修饰符可以连续写，例如 @click.stop.prevent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;08. 事件修饰符&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .parentdv &#123; width: 400px; height: 400px; background-color: bisque; text-align: center; &#125; .childdv &#123; width: 300px; height: 200px; margin: 50px; background-color: cadetblue; text-align: center; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. prevent 阻止默认事件 2. stop 阻止事件冒泡 3. once 事件只触发一次 4. capture 事件捕获模式 和 冒泡模式刚好相反 5. self 是有event.target 是当前操作的元素时才触发 6. passive 事件的默认行为立即执行，无需等待回调完毕 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;vue 事件修饰符&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;userName&quot; /&gt; &lt;!--阻止默认事件 @click.prevent--&gt; &lt;a href=&quot;https://odinsam.com&quot; @click.prevent=&quot;clickShow&quot;&gt; 点击弹窗，阻止默认事件 - @click.prevent &lt;/a &gt;&lt;br /&gt;&lt;br /&gt; &lt;!--阻止事件冒泡 @click.stop--&gt; &lt;div class=&quot;parentdv&quot; @click.capture=&quot;parentClick&quot;&gt; &lt;span&gt;事件捕获模式 - @click.capture&lt;/span&gt; &lt;div class=&quot;childdv&quot; @click.stop=&quot;childClick&quot;&gt; 阻止事件冒泡 - @click.stop &lt;/div&gt; &lt;/div&gt; &lt;br /&gt; &lt;!--事件只触发一次 @click.once--&gt; &lt;button @click.once=&quot;btnOnceClick&quot;&gt; 事件只触发一次 - @click.once&lt;/button &gt;&lt;br /&gt;&lt;br /&gt; &lt;!--当event.target==self才触发事件 @click.self--&gt; &lt;div class=&quot;parentdv&quot; @click.self=&quot;dvselfClick&quot;&gt; @click.self=&quot;dvselfClick&quot; &lt;button @click.stop=&quot;childBtnClick&quot;&gt; 按钮点击会冒泡，但div的click有self修饰符，所以不触发div的click事件 &lt;/button&gt; &lt;/div&gt; &lt;br /&gt;&lt;br /&gt; &lt;!--事件的默认行为立即执行，无需等待回调完毕 @click.passive--&gt; &lt;span&gt;显示姓名&#123;&#123;showName&#125;&#125;&lt;/span&gt; &lt;button @click.passive=&quot;btnClickPassive&quot;&gt;@click.passive&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; userName: &#x27;odinsam&#x27;, showName: &#x27;&#x27; &#125;; &#125;, methods: &#123; clickShow() &#123; alert(&#x27;function clickShow&#x27;); &#125;, parentClick() &#123; alert(&#x27;parent click&#x27;); &#125;, childClick() &#123; alert(&#x27;child click&#x27;); &#125;, btnOnceClick() &#123; alert(&#x27;click once&#x27;); &#125;, dvselfClick() &#123; alert(&#x27;div self click&#x27;); &#125;, childBtnClick() &#123; alert(&#x27;child Btn Click&#x27;); &#125;, btnClickPassive() &#123; for (let i = 0; i &lt; 100000; i++) &#123; console.log(&#x27;#&#x27;); &#125; this.showName = this.userName; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"prevent","slug":"prevent","permalink":"https://www.odinsam.com/tags/prevent/"},{"name":"stop","slug":"stop","permalink":"https://www.odinsam.com/tags/stop/"},{"name":"once","slug":"once","permalink":"https://www.odinsam.com/tags/once/"},{"name":"capture","slug":"capture","permalink":"https://www.odinsam.com/tags/capture/"},{"name":"self","slug":"self","permalink":"https://www.odinsam.com/tags/self/"},{"name":"passive","slug":"passive","permalink":"https://www.odinsam.com/tags/passive/"}],"author":"OdinSam"},{"title":"Vue2.0 - 07. 事件处理","slug":"Vue2-0-07-事件处理","date":"2022-10-15T06:43:00.000Z","updated":"2022-10-18T12:58:09.093Z","comments":true,"path":"/articles/ec6.html","link":"","permalink":"https://www.odinsam.com/articles/ec6.html","excerpt":"【Vue2.0】学习系列 第7章: 事件处理","text":"【Vue2.0】学习系列 第7章: 事件处理 完整代码可以在 GitHub 。 事件绑定 使用 v-on: 绑定事件 click事件可以简写为 @click 无参数的事件处理方法 会有一个默认参数 event 代表 eventObject 带参数的时间处理方法 也可以带 eventObject 使用 $event传递 事件处理函数需要配置在methods中，最终会体现在vm上 事件处理函数都是被vue管理的函数，this指向vm或者组件对象实例。不可以使用箭头函数，否则this指向window 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;07.事件处理&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 1. 事件绑定 使用 v-on: 绑定事件 2. click事件可以简写为 @click 3. 无参数的事件处理方法 会有一个默认参数 event 代表 eventObject 4. 带参数的时间处理方法 也可以带 eventObject 使用 $event传递 5. 事件处理函数需要配置在methods中，最终会体现在vm上 6. 事件处理函数都是被vue管理的函数，this指向vm或者组件对象实例。不可以使用箭头函数，否则this指向window 7. --&gt; &lt;h2&gt;vue 事件处理&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;userName&quot; /&gt; &lt;button v-on:click=&quot;showInfo&quot;&gt;提示信息&lt;/button&gt; &lt;button @click=&quot;showInfoWithParams(userName,$event)&quot;&gt; 提示信息2 &lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, // 直接指定vue对应的容器 data() &#123; return &#123; userName: &#x27;odinsam&#x27; &#125;; &#125;, methods: &#123; showInfo(event) &#123; console.log(&#x27;无参处理函数 showInfo&#x27;); console.log(event); &#125;, showInfoWithParams(un, event) &#123; console.log(&#x27;带参处理函数 showInfoWithParams&#x27;); console.log(`input userName: $&#123;un&#125;, event对象:$&#123;event&#125;`); &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"v-on","slug":"v-on","permalink":"https://www.odinsam.com/tags/v-on/"},{"name":"@click","slug":"click","permalink":"https://www.odinsam.com/tags/click/"}],"author":"OdinSam"},{"title":"Vue2.0 - 06. 数据代理-Object.defineProperty","slug":"Vue2-0-06-数据代理-Object-defineProperty","date":"2022-10-14T18:12:00.000Z","updated":"2022-10-17T14:03:38.394Z","comments":true,"path":"/articles/7c3d.html","link":"","permalink":"https://www.odinsam.com/articles/7c3d.html","excerpt":"【Vue2.0】学习系列 第6章: 数据代理-Object.defineProperty","text":"【Vue2.0】学习系列 第6章: 数据代理-Object.defineProperty 完整代码可以在 GitHub 。 1234567891011121314151617let user=&#123;name:&#x27;odinsam&#x27;,sex:&#x27;男&#x27;&#125;Object.defineProperty(user,&#x27;age&#x27;,&#123;value:20,enumerable:true,writable:true,configurable:true&#125;)&#123;name: &#x27;odinsam&#x27;, sex: &#x27;男&#x27;, age: 20&#125;for(let key in user)&#123; console.log(`user的key-value key:$&#123;key&#125; value:$&#123;user[key]&#125;`) &#125;// user的key-value key:name value:odinsam// user的key-value key:sex value:男//user的key-value key:age value:20user.age=3030user.age30delete user.agetruefor(let key in user)&#123; console.log(`user的key-value key:$&#123;key&#125; value:$&#123;user[key]&#125;`) &#125;user的key-value key:name value:odinsamuser的key-value key:sex value:男 Object.defineProperty的 get set 用法 123456789101112131415161718let number = 20let user=&#123;name:&#x27;odinsam&#x27;,sex:&#x27;男&#x27;&#125;Object.defineProperty(user,&#x27;age&#x27;,&#123; get()&#123; return number &#125; set(value)&#123; number=value &#125; &#125;)&#123;name: &#x27;odinsam&#x27;, sex: &#x27;男&#x27;, age: 20&#125;for(let key in user)&#123; console.log(`user的key-value key:$&#123;key&#125; value:$&#123;user[key]&#125;`) &#125;// user的key-value key:name value:odinsam// user的key-value key:sex value:男//user的key-value key:age value:20user.age=3030user.age30delete user.agetruefor(let key in user)&#123; console.log(`user的key-value key:$&#123;key&#125; value:$&#123;user[key]&#125;`) &#125;user的key-value key:name value:odinsamuser的key-value key:sex value:男 原始的数据代理 obj2通过数据代理获取obj1的x属性 1234567891011//原始的数据代理let obj1 = &#123; x: 10 &#125;;let obj2 = &#123; y: 10 &#125;;Object.defineProperty(obj2, &#x27;x&#x27;, &#123; get() &#123; return obj1.x; &#125;, set(value) &#123; obj1.x = value; &#125;&#125;); vue中的数据代理 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;06.数据代理-Object.defineProperty&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;script&gt; /* vue中的数据代理 1. 通过vm对象来代理data对象中属性的操作 getter setter 2. 更加方便的操作data中的数据 3. 通过Object.defineProperty()把data对象中所有的属性添加到vm上 4. 为每一个添加到wm上的属性都指定 getter、setter方法 5. 在getter、setter内部操作data中对应的属性 6. vm._data中的属性不是数据代理而是数据劫持，通过数据劫持监听数据改变从而render页面 */ &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"原型链","slug":"原型链","permalink":"https://www.odinsam.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}],"author":"OdinSam"},{"title":"Vue2.0 - 05. mvvm模型","slug":"Vue2-0-05-mvvm模型","date":"2022-10-14T17:52:00.000Z","updated":"2022-10-18T13:00:45.956Z","comments":true,"path":"/articles/a38e.html","link":"","permalink":"https://www.odinsam.com/articles/a38e.html","excerpt":"【Vue2.0】学习系列 第5章: mvvm模型","text":"【Vue2.0】学习系列 第5章: mvvm模型 MVVM 解释123M - 模型 即 data 中的数据V - 视图 即 模板 VM - viewModel 即 vue的实例对象 data bindings 数据以对象的形式存储在data中，通过databindings将数据绑定在 view 页面中 view页面改变，通过 dom listeners 修改 data中的数据 data中所有的属性，最后都出现在vm立 vm所有的属性即vue原型的属性，在vue模板中都可以直接使用","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"mvvm","slug":"mvvm","permalink":"https://www.odinsam.com/tags/mvvm/"},{"name":"ViewModel","slug":"ViewModel","permalink":"https://www.odinsam.com/tags/ViewModel/"},{"name":"view","slug":"view","permalink":"https://www.odinsam.com/tags/view/"}],"author":"OdinSam"},{"title":"Vue2.0 - 04. el与data的两种写法","slug":"Vue2-0-04-el与data","date":"2022-10-14T17:26:00.000Z","updated":"2022-10-18T12:58:22.923Z","comments":true,"path":"/articles/3899.html","link":"","permalink":"https://www.odinsam.com/articles/3899.html","excerpt":"【Vue2.0】学习系列 第4章: el 与 data的两种写法","text":"【Vue2.0】学习系列 第4章: el 与 data的两种写法 完整代码可以在 GitHub 。 el 与 data 有两种写法 el 的两种写法: 1. 在new vue(&#123; el:'#root' &#125;) 时同时指定el的容器 2. 在创建vue后 通过实例对象指定el的值 vm.$mount('#root') data 的两种写法 1. 通过对象的形式 data:&#123; title:'hello vue' &#125; 2. 使用函数的形式 data() &#123; return &#123; title:'hello vue' &#125; &#125; 后期使用函数式组件时，data必须使用函数形式 重点注意: 由vue管理的函数(例如 data 的函数式写法)，一定不能写箭头函数，否则this指向的实例就会是window对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;04.el与data的两种写法&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;通过vue的实例对象挂载数据:&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; /* el 与 data 有两种写法 el 的两种写法: 1. 在new vue(&#123; el:&#x27;#root&#x27; &#125;) 时同时指定el的容器 2. 在创建vue后 通过实例对象指定el的值 vm.$mount(&#x27;#root&#x27;) data 的两种写法 1. 通过对象的形式 data:&#123; title:&#x27;hello vue&#x27; &#125; 2. 使用函数的形式 data() &#123; return &#123; title:&#x27;hello vue&#x27; &#125; &#125; 后期使用函数式组件时，data必须使用函数形式 重点注意: 由vue管理的函数(例如 data 的函数式写法)，一定不能写箭头函数，否则this指向的实例就会是window对象 */ Vue.config.productionTip = false; // 写法1 const vm = new Vue(&#123; // el: &#x27;#root&#x27;, // 直接指定vue对应的容器 // 使用data对象形式 // data: &#123; // title: &#x27;hello vue&#x27;, // url: &#x27;http://www.odinsam.com&#x27; // &#125; // 使用函数式 data() &#123; return &#123; title: &#x27;hello vue !!&#x27; &#125;; &#125; &#125;); // 写法2 vm.$mount(&#x27;#root&#x27;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"el","slug":"el","permalink":"https://www.odinsam.com/tags/el/"},{"name":"data","slug":"data","permalink":"https://www.odinsam.com/tags/data/"}],"author":"OdinSam"},{"title":"Vue2.0 - 03. 数据绑定","slug":"Vue2-0-03-数据绑定语法","date":"2022-10-14T16:43:00.000Z","updated":"2022-10-18T12:58:36.783Z","comments":true,"path":"/articles/f50b.html","link":"","permalink":"https://www.odinsam.com/articles/f50b.html","excerpt":"【Vue2.0】学习系列 第3章: vue 的数据绑定","text":"【Vue2.0】学习系列 第3章: vue 的数据绑定 完整代码可以在 GitHub 。 vue有单向数据绑定和双向数据绑定两种 单向绑定 v-bind 数据只能从data流向页面 双向绑定 v-model 数据不仅可以从data流向页面，当页面发生改变同样可以修改data的内容 双向绑定一般都应用在表单元素 如 input select 等 v-model:value 可以简写为 v-model 因为 v-model默认收集的就是valuede值 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;03.数据绑定&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- vue有单向数据绑定和双向数据绑定两种 1. 单向绑定 v-bind 数据只能从data流向页面 2. 双向绑定 v-model 数据不仅可以从data流向页面，当页面发生改变同样可以修改data的内容 3. 双向绑定一般都应用在表单元素 如 input select 等 4. v-model:value 可以简写为 v-model 因为 v-model默认收集的就是valuede值 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;单向数据绑定 : v-bind 的简写&lt;/h2&gt; &lt;input type=&quot;text&quot; :value=&quot;title&quot; /&gt; &lt;h2&gt;双向数据绑定 v-model&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;title&quot; /&gt; &lt;!-- 如下代码是错误的： [Vue warn]: Failed to resolve directive: modle --&gt; &lt;h2 v-modle:value=&quot;title&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; title: &#x27;hello vue&#x27;, url: &#x27;http://www.odinsam.com&#x27; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 效果如图","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://www.odinsam.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"name":"v-bind","slug":"v-bind","permalink":"https://www.odinsam.com/tags/v-bind/"},{"name":"v-model","slug":"v-model","permalink":"https://www.odinsam.com/tags/v-model/"}],"author":"OdinSam"},{"title":"Vue2.0 - 02. 模板语法","slug":"Vue2-0-01-模板语法","date":"2022-10-14T16:26:00.000Z","updated":"2022-10-17T14:03:56.125Z","comments":true,"path":"/articles/1660.html","link":"","permalink":"https://www.odinsam.com/articles/1660.html","excerpt":"【Vue2.0】学习系列 第2章: vue 的模板语法.","text":"【Vue2.0】学习系列 第2章: vue 的模板语法. 完整代码可以在 GitHub 。 模板语法有插值语法和指令语法 指令语法常用语解析标签 包括标签属性、标签内容、标签事件 v-bind绑定 将 “”中的内容即 url 当做js表达式， url在data中找到对应的链接，所以绑定在a标签的href属性上 v-bind 可以简写为 : v-bind 仅可以绑定数据，单向数据绑定（从data中获取数据绑定到页面中），页面中的数据发生变化，无法修改data中的内容 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;02.模板语法&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--模板语法有插值语法和指令语法--&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 插值语法一般用于显示标签的内容 --&gt; &lt;h1&gt;插值语法: &#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;指令语法&lt;/h2&gt; &lt;!-- 指令语法常用语解析标签 包括标签属性、标签内容、标签事件 v-bind绑定 1. 将 “”中的内容即 url 当做js表达式， url在data中找到对应的链接，所以绑定在a标签的href属性上 2. v-bind 可以简写为 : 3. v-bind 仅可以绑定数据，单向数据绑定（从data中获取数据绑定到页面中），页面中的数据发生变化，无法修改data中的内容 --&gt; &lt;a v-bind:href=&quot;url&quot;&gt;odinsam 的博客&lt;/a&gt; &lt;br /&gt; &lt;a :href=&quot;Date.now()&quot;&gt;当前时间&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; title: &#x27;hello vue&#x27;, url: &#x27;http://www.odinsam.com&#x27; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"Vue2.0 - 01. hello vue","slug":"Vue-01-hello-vue","date":"2022-10-14T16:18:00.000Z","updated":"2022-10-18T12:59:13.906Z","comments":true,"path":"/articles/deab.html","link":"","permalink":"https://www.odinsam.com/articles/deab.html","excerpt":"【Vue2.0】学习系列 第1章: 初始 vue.","text":"【Vue2.0】学习系列 第1章: 初始 vue. 完整代码可以在 GitHub 。 需要创建vue实例，且传入一个配置对象 root容器中的代码需要符合html规范，只是加入了vue语法 root容器立的代码被称为 vue 模板 插值语法 {{ $1 }} 中的内容需要是 js 表达式，且内容可以直接读取到配置的data中所有的属性 vue实例和容器需要时一一对应 一旦 data 中的数据发生变化，页面会自动更新 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;01.hello案例&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1. 需要创建vue实例，且传入一个配置对象 2. root容器中的代码需要符合html规范，只是加入了vue语法 3. root容器立的代码被称为 vue 模板 4. 插值语法 &#123;&#123; $1 &#125;&#125; 中的内容需要是 js 表达式，且内容可以直接读取到配置的data中所有的属性 5. vue实例和容器需要时一一对应 6. 一旦 data 中的数据发生变化，页面会自动更新 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello vue&lt;/h1&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;!--当前语法为 vue 的插值语法--&gt; &lt;h2&gt;&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; //阻止 vue 在启动时生成生产提示 Vue.config.productionTip = false; //创建vue实例 const vm = new Vue(&#123; //指定当前vue实例为那个容器服务， css选择器选择对应容器 el: &#x27;#root&#x27;, //定义对应的数据，可以在对应的容器 el 中使用 data: &#123; name: &#x27;odinsam&#x27;, age: 20 &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"插值语法","slug":"插值语法","permalink":"https://www.odinsam.com/tags/%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95/"}],"author":"OdinSam"},{"title":"Vue2.0 系列","slug":"Vue2-0-系列","date":"2022-10-14T16:16:00.000Z","updated":"2022-10-18T13:01:44.525Z","comments":true,"path":"/articles/da3d.html","link":"","permalink":"https://www.odinsam.com/articles/da3d.html","excerpt":"vue2.0 基础学习目录. vue2.0 进阶学习的目录","text":"vue2.0 基础学习目录. vue2.0 进阶学习的目录 完整代码可以在 GitHub 。 目录 [01] hello vue [02] 模板语法 [03] 数据绑定 [04] el与data的两种写法 [05] mvvm模型 [06] 数据代理-Object.defineProperty [07] 事件处理 [08] 事件修饰符 [09] 键盘事件 [10] Computed计算属性 [11] Watch监视属性 [12] 样式的绑定 [13] vue指令 [14] vue.set方法 [15] 表单数据的收集 [16] Filter过滤器 [17] 生命周期 [18.1] vue组件 - 非单文件组件 [18.2] vue组件 - 组件嵌套 [18.3] vue组件 - 内置关系 [18.4] vue组件 - 单文件组件 [19] Vue脚手架","categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"}],"author":"OdinSam"},{"title":"OdinLog 组件","slug":"dinLog-组件","date":"2022-07-03T10:37:10.000Z","updated":"2022-07-05T13:17:00.000Z","comments":true,"path":"/articles/86b2.html","link":"","permalink":"https://www.odinsam.com/articles/86b2.html","excerpt":"自定义简单的一个日志组件。可以存储本地文件，也可以存储到数据库(目前仅支持 mysql 和 sqlServer 数据库)。后期扩展和ELK结合。具体源代码在github可以查看。","text":"自定义简单的一个日志组件。可以存储本地文件，也可以存储到数据库(目前仅支持 mysql 和 sqlServer 数据库)。后期扩展和ELK结合。具体源代码在github可以查看。 1. 简介 组件可以生成对应日志文件( bin 目录下)，可用于winform、webapi项目。如果存储在本地，以日志级别 Info、Debug、Error生成文件夹，内部以 yyyy-MM-dd 格式生成文件夹。日志文件以数字标识，如果单个日志文件大小超过5M则另生成日志文件。 2. 组件使用 可以使用依赖注入，也可以在配置Config后直接使用 依赖注入1234builder.Services.AddOdinSingletonOdinLogs(opt=&gt; opt.Config=new LogConfig &#123; LogSaveType=new EnumLogSaveType[]&#123;EnumLogSaveType.All&#125;, ConnectionString = &quot;server=xxxx;Database=xxxx;Uid=xxx;Pwd=xxx;&quot;&#125;); 直接配置123OdinLog.Core.OdinLogs = new OdinLogs(new LogConfig &#123; LogSaveType=new EnumLogSaveType[]&#123;EnumLogSaveType.All&#125;, ConnectionString = &quot;server=xxxx;Database=xxxx;Uid=xxx;Pwd=xxx;&quot;&#125;);) 调用123456OdinLogs.Info(new LogInfo()&#123;LogContent = &quot;log info test&quot;,LogMark=&quot;log mark&quot;, &#125;); OdinLogs.Error( new ExceptionLog()&#123; LogContent = &quot;log exception test&quot;, LogMark=&quot;log mark&quot;, LogException = new Exception(&quot;custom exceptioni&quot;)&#125;); 具体配置参看 LogConfig 结构 3. 存储表结构 https://github.com/odinsam/OdinLog/tree/master/OdinLog/doc/DDL/scripts 4. 文件夹结构、文件内容格式如下： 1234567891011-- logs --Info -- 2022-06-01 0.txt 1.txt --Debug -- 2022-06-01 0.txt --Error -- 2022-06-01 0.txt Info、Debug 文件内容格式如下: 123456【 LogId 】: 766c769d349d494daf82fca503666d5d 【 Log Level 】: Info 【 LogTime 】: 2022-07-03 17:59:44 【 LogContent 】:log info test**************************************************************************************************** Error 文件内容格式如下: 1234567891011121314151617181920【 LogId 】: 57c2978db92a44959e613f7a1e733d8b 【 Log Level 】: Error 【 LogTime 】: 2022-07-03 18:10:51 【 Exception Message 】: custom exceptioni【 Exception Info 】: &#123; &quot;ClassName&quot;: &quot;System.Exception&quot;, &quot;Message&quot;: &quot;custom exceptioni&quot;, &quot;Data&quot;: null, &quot;InnerException&quot;: null, &quot;HelpURL&quot;: null, &quot;StackTraceString&quot;: null, &quot;RemoteStackTraceString&quot;: null, &quot;RemoteStackIndex&quot;: 0, &quot;ExceptionMethod&quot;: null, &quot;HResult&quot;: -2146233088, &quot;Source&quot;: null, &quot;WatsonBuckets&quot;: null&#125;**************************************************************************************************** 具体的代码在 GitHub","categories":[],"tags":[],"author":"OdinSam"},{"title":"mysql8 远程连接解决办法","slug":"mysql8-远程连接解决办法","date":"2022-06-30T07:41:00.000Z","updated":"2022-06-30T07:43:43.000Z","comments":true,"path":"/articles/8b92.html","link":"","permalink":"https://www.odinsam.com/articles/8b92.html","excerpt":"","text":"123grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; ;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;flush privileges;","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.odinsam.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.odinsam.com/tags/mysql/"}],"author":"OdinSam"},{"title":"ApiLinkMonitor 单服务链路追踪框架","slug":"ApiLinkMonitor-单服务链路追踪框架","date":"2021-07-24T12:01:00.000Z","updated":"2021-07-24T12:07:26.000Z","comments":true,"path":"/articles/5b4d.html","link":"","permalink":"https://www.odinsam.com/articles/5b4d.html","excerpt":"在平时的开发中，虽然我们有日志信息、报错信息等等，但是我们依然在某些时候需要查看项目中方法调用的来龙去脉，这种信息一般叫做链路信息。这里介绍一个单服务用于中小型项目的链路追踪框架。","text":"在平时的开发中，虽然我们有日志信息、报错信息等等，但是我们依然在某些时候需要查看项目中方法调用的来龙去脉，这种信息一般叫做链路信息。这里介绍一个单服务用于中小型项目的链路追踪框架。 服务调用链路监控框架 简介 项目基于 OdinInjectCore 和 SnowFlake 框架开发，使用 .net core 中间件实现，主要用到了 AspectCore.Core 第三方框架为底层服务类方法调用的链路监控。监控的项目调用的链路信息入库 mongo，所以需要搭配 mongo 一起使用. 并且 使用 1234567891011121314// 注入链路监控services .AddSingletonSnowFlake(dataCenterId, workerId) .AddOdinTransientMongoDb( opt =&gt; &#123; opt.ConnectionString = mongoConnection; opt.DbName = databaseName; &#125;) .AddOdinTransientInject&lt;IOdinApiLinkMonitor&gt;();services.ConfigureDynamicProxy(config =&gt; &#123; // ~ 使用通配符的特定全局拦截器 config.Interceptors.AddTyped&lt;OdinAspectCoreInterceptorAttribute&gt;(Predicates.ForService(&quot;*Service&quot;)); &#125;); 链路数据 controller 调用的 service 类需要以 Service 结尾,例如 接口 ITestService 和 实现类 TestService,controller 的 api 方法被调用后生成链路数据. 所有数据均进入 mongo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&#123; // 链路的 雪花Id，本次链路唯一 &quot;Id&quot;: 206324387228553216, // 链路 当前的雪花Id &quot;CurrentId&quot;: 206324387245330432, // 链路状态 &quot;LinkStatusEnum&quot;: 0, // 链路状态描述 start 表示本次链路开始 &quot;LinkStatusStr&quot;: &quot;Start&quot;, // 上层链路雪花Id 0代表没有上层链路 &quot;LinkPrevious&quot;: 0, // 链路调用返回的状态 &quot;InvokerReturnStatusEnum&quot;: 0, // 链路调用返回的状态描述 &quot;InvokerReturnStatusStr&quot;: null, // 下级链路雪花Id &quot;LinkNext&quot;: 206324387245330433, // 链路耗时 &quot;ElapsedTime&quot;: null, // 链路调用的完整类名 &quot;InvokerClassFullName&quot;: null, // 链路调用的类名 &quot;InvokerClassName&quot;: null, // 调用的方法名 &quot;InvokerMethodName&quot;: null, // 本次链路的需要 从小到大排序 &quot;LinkSort&quot;: 0&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324394790883328, &quot;LinkStatusEnum&quot;: 1, // 链路状态描述 Invoker 表示链路调用中 &quot;LinkStatusStr&quot;: &quot;Invoker&quot;, // 与上一层链路的 LinkNext 对应 &quot;LinkPrevious&quot;: 206324387245330433, &quot;InvokerReturnStatusEnum&quot;: 0, &quot;InvokerReturnStatusStr&quot;: null, &quot;LinkNext&quot;: 206324394790883329, &quot;ElapsedTime&quot;: null, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.ITestService&quot;, &quot;InvokerClassName&quot;: &quot;ITestService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 1&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324394962849792, &quot;LinkStatusEnum&quot;: 1, &quot;LinkStatusStr&quot;: &quot;Invoker&quot;, &quot;LinkPrevious&quot;: 206324394790883329, &quot;InvokerReturnStatusEnum&quot;: 0, &quot;InvokerReturnStatusStr&quot;: null, &quot;LinkNext&quot;: 206324394962849793, &quot;ElapsedTime&quot;: null, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.IInerService&quot;, &quot;InvokerClassName&quot;: &quot;IInerService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 2&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324395122233344, &quot;LinkStatusEnum&quot;: 1, &quot;LinkStatusStr&quot;: &quot;Invoker&quot;, &quot;LinkPrevious&quot;: 206324394962849793, &quot;InvokerReturnStatusEnum&quot;: 0, &quot;InvokerReturnStatusStr&quot;: null, &quot;LinkNext&quot;: 206324395122233345, &quot;ElapsedTime&quot;: null, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.ITTService&quot;, &quot;InvokerClassName&quot;: &quot;ITTService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 3&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324395277422592, &quot;LinkStatusEnum&quot;: 3, // 链路状态描述 ToEndReturn 表示链路调用返回 &quot;LinkStatusStr&quot;: &quot;ToEndReturn&quot;, &quot;LinkPrevious&quot;: 206324395122233345, &quot;InvokerReturnStatusEnum&quot;: 2, // 链路调用返回的状态描述 CatchReturn 表示调用出现异常 但是被catch捕获 &quot;InvokerReturnStatusStr&quot;: &quot;CatchReturn&quot;, &quot;LinkNext&quot;: 206324395277422593, &quot;ElapsedTime&quot;: 37, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.ITTService&quot;, &quot;InvokerClassName&quot;: &quot;ITTService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 4&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324395520692224, &quot;LinkStatusEnum&quot;: 3, &quot;LinkStatusStr&quot;: &quot;ToEndReturn&quot;, &quot;LinkPrevious&quot;: 206324395277422593, &quot;InvokerReturnStatusEnum&quot;: 2, &quot;InvokerReturnStatusStr&quot;: &quot;CatchReturn&quot;, &quot;LinkNext&quot;: 206324395520692225, &quot;ElapsedTime&quot;: 133, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.IInerService&quot;, &quot;InvokerClassName&quot;: &quot;IInerService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 5&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324395667492864, &quot;LinkStatusEnum&quot;: 3, &quot;LinkStatusStr&quot;: &quot;ToEndReturn&quot;, &quot;LinkPrevious&quot;: 206324395520692225, &quot;InvokerReturnStatusEnum&quot;: 2, &quot;InvokerReturnStatusStr&quot;: &quot;CatchReturn&quot;, &quot;LinkNext&quot;: 206324395667492865, &quot;ElapsedTime&quot;: 210, &quot;InvokerClassFullName&quot;: &quot;OdinCore.Services.InterfaceServices.ITestService&quot;, &quot;InvokerClassName&quot;: &quot;ITestService&quot;, &quot;InvokerMethodName&quot;: &quot;show&quot;, &quot;LinkSort&quot;: 6&#125;&#123; &quot;Id&quot;: 206324387228553216, &quot;CurrentId&quot;: 206324396925784064, &quot;LinkStatusEnum&quot;: 2, // 链路状态描述 Over 表示本次链路调用结束 &quot;LinkStatusStr&quot;: &quot;Over&quot;, &quot;LinkPrevious&quot;: 206324395667492865, &quot;InvokerReturnStatusEnum&quot;: 1, // 调用成功结束 &quot;InvokerReturnStatusStr&quot;: &quot;Success&quot;, &quot;LinkNext&quot;: 0, // 本次调用 2558 ms &quot;ElapsedTime&quot;: 2558, &quot;InvokerClassFullName&quot;: null, &quot;InvokerClassName&quot;: null, &quot;InvokerMethodName&quot;: null, &quot;LinkSort&quot;: 7&#125; 解析 通过链路数据得出结论： 本次 api 调用： 首先 调用 OdinCore.Services.InterfaceServices.ITestService 类的 show 方法,方法内部调用 OdinCore.Services.InterfaceServices.IInerService 类的 show 方法， 然后又调用 OdinCore.Services.InterfaceServices.ITTService 类的 show 方法，结果调用出错，但是被 catch 捕获最后返回。 swagger 调用返回信息如下: 1234567891011121314151617181920&#123; &quot;SnowFlakeId&quot;: &quot;206324387228553216&quot;, &quot;Data&quot;: &#123; &quot;ClassName&quot;: &quot;System.Exception&quot;, &quot;Message&quot;: &quot;ttservice throw&quot;, &quot;Data&quot;: null, &quot;InnerException&quot;: null, &quot;HelpURL&quot;: null, &quot;StackTraceString&quot;: &quot; at OdinPlugs.OdinMvcCore.OdinFilter.ApiInvokerFilterAttribute.OnActionExecuted(ActionExecutedContext context) in /Users/odin/workSpace/github/odinmaf/OdinPlugs/OdinMvcCore/OdinFilter/ApiInvokFilterAttribute.cs:line 109\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeNextActionFilterAsync()\\n--- End of stack trace from previous location ---\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeInnerFilterAsync()\\n--- End of stack trace from previous location ---\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeNextExceptionFilterAsync&gt;g__Awaited|25_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ExceptionContextSealed context)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeNextResourceFilter()\\n--- End of stack trace from previous location ---\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ResourceExecutedContextSealed context)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeFilterPipelineAsync()\\n--- End of stack trace from previous location ---\\n at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Logged|17_1(ResourceInvoker invoker)\\n at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)\\n at Microsoft.AspNetCore.MiddlewareAnalysis.AnalysisMiddleware.Invoke(HttpContext httpContext)\\n at OdinPlugs.ApiLinkMonitor.OdinMiddleware.OdinExceptionMiddleware.Invoke(HttpContext context) in /Users/odin/workSpace/github/odinmaf/OdinPlugs.ApiLinkMonitor/OdinMiddleware/OdinExceptionMiddleware.cs:line 34&quot;, &quot;RemoteStackTraceString&quot;: null, &quot;RemoteStackIndex&quot;: 0, &quot;ExceptionMethod&quot;: null, &quot;HResult&quot;: -2146233088, &quot;Source&quot;: &quot;AspectCore.Core&quot;, &quot;WatsonBuckets&quot;: null &#125;, &quot;StatusCode&quot;: &quot;sys-error&quot;, &quot;ErrorMessage&quot;: &quot;系统异常，请联系管理员&quot;, &quot;Message&quot;: &quot;系统异常:[sys-error]&quot;&#125; 通过相同的雪花 Id 最后会清晰的分析出整个调用过程中的过程，并且如果能够结合 OdinPlugs 框架,可以监控到 controller 中 api 的调用记录，包括入参、时间、返回信息等会更加详细。 具体的代码在 GitHub","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":"链路追踪","slug":"链路追踪","permalink":"https://www.odinsam.com/tags/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"},{"name":"ApiLinkMonitor","slug":"ApiLinkMonitor","permalink":"https://www.odinsam.com/tags/ApiLinkMonitor/"}],"author":"OdinSam"},{"title":"利用BackgroundService封装后台服务","slug":"用BackgroundService封装后台服务","date":"2021-07-22T15:21:00.000Z","updated":"2021-07-24T11:59:28.000Z","comments":true,"path":"/articles/c075.html","link":"","permalink":"https://www.odinsam.com/articles/c075.html","excerpt":"在之前的文章 使用 BackgroundService 类在微服务中实现后台任务 中有介绍到如何利用 BackgroundService 来实现后台服务，这里我们依旧利用 BackgroundService 来进行类似 hangfire 的封装。","text":"在之前的文章 使用 BackgroundService 类在微服务中实现后台任务 中有介绍到如何利用 BackgroundService 来实现后台服务，这里我们依旧利用 BackgroundService 来进行类似 hangfire 的封装。 OdinPlugs.OdinHostedService 使用方法 1.1 后台任务 - 普通任务，立即执行，只执行一次 123456789services.AddOdinBgServiceNomalJob(opt =&gt;&#123; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - Nomal - Job - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;;&#125;); 1.2 后台任务 - 延迟调用，只执行一次 12345678910services.AddOdinBgServiceScheduleJob(opt =&gt;&#123; opt.DueTime = 5000; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - ScheduleJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;;&#125;); 1.3 后台任务 - 循环任务执行：重复执行的任务，使用常见的时间循环模式 12345678910services.AddOdinBgServiceScheduleJob(opt =&gt;&#123; opt.DueTime = 5000; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - ScheduleJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;;&#125;); 1.4 后台任务 - 循环任务执行：重复执行的任务(任务执行完后继续自动执行) 12345678910services.AddOdinBgServiceLoopJob(opt =&gt;&#123; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - LoopJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif Thread.Sleep(1000); &#125;;&#125;); 1.5 后台任务 - 自定义任务 1234567891011121314151617181920212223242526services.AddOdinBgServiceJob(opt =&gt;&#123; Timer timer = null; void worker(object state) &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125; opt.StartAsyncAction = () =&gt; &#123; timer = new Timer(worker, null, 0, 2000); &#125;; opt.ExecuteAsyncAction = () =&gt; &#123; &#125;; opt.StopAsyncAction = () =&gt; &#123; timer?.Change(Timeout.Infinite, 0); &#125;; opt.DisposeAction = () =&gt; &#123; timer?.Dispose(); &#125;;&#125;); 1.6 后台任务 - 多任务执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768services .AddOdinBgServiceJob(opt =&gt; &#123; Timer timer = null; void worker(object state) &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125; opt.StartAsyncAction = () =&gt; &#123; timer = new Timer(worker, null, 0, 2000); &#125;; opt.ExecuteAsyncAction = () =&gt; &#123; &#125;; opt.StopAsyncAction = () =&gt; &#123; timer?.Change(Timeout.Infinite, 0); &#125;; opt.DisposeAction = () =&gt; &#123; timer?.Dispose(); &#125;; &#125;) .AddOdinBgServiceLoopJob(opt =&gt; &#123; opt.ActionJob = () =&gt; &#123; // new ReceiveRabbitMQHelper().ReceiveMQ(_Options);#if DEBUG Log.Information($&quot;Service:【 BgService - LoopJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif Thread.Sleep(1000); &#125;; &#125;) .AddOdinBgServiceRecurringJob(opt =&gt; &#123; opt.Period = TimeSpan.FromSeconds(1); opt.ActionJob = () =&gt; &#123; // new ReceiveRabbitMQHelper().ReceiveMQ(_Options);#if DEBUG Log.Information($&quot;Service:【 BgService - RecurringJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;; &#125;) .AddOdinBgServiceNomalJob(opt =&gt; &#123; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - Nomal- Job - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;; &#125;) .AddOdinBgServiceScheduleJob(opt =&gt; &#123; opt.DueTime = 5000; opt.ActionJob = () =&gt; &#123;#if DEBUG Log.Information($&quot;Service:【 BgService - ScheduleJob - Running 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;);#endif &#125;; &#125;); 具体的代码在 GitHub","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"微服务","slug":"微服务","permalink":"https://www.odinsam.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"BackgroundService","slug":"BackgroundService","permalink":"https://www.odinsam.com/tags/BackgroundService/"},{"name":"后台服务","slug":"后台服务","permalink":"https://www.odinsam.com/tags/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/"}],"author":"OdinSam"},{"title":"关于Mapster对象映射器的封装和使用","slug":"关于Mapster对象映射器的封装和使用","date":"2021-07-15T11:41:00.000Z","updated":"2021-07-15T11:53:29.000Z","comments":true,"path":"/articles/9cc8.html","link":"","permalink":"https://www.odinsam.com/articles/9cc8.html","excerpt":"说到 .NET 中的对象映射框架，大部分人的第一映像就是 AutoMapper ，而 Mapster 相对知道的人较少。但其实 Mapster 是一个高性能的对象映射框架，与 AutoMapper 相比，Mapster 在速度和内存占用方面表现更加优秀，可以在只使用1/3内存的情况下获得4倍的性能提升。","text":"说到 .NET 中的对象映射框架，大部分人的第一映像就是 AutoMapper ，而 Mapster 相对知道的人较少。但其实 Mapster 是一个高性能的对象映射框架，与 AutoMapper 相比，Mapster 在速度和内存占用方面表现更加优秀，可以在只使用1/3内存的情况下获得4倍的性能提升。 基础类 12345678910public class Student&#123; public string StuName &#123; get; set; &#125; public string StuAddress &#123; get; set; &#125;&#125;public class Student_DbModel&#123; public string StudentName &#123; get; set; &#125; public string StudentAddress &#123; get; set; &#125;&#125; Startup.cs 注册全局映射Config，也可以不注册 123456789101112// 使用 OdinInjectCore 注入services.AddOdinTypeAdapter(opt =&gt; &#123; opt.ForType&lt;ErrorCode_DbModel, ErrorCode_Model&gt;() .Map(dest =&gt; dest.ShowMessage, src =&gt; src.CodeShowMessage); &#125;);// 使用 .net core DI 注入services.AddSingleton&lt;ITypeAdapterMapster&gt;(provider =&gt; new TypeAdapterMapster(opt =&gt; &#123; opt.ForType&lt;ErrorCode_DbModel, ErrorCode_Model&gt;() .Map(dest =&gt; dest.ShowMessage, src =&gt; src.CodeShowMessage); &#125;)); 使用时获取全局注册Config 1234// 使用 OdinInjectCore 获取 TypeAdapterMapstervar mapsterConfig = OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig();// 使用 .net core 默认 DI 获取 TypeAdapterMapstervar mapsterConfig = services.BuildServiceProvider().GetService&lt;ITypeAdapterMapster&gt;().GetConfig(); 获取数据准备映射转换对象 123// 通过 SqlSugar 获取数据库中的数据List&lt;Student_DbModel&gt; stuDbModels = DbScoped.Sugar.Queryable&lt;Student_DbModel&gt;().ToList();Student_DbModel stuDbModel = stuDbModels[0]; 对象映射转换 123456789101112131415161718192021222324// 使用全局映射配置转换目标对象类型var stu = stuDbModel.OdinTypeAdapterBuilder&lt;Student_DbModel, Student&gt;( OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig() );// 使用自定义映射配置转换目标对象类型// 需要注意的是: 因为没有传全局映射配置, 此时虽然全局配置也有 StudentName 属性映射 StuName 的配置，但是会以当前自定义配置为准var stu = stuDbModel.OdinTypeAdapterBuilder&lt;Student_DbModel, Student&gt;( opt =&gt; &#123; opt.Map(dest =&gt; dest.StuName, src =&gt; src.StudentName); &#125; );// 使用自定义映射+全局映射配置转换目标对象对象类型// 需要注意的是: 因为全局映射配置中有 StudentName 属性映射 StuName 的配置，所以当自定义配置与全局配置都存在时，以全局配置为准var stu = stuDbModel.OdinTypeAdapterBuilder&lt;Student_DbModel, Student&gt;( opt =&gt; &#123; opt.Map(dest =&gt; dest.StuName, src =&gt; src.StudentName); opt.Map(dest =&gt; dest.StuAddress, src =&gt; src.StudentAddress); &#125;, OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig() ); 集合映射转换 将 stuDbModels List&lt;ErrorCode_DbModel&gt; 集合映射转换为 stuLst List 类型的集合 泛型参数说明: 参数名称 说明 Student_DbModel 映射的源类型 Student 转换的目标类型 List 最终转换后的集合类型 123456789101112131415161718192021222324// 使用全局映射配置转换目标对象类型var stuLst = stuDbModels.OdinTypeAdapterBuilder&lt;Student_DbModel, Student, List&lt;Student&gt;&gt;( OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig() );// 使用自定义映射配置转换目标对象类型// 需要注意的是: 因为没有传全局映射配置, 此时虽然全局配置也有 StudentName 属性映射 StuName 的配置，但是会以当前自定义配置为准var stuLst = stuDbModels.OdinTypeAdapterBuilder&lt;Student_DbModel, Student, List&lt;Student&gt;&gt;( opt =&gt; &#123; opt.Map(dest =&gt; dest.StuName, src =&gt; src.StudentName); &#125; );// 使用自定义映射+全局映射配置转换目标对象对象类型// 需要注意的是: 因为全局映射配置中有 StudentName 属性映射 StuName 的配置，所以当自定义配置与全局配置都存在时，以全局配置为准var stuLst = stuDbModels.OdinTypeAdapterBuilder&lt;Student_DbModel, Student, List&lt;Student&gt;&gt;( opt =&gt; &#123; opt.Map(dest =&gt; dest.StuName, src =&gt; src.StudentName); opt.Map(dest =&gt; dest.StuAddress, src =&gt; src.StudentAddress); &#125;, OdinInjectCore.GetService&lt;ITypeAdapterMapster&gt;().GetConfig() ); 关于 Mapster 更详细的用法，请参照 Mapster 官网。 具体封装代码详见 Github","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"Mapster","slug":"Mapster","permalink":"https://www.odinsam.com/tags/Mapster/"}],"author":"OdinSam"},{"title":".Net中关于Json序列化Long类型数据的解决办法","slug":"Net中关于Json序列化Long类型数据的解决办法","date":"2021-07-06T15:11:09.000Z","updated":"2021-07-06T16:06:53.000Z","comments":true,"path":"/articles/4ad7.html","link":"","permalink":"https://www.odinsam.com/articles/4ad7.html","excerpt":"在分布式的项目中，我们的数据库Id不能再像以前一样使用int类型自动增长，这时候我们需要一个在网络当中都要能够保持唯一的值，通常情况我们会使用Guid来解决这个问题，但是作为string类型，他并不适合作为主键。尤其是在查询等需要索引操作的时候显得尤为重要。","text":"在分布式的项目中，我们的数据库Id不能再像以前一样使用int类型自动增长，这时候我们需要一个在网络当中都要能够保持唯一的值，通常情况我们会使用Guid来解决这个问题，但是作为string类型，他并不适合作为主键。尤其是在查询等需要索引操作的时候显得尤为重要。 这时候我们通常会选择使用雪花Id来解决这个问题，他是一个能在网络当中能够保证唯一的数值number类型的数字，对应在csharp中是long类型。具体雪花Id的原理网上都有，这里直接上生成雪花Id的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public class OdinSnowFlake : IOdinSnowFlake&#123; // 开始时间截((new DateTime(2020, 1, 1, 0, 0, 0, DateTimeKind.Utc)-Jan1st1970).TotalMilliseconds) private readonly long twepoch; // 机器id所占的位数 private const int workerIdBits = 5; // 数据标识id所占的位数 private const int datacenterIdBits = 5; // 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) private const long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 支持的最大数据标识id，结果是31 private const long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 序列在id中占的位数 private const int sequenceBits = 12; // 数据标识id向左移17位(12+5) private const int datacenterIdShift = sequenceBits + workerIdBits; // 机器ID向左移12位 private const int workerIdShift = sequenceBits; // 时间截向左移22位(5+5+12) private const int timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; // 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) private const long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); // 数据中心ID(0~31) public long datacenterId &#123; get; private set; &#125; // 工作机器ID(0~31) public long workerId &#123; get; private set; &#125; // 毫秒内序列(0~4095) public long sequence &#123; get; private set; &#125; // 上次生成ID的时间截 public long lastTimestamp &#123; get; private set; &#125; private static Dictionary&lt;long, long&gt; dicContainer = null; /// &lt;summary&gt; /// 雪花ID /// &lt;/summary&gt; /// &lt;param name=&quot;datacenterId&quot;&gt;数据中心ID&lt;/param&gt; /// &lt;param name=&quot;workerId&quot;&gt;工作机器ID&lt;/param&gt; public OdinSnowFlake(long datacenterId, long workerId) &#123; this.twepoch = (long)((new DateTime(2020, 1, 1, 0, 0, 0, DateTimeKind.Utc) - Jan1st1970).TotalMilliseconds); if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new Exception(string.Format(&quot;datacenter Id can&#x27;t be greater than &#123;0&#125; or less than 0&quot;, maxDatacenterId)); &#125; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new Exception(string.Format(&quot;worker Id can&#x27;t be greater than &#123;0&#125; or less than 0&quot;, maxWorkerId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; this.sequence = 0L; this.lastTimestamp = -1L; if (dicContainer == null) dicContainer = new Dictionary&lt;long, long&gt;(); &#125; public void InitDic() &#123; if (dicContainer == null) dicContainer = new Dictionary&lt;long, long&gt;(); &#125; public void ClearDic() &#123; if (dicContainer != null) dicContainer.Clear(); &#125; /// &lt;summary&gt; /// 获得下一个ID /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public long NextId() &#123; lock (this) &#123; long timestamp = GetCurrentTimestamp(); if (timestamp &gt; lastTimestamp) //时间戳改变，毫秒内序列重置 &#123; sequence = 0L; &#125; else if (timestamp == lastTimestamp) //如果是同一时间生成的，则进行毫秒内序列 &#123; sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) //毫秒内序列溢出 &#123; timestamp = GetNextTimestamp(lastTimestamp); //阻塞到下一个毫秒,获得新的时间戳 &#125; &#125; else //当前时间小于上一次ID生成的时间戳，证明系统时钟被回拨，此时需要做回拨处理 &#123; sequence = (sequence + 1) &amp; sequenceMask; if (sequence &gt; 0) &#123; timestamp = lastTimestamp; //停留在最后一次时间戳上，等待系统时间追上后即完全度过了时钟回拨问题。 &#125; else //毫秒内序列溢出 &#123; timestamp = lastTimestamp + 1; //直接进位到下一个毫秒 &#125; //throw new Exception(string.Format(&quot;Clock moved backwards. Refusing to generate id for &#123;0&#125; milliseconds&quot;, lastTimestamp - timestamp)); &#125; lastTimestamp = timestamp; //上次生成ID的时间截 //移位并通过或运算拼到一起组成64位的ID var id = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; if (!dicContainer.ContainsKey(id)) &#123; dicContainer.Add(id, id); return id; &#125; else &#123; Thread.Sleep(1); return NextId(); &#125; &#125; &#125; /// &lt;summary&gt; /// 解析雪花ID /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string AnalyzeId(long Id) &#123; StringBuilder sb = new StringBuilder(); var timestamp = (Id &gt;&gt; timestampLeftShift); var time = Jan1st1970.AddMilliseconds(timestamp + twepoch); sb.Append(time.ToLocalTime().ToString(&quot;yyyy-MM-dd HH:mm:ss:fff&quot;)); var datacenterId = (Id ^ (timestamp &lt;&lt; timestampLeftShift)) &gt;&gt; datacenterIdShift; sb.Append(&quot;_&quot; + datacenterId); var workerId = (Id ^ ((timestamp &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift))) &gt;&gt; workerIdShift; sb.Append(&quot;_&quot; + workerId); var sequence = Id &amp; sequenceMask; sb.Append(&quot;_&quot; + sequence); return sb.ToString(); &#125; /// &lt;summary&gt; /// 阻塞到下一个毫秒，直到获得新的时间戳 /// &lt;/summary&gt; /// &lt;param name=&quot;lastTimestamp&quot;&gt;上次生成ID的时间截&lt;/param&gt; /// &lt;returns&gt;当前时间戳&lt;/returns&gt; private static long GetNextTimestamp(long lastTimestamp) &#123; long timestamp = GetCurrentTimestamp(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = GetCurrentTimestamp(); &#125; return timestamp; &#125; /// &lt;summary&gt; /// 获取当前时间戳 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static long GetCurrentTimestamp() &#123; return (long)(DateTime.UtcNow - Jan1st1970).TotalMilliseconds; &#125; private static readonly DateTime Jan1st1970 = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);&#125; 代码解释： 提供了构造函数，其中datacenterId为当前数据中心Id:一般从1开始。workerId是机器Id,需要注意的是在网络节点当中的服务器，这个Id不能重复 代码的 NextId() 方法将会生成一个 18位长的long类型的雪花Id。 AnalyzeId() 方法可以简单的解析一个long的数值是不是符合雪花Id的规范。这个解析不精准，只能判断格式大致是否正确具体解析规则可以看代码。 有了这个Id，我们通常可以开心的在代码当中以application/json格式返回一个对象，比如 输出的结果是 这是因为 JavaScript 数值精度是32位，如果整数数度超过32位，就会被当作浮点数处理。换句话说，如果从服务端生成的JSON，某个值是64位整数，传到前端JavaScript，再传回服务端，不做任何运算，都可能出现失真。 解决问题的办法：将long作为string类型序列化输出 代码如下： 1234567public class Stu&#123; [JsonConverter(typeof(JsonConverterLong))] public long id &#123; get; set; &#125; public string name &#123; get; set; &#125; public int age &#123; get; set; &#125;&#125; JsonConverterLong 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class JsonConverterLong : JsonConverter&#123; /// &lt;summary&gt; /// 是否可以转换 /// &lt;/summary&gt; /// &lt;param name=&quot;objectType&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override bool CanConvert(Type objectType) &#123; return true; &#125; /// &lt;summary&gt; /// 读json /// &lt;/summary&gt; /// &lt;param name=&quot;reader&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;objectType&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;existingValue&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;serializer&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) &#123; if ((reader.ValueType == null || reader.ValueType == typeof(long?)) &amp;&amp; reader.Value == null) &#123; return null; &#125; else &#123; long.TryParse(reader.Value != null ? reader.Value.ToString() : &quot;&quot;, out long value); return value; &#125; &#125; /// &lt;summary&gt; /// 写json /// &lt;/summary&gt; /// &lt;param name=&quot;writer&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;serializer&quot;&gt;&lt;/param&gt; public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) &#123; if (value == null) writer.WriteValue(value); else writer.WriteValue(value + &quot;&quot;); &#125;&#125;","categories":[],"tags":[],"author":"OdinSam"},{"title":"vscode 使用 git-commit-plugin 插件规范提交 Git","slug":"vscode使用git-commit-plugin 插件规范提交Git","date":"2021-06-30T13:49:00.000Z","updated":"2021-07-06T16:02:07.000Z","comments":true,"path":"/articles/34fe.html","link":"","permalink":"https://www.odinsam.com/articles/34fe.html","excerpt":"在团队协作开发时，每个人提交代码时都会写 commit message。每个人都有自己的书写风格，翻看我们组的git log, 可以说是五花八门，十分不利于阅读和维护。本文将介绍 Git 提交的规范以及如何利用 git-commit-plugin 插件快速提交规范的commit。","text":"在团队协作开发时，每个人提交代码时都会写 commit message。每个人都有自己的书写风格，翻看我们组的git log, 可以说是五花八门，十分不利于阅读和维护。本文将介绍 Git 提交的规范以及如何利用 git-commit-plugin 插件快速提交规范的commit。 一般来说，大厂都有一套的自己的提交规范，尤其是在一些大型开源项目中，commit message 都是十分一致的。因此，我们需要制定统一标准，促使团队形成一致的代码提交风格，更好的提高工作效率，成为一名有追求的工程师。其中 AngularJS 在 github 上 的提交记录被业内许多人认可，逐渐被大家引用。 Commit message 的格式 每次提交，Commit message 都包括三个部分：header，body 和 footer。 12345type(scope):空格subject换行[body]换行[footer] 1. type 类型 type 是 commit 的类别，只允许如下几种标识： 12345678910111213141516# 主要typefeat: 增加新功能fix: 修复bug# 特殊type docs: 只改动了文档相关的内容style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号build: 构造工具的或者外部依赖的改动，例如webpack，npmrefactor: 代码重构时使用revert: 执行git revert打印的message# 暂不使用typetest: 添加测试或者修改现有测试perf: 提高性能的改动ci: 与CI（持续集成服务）有关的改动chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动 2. scope scope也为必填项，用于描述改动的范围，格式为项目名/模块名，例如：xxxServices 。如果一次commit修改多个模块，建议拆分成多次commit，以便更好追踪和维护。 3. subject commit 目的的简短描述，不超过50个字符。结尾一般是 #33224 这样的超链接。链接到本次提交的 url 但不强制 4. body 对本次 commit 的详细描述 5. footer Footer 部分只用于以下两种情况： 5.1. 不兼容变动: 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。例如下边这样： 1234567891011121314151617BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: &#x27;attribute&#x27;, &#125; After: scope: &#123; myAttr: &#x27;@&#x27;, &#125; The removed `inject` wasn&#x27;t generaly useful for directives so there should be no code using it. 5.2. 关闭 Issue: 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 完整的提交demo如下： 12345fix(dev-infra): remove bots from special thanks sectionWith this change we remove known used bots from special thanks section in the changelog.PR Close #42697 那么每次都这样编写提交的内容，还要注意对应的格式。我们有没有简单方便的办法呢，那就是使用对应工具的插件。git-commit-plugin 插件可以帮助我们快速的边写提交的信息，但是插件本身并不支持格式化。所以，我在该插件的基础上做了二次开发，具体使用如下： 下载安装对应的插件：git-commit-plugin-1.0.6.vsix 在插件的扩展配置中，进行对应的提交模板配置。可以配置多个，这是因为我公司和我自己的提交格式都不一样。具体可以参见项目的 readme.md 12345678910&quot;GitCommitPlugin.Templates&quot;: [ &#123; &quot;templateName&quot;: &quot;Angular&quot;, &quot;templateContent&quot;: &quot;&lt;icon&gt;&lt;space&gt;&lt;type&gt;(&lt;scope&gt;):&lt;space&gt;&lt;subject&gt;&lt;enter&gt;&lt;body&gt;&lt;enter&gt;&lt;footer&gt;&quot; &#125;, &#123; &quot;templateName&quot;: &quot;git-cz&quot;, &quot;templateContent&quot;: &quot;&lt;type&gt;(&lt;scope&gt;):&lt;space&gt;&lt;icon&gt;&lt;space&gt;&lt;subject&gt;&lt;enter&gt;&lt;body&gt;&lt;enter&gt;&lt;footer&gt;&quot; &#125;] 配置插件是否启用图标 1&quot;GitCommitPlugin.ShowEmoji&quot;: true 最后就可以方便的提交使用了。","categories":[{"name":"Git","slug":"Git","permalink":"https://www.odinsam.com/categories/Git/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://www.odinsam.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/tags/VsCode/"},{"name":"Git","slug":"Git","permalink":"https://www.odinsam.com/tags/Git/"}],"author":"OdinSam"},{"title":".Net Core使用SqlSugar和Cap","slug":"Net-Core使用SqlSugar和Cap","date":"2021-06-16T15:21:00.000Z","updated":"2021-06-16T16:13:08.000Z","comments":true,"path":"/articles/ed30.html","link":"","permalink":"https://www.odinsam.com/articles/ed30.html","excerpt":"近期的一次面试当中聊起了 .Net Core 中的 EF 框架和分布式的事务，因为在项目中也遇到过并发导致 EF Core 性能和报错的各种问题，所以就和面试官吐槽了一下，面试官说他们公司用的 SqlSugar 。这个开源组件库我以前知道的，但很久没有关注。回家看了一下发现这个东西已经非常完善，特此将项目中的 EF Core 变更为了 SqlSugar并且加入了 Cap，顺便记录一下遇到的问题。","text":"近期的一次面试当中聊起了 .Net Core 中的 EF 框架和分布式的事务，因为在项目中也遇到过并发导致 EF Core 性能和报错的各种问题，所以就和面试官吐槽了一下，面试官说他们公司用的 SqlSugar 。这个开源组件库我以前知道的，但很久没有关注。回家看了一下发现这个东西已经非常完善，特此将项目中的 EF Core 变更为了 SqlSugar并且加入了 Cap，顺便记录一下遇到的问题。 1. SqlSugar简介 SqlSugar是一款 老牌 .NET 开源ORM框架，由果糖大数据科技团队维护和更新 ，Github star数仅次于EF 和 Dapper。优点： 简单易用、功能齐全、高性能、轻量级、服务齐全、有专业技术支持一天18小时服务。支持数据库有 MySql、SqlServer、Sqlite、Oracle 、 postgresql、达梦、人大金仓。我的项目习惯了Code First，第一次使用也不知道是否正确。 Startup.cs - SqlSugar 注入代码 123456789services.AddTransient&lt;OdinProjectSugarDbContext&gt;();OdinInjectHelper.ServiceProvider = services.BuildServiceProvider();var sugarEntity = OdinInjectHelper.GetService&lt;OdinProjectSugarDbContext&gt;();#region 初始化数据库//修改cnf.config Host配置的链接字符串 enable修改为true，即可自动化初识数据库if (_Options.DbEntity.InitDb)&#123; sugarEntity.CreateTable(&quot;db_odinCore&quot;, false);&#125; OdinProjectSugarDbContext.cs - DbContext定义以及初始化数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class OdinProjectSugarDbContext&#123; SqlSugarClient db; public OdinProjectSugarDbContext() &#123; db = DbScoped.Sugar; &#125; public void CreateTable(string databaseName, bool Backup = false) &#123; var flag = false; try &#123; // 判断数据库是否存在，如果不存在这里会有异常 flag = db.DbMaintenance.GetDataBaseList(db).Contains(databaseName); &#125; catch &#123; // 如果不存在 初始化创建数据库 db.DbMaintenance.CreateDatabase(databaseName); &#125; finally &#123; if (!flag) &#123; Log.Logger.Information($&quot;【 自动创建数据库 】&quot;); db.DbMaintenance.CreateDatabase(databaseName); // 我在所有的表后边都实现了一个自己的接口 IDbTable var dbTable = typeof(IDbTable); // 找到所有实现了 IDbTable 的类 就是Mysql中对应的表 var types = this.GetType().Assembly.GetTypes().Where(t =&gt; dbTable.IsAssignableFrom(t)); // 是否备份表 if (Backup) &#123; foreach (var item in types) &#123; // 判断表是否存在 如果不存在则新建表 if (!OdinSugarHelper.CheckTable(item)) &#123; DbScoped.Sugar.CodeFirst.BackupTable().InitTables(item); Log.Logger.Information($&quot;创建数据表【 &#123;item.ToString()&#125; 】&quot;); &#125; &#125; &#125; else &#123; foreach (var item in types) &#123; if (!OdinSugarHelper.CheckTable(item)) &#123; DbScoped.Sugar.CodeFirst.InitTables(item); Log.Logger.Information($&quot;创建数据表【 &#123;item.ToString()&#125; 】&quot;); &#125; &#125; &#125; Log.Logger.Information($&quot;启用【 数据库初始化 】---开始配置&quot;); SampleData.Init(); &#125; &#125; &#125; public OdinSugarDbSet&lt;Aop_ApiInvokerCatch_DbModel&gt; ApiInvokerCatchs &#123; get &#123; return new OdinSugarDbSet&lt;Aop_ApiInvokerCatch_DbModel&gt;(db); &#125; &#125; public OdinSugarDbSet&lt;Aop_ApiInvokerRecord_DbModel&gt; ApiInvokerRecords &#123; get &#123; return new OdinSugarDbSet&lt;Aop_ApiInvokerRecord_DbModel&gt;(db); &#125; &#125; public OdinSugarDbSet&lt;ErrorCode_DbModel&gt; ErrorCodes &#123; get &#123; return new OdinSugarDbSet&lt;ErrorCode_DbModel&gt;(db); &#125; &#125;&#125; OdinSugarHelper.cs 1234567891011121314151617181920212223242526272829303132333435public class OdinSugarHelper&#123; static SqlSugarClient Db = DbScoped.Sugar; /// &lt;summary&gt; /// 检查表是否存在 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool CheckTable(Type type) &#123; string tableName = Db.EntityMaintenance.GetTableName(type); return Db.DbMaintenance.IsAnyTable(tableName, false); &#125; /// &lt;summary&gt; /// 检查表是否存在 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool CheckTable&lt;T&gt;() &#123; string tableName = Db.EntityMaintenance.GetTableName(typeof(T)); return Db.DbMaintenance.IsAnyTable(tableName, false); &#125; /// &lt;summary&gt; /// 检查表是否存在 /// &lt;/summary&gt; /// &lt;param name=&quot;TableName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool CheckTable(string TableName) &#123; return Db.DbMaintenance.IsAnyTable(TableName, false); &#125;&#125; 这样程序在运行的时候就基于DbContext的定义可以在数据库新建表。 2. 基于 SqlSugar 使用 cap CAP 是一个在分布式系统中（SOA，MicroService）实现事件总线及最终一致性（分布式事务）的一个开源的 C# 库，她具有轻量级，高性能，易使用等特点。 Startup.cs - SqlSugar 注入代码 1services.AddOdinCapInject(_Options.DbEntity.ConnectionString, _Options.MongoDb.MongoConnection, _Options.RabbitMQ); AddOdinCapInject - 方法 1234567891011121314151617181920212223242526272829public static IServiceCollection AddOdinCapInject(this IServiceCollection services, string mysqlConnectionString, string mongoConnectionString, RabbitMQOptions rabbitMQOptions)&#123; services.AddCap(x =&gt; &#123; //如果你使用的ADO.NET，根据数据库选择进行配置： // x.UseSqlServer(&quot;数据库连接字符串&quot;); x.UseMySql(mysqlConnectionString); // x.UsePostgreSql(&quot;数据库连接字符串&quot;); //如果你使用的 MongoDB，你可以添加如下配置： // x.UseMongoDB(mongoConnectionString); //注意，仅支持MongoDB 4.0+集群 //CAP支持 RabbitMQ、Kafka、AzureServiceBus 等作为MQ，根据使用选择配置： x.UseRabbitMQ(rb =&gt; &#123; rb.HostName = rabbitMQOptions.HostNames[0]; rb.UserName = rabbitMQOptions.Account.UserName; rb.Password = rabbitMQOptions.Account.Password; rb.VirtualHost = rabbitMQOptions.VirtualHost; rb.Port = rabbitMQOptions.Port; &#125;); // x.UseKafka(&quot;ConnectionStrings&quot;); // x.UseAzureServiceBus(&quot;ConnectionStrings&quot;); x.UseDashboard(); &#125;); return services;&#125; OdinCapHelper.cs - 封装，注入到service中即可使用 12345678910111213141516171819202122public class OdinCapHelper : IOdinCapHelper&#123; public void CapPublish&lt;T&gt;(string publishName, T contentObj, Action action = null) &#123; var db = DbScoped.Sugar; var capBus = OdinInjectHelper.GetService&lt;ICapPublisher&gt;(); using (var connection = (MySqlConnection)db.Ado.Connection) &#123; using (var transaction = connection.BeginTransaction(capBus, autoCommit: false)) &#123; if (connection.State != ConnectionState.Open) &#123; connection.Open(); &#125; db.Ado.Transaction = (IDbTransaction)transaction.DbTransaction;//这行很重要 if (action != null) action(); capBus.Publish&lt;T&gt;(publishName, contentObj); transaction.Commit(); &#125; &#125; &#125;&#125; 这里需要注意的是，如果和我一样是使用mysql数据库，那么需要讲nuget包由 SqlSugarCore 替换为 SqlSugarCore.MySqlConnector 切记！！！ 切记！！！ ** Controller ** - Action方法中发布消息 12345var db = DbScoped.Sugar;OdinCapHelper.CapPublish(&quot;Sample.RabbitMQ.MySql&quot;, DateTime.Now, () =&gt; &#123; System.Console.WriteLine(&quot;to do something&quot;); &#125;); Controller - Action方法中订阅消费消息 123456[CapSubscribe(&quot;Sample.RabbitMQ.MySql&quot;)]public async Task&lt;Task&gt; CheckReceivedMessage(DateTime time)&#123; Console.WriteLine(time); return Task.CompletedTask;&#125; 完整代码可以在 GitHub中找到。","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":"SqlSugar","slug":"SqlSugar","permalink":"https://www.odinsam.com/tags/SqlSugar/"},{"name":"Cap","slug":"Cap","permalink":"https://www.odinsam.com/tags/Cap/"}],"author":"OdinSam"},{"title":"使用 BackgroundService 类在微服务中实现后台任务","slug":"使用-BackgroundService-类在微服务中实现后台任务","date":"2021-06-14T09:34:00.000Z","updated":"2021-06-14T10:18:51.000Z","comments":true,"path":"/articles/2893.html","link":"","permalink":"https://www.odinsam.com/articles/2893.html","excerpt":"任何应用程序中都可能需要使用后台任务和计划作业，无论应用程序是否遵循微服务体系结构模式均是如此。 使用微服务体系结构的区别在于，你可以在一个单独的用于托管的进程/容器中实现后台任务。一般在 .NET 中，我们将这些类型的任务称为托管服务，因为它们是托管在主机/应用程序/微服务中的服务/逻辑。 请注意，在这种情况下，托管服务仅表示具有后台任务逻辑的类。","text":"任何应用程序中都可能需要使用后台任务和计划作业，无论应用程序是否遵循微服务体系结构模式均是如此。 使用微服务体系结构的区别在于，你可以在一个单独的用于托管的进程/容器中实现后台任务。一般在 .NET 中，我们将这些类型的任务称为托管服务，因为它们是托管在主机/应用程序/微服务中的服务/逻辑。 请注意，在这种情况下，托管服务仅表示具有后台任务逻辑的类。 1. IHostedService介绍 自 .NET Core 2.0 开始，该框架提供名为 IHostedService 的新接口，有助于轻松实现托管服务。 基本理念是，可以注册多个后台任务（托管服务），在 Web 主机或主机运行时在后台运行具体介绍如下图： 但是，由于大多数后台任务在取消令牌管理和其他典型操作方面都有类似的需求，因此有一个非常方便且可以从中进行派生的抽象基类，名为 BackgroundService（自 .NET Core 2.1 起提供），该类提供设置后台任务所需的主要工作。从抽象基类派生时，只需在自定义的托管服务类中实现 ExecuteAsync() 方法，结合 利用Canal集合RabbitMQ实现数据和缓存同步 这篇文章，就可以搭建Canal + RabbitMQ + CacheManager 的基本架构，从而实现由 Canal 监控和发现 mysql 数据库的增量信息并推送到 RabbitMQ ，而我们使用BackgroundSerivce 搭建的后台托管服务消费 RabbitMQ 信息修改 Redis 中的缓存数据，而 CacheManager 设定 Redis 缓存为缓存挡板，故而内存中的二级缓存也会得到对应修改。 2. 具体实现 这里是以 ErrorCode 错误码为例，实现一系列操作。首先是 实现 BackgroundService 的子类 OdinBackgroundService ： 12345678910111213141516171819202122232425262728293031323334353637383940public class OdinBackgroundService : BackgroundService&#123; private readonly ProjectExtendsOptions apiOptions; private readonly ReceiveRabbitMQHelper receiveRabbitMQHelper; private int executionCount = 0; private Timer _timer; public OdinBackgroundService() &#123; this.apiOptions = OdinInjectHelper.GetService&lt;IOptionsSnapshot&lt;ProjectExtendsOptions&gt;&gt;().Value; this.receiveRabbitMQHelper = new ReceiveRabbitMQHelper(); &#125; private void DoWork(object state) &#123; receiveRabbitMQHelper.ReceiveMQ(apiOptions); &#125; public override Task StartAsync(CancellationToken cancellationToken) &#123; return ExecuteAsync(cancellationToken); &#125; protected override Task ExecuteAsync(CancellationToken stoppingToken) &#123; Log.Information($&quot;Service:【 Run 】\\tTime:【&#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;); _timer = new Timer(DoWork, null, TimeSpan.Zero, TimeSpan.FromMilliseconds(300)); return Task.CompletedTask; &#125; public override Task StopAsync(CancellationToken cancellationToken) &#123; Log.Information($&quot;Service:【 Stop 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;); _timer?.Change(Timeout.Infinite, 0); return base.StopAsync(cancellationToken); &#125; public override void Dispose() &#123; _timer?.Dispose(); &#125;&#125; 这里采用轮询机制，每300ms消费一次 RabbitMQ 的信息，具体的消费代码 ReceiveRabbitMQHelper 如下: 1234567891011121314151617181920212223242526272829303132333435363738public class ReceiveRabbitMQHelper&#123; private readonly IRabbitMQReceiveServer rabbitMQReceiveServer; private readonly IOdinCanalHelper canalHelper; private readonly IOdinCacheManager cacheManager; public ReceiveRabbitMQHelper() &#123; this.rabbitMQReceiveServer = OdinInjectHelper.GetService&lt;IRabbitMQReceiveServer&gt;(); this.canalHelper = OdinInjectHelper.GetService&lt;IOdinCanalHelper&gt;(); this.cacheManager = OdinInjectHelper.GetService&lt;IOdinCacheManager&gt;(); &#125; public void ReceiveMQ(ProjectExtendsOptions apiOptions) &#123; rabbitMQReceiveServer.ReceiveJsonMessage( apiOptions.RabbitMQ, new RabbitMQReceivedModel &#123; ExchangeName = &quot;canal-exchange&quot;, QueueName = &quot;canal-queues&quot;, AutoAck = false &#125;, (BasicGetResult result, IModel channel) =&gt; &#123; var msg = RabbitMQReceiveHandler.ReceiveJsonMessageHandler(result, channel); if (!string.IsNullOrEmpty(msg)) &#123; System.Console.WriteLine($&quot;Canal-WorkService:【 Run 】\\tTime:【 &#123;DateTime.Now.ToString(&quot;yyyy-dd-MM hh:mm:ss&quot;)&#125; 】&quot;); System.Console.WriteLine(msg); // 这里用来处理获取到的 RabbitMQ 的增量信息 ErrorCodeHelper.ErrorCodeCanalHandler(canalHelper, cacheManager, msg); System.Console.WriteLine(&quot;\\r\\n&quot;); &#125; &#125; ); &#125;&#125; ErrorCodeCanalHandler用来处理获取到的 RabbitMQ 的增量信息，具体封装如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ErrorCodeHelper&#123; public static void ErrorCodeCanalHandler(IOdinCanalHelper canalHelper, IOdinCacheManager cacheManager, string canalString) &#123; var obj = canalHelper.GetCanalInfo(canalString); var type = obj.type; switch (type.ToLower()) &#123; case &quot;insert&quot;: &#123; var model = ConvertCanalDataToErrorCodeModel(obj); var flag = cacheManager.Add(model.ErrorCode, model); if (flag) System.Console.WriteLine(&quot;cacheManager add success&quot;); else System.Console.WriteLine(&quot;cacheManager add fail&quot;); &#125; break; case &quot;update&quot;: &#123; var model = ConvertCanalDataToErrorCodeModel(obj); cacheManager.Cover&lt;ErrorCode_Model&gt;(model.ErrorCode, model); System.Console.WriteLine(&quot;cacheManager Cover success&quot;); &#125; break; case &quot;delete&quot;: &#123; var errorCode = GetErrorCode(obj); bool flag = cacheManager.Delete(errorCode); if (flag) System.Console.WriteLine(&quot;cacheManager delete success&quot;); else System.Console.WriteLine(&quot;cacheManager delete fail&quot;); &#125; break; default: break; &#125; &#125; private static string GetErrorCode(OdinCanalModel obj) &#123; var errorCode = obj.data[0].GetValue(&quot;ErrorCode&quot;).ToString(); return errorCode; &#125; private static ErrorCode_Model ConvertCanalDataToErrorCodeModel(OdinCanalModel obj) &#123; var errorCode = obj.data[0].GetValue(&quot;ErrorCode&quot;).ToString(); var codeShowMessage = obj.data[0].GetValue(&quot;CodeShowMessage&quot;).ToString(); var codeErrorMessage = obj.data[0].GetValue(&quot;CodeErrorMessage&quot;).ToString(); ErrorCode_Model model = new ErrorCode_Model() &#123; ErrorCode = errorCode, ErrorMessage = codeErrorMessage, ShowMessage = codeErrorMessage, &#125;; return model; &#125;&#125; 这样基本的搭建就完成了，完整代码可以在 GitHub 。","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"微服务","slug":"微服务","permalink":"https://www.odinsam.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"BackgroundService","slug":"BackgroundService","permalink":"https://www.odinsam.com/tags/BackgroundService/"}],"author":"OdinSam"},{"title":"基于HttpClientFactory的封装和使用","slug":"基于HttpClientFactory的封装和使用","date":"2021-06-10T22:08:00.000Z","updated":"2021-06-10T22:49:13.000Z","comments":true,"path":"/articles/4ff6.html","link":"","permalink":"https://www.odinsam.com/articles/4ff6.html","excerpt":".Net Core2.0 版本以前 HttpClient 还是挺坑的，我们需要操心怎么建立如何释放，而且代码质量不好还会影响 HttpClient 的性能和访问速度。2.0版本以后 HttpClientFactory 的出现解决了我们所有的痛点，我们不须要关心如何建立 HttpClient 又如何释放它。经过它能够建立具备特定业务的HttpClient，并且能够很友好的和 DI 容器结合使用。","text":".Net Core2.0 版本以前 HttpClient 还是挺坑的，我们需要操心怎么建立如何释放，而且代码质量不好还会影响 HttpClient 的性能和访问速度。2.0版本以后 HttpClientFactory 的出现解决了我们所有的痛点，我们不须要关心如何建立 HttpClient 又如何释放它。经过它能够建立具备特定业务的HttpClient，并且能够很友好的和 DI 容器结合使用。 1. 首先在 Startup.cs 文件的 ConfigureServices 方法中注入 HttpClient 123456789101112131415161718192021222324var handler = new HttpClientHandler();foreach (var cerItem in _Options.SslCers)&#123; if (!string.IsNullOrEmpty(cerItem.CerPath)) &#123; var clientCertificate = new X509Certificate2(cerItem.CerPath, cerItem.CerPassword); handler.ClientCertificates.Add(clientCertificate); &#125;&#125;var handlerWithCer = new HttpClientHandler();foreach (var cerItem in _Options.SslCers)&#123; if (!string.IsNullOrEmpty(cerItem.CerPath)) &#123; var clientCertificate = new X509Certificate2(cerItem.CerPath, cerItem.CerPassword); handlerWithCer.ClientCertificates.Add(clientCertificate); &#125;&#125;services.AddHttpClient(&quot;OdinClient&quot;, c =&gt;&#123;&#125;).ConfigurePrimaryHttpMessageHandler(() =&gt; handler);services.AddHttpClient(&quot;OdinClientCer&quot;, c =&gt;&#123;&#125;).ConfigurePrimaryHttpMessageHandler(() =&gt; handlerWithCer); 这里我注入了两个 HttpClient，一个是没有证书的，一个是有证书的。如何在 Post 和 Get 的时候动态传递证书，有知道的小伙伴可以留言告诉我一下（我没找到这个解决的办法）。 2. 接下来可以在拦截器里开启 Request.Body 重复读取。 1context.HttpContext.Request.EnableBuffering(); 3. 封装获取Request.Body的方法 12345678910public static class HttpRequestExtends&#123; public static string ReadRequestBody(this HttpRequest request) &#123; var reader = new StreamReader(request.Body); var data = reader.ReadToEndAsync(); request.Body.Seek(0, SeekOrigin.Begin); return data.Result; &#125;&#125; 4. 封装HttpClient方法(这里只是封装了 Get 和 Post 作为演示) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168public class OdinHttpClientFactory : IOdinHttpClientFactory&#123; public static async Task&lt;T&gt; GetRequestAsync&lt;T&gt;(string clientName, string uri, Dictionary&lt;string, string&gt; customHeaders = null, string mediaType = &quot;application/json&quot;) &#123; var clientFactory = OdinInjectHelper.GetService&lt;IHttpClientFactory&gt;(); var client = clientFactory.CreateClient(clientName); var request = new HttpRequestMessage() &#123; RequestUri = new Uri(uri), Method = HttpMethod.Get, &#125;; RequestHeaderAdd(request, customHeaders); request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(mediaType)); return await GetResponseResult&lt;T&gt;(client, request); &#125; public static async Task&lt;T&gt; PostRequestAsync&lt;T&gt;(string clientName, string uri, Object obj, Dictionary&lt;string, string&gt; customHeaders = null, string mediaType = &quot;application/json&quot;, Encoding encoder = null) &#123; var clientFactory = OdinInjectHelper.GetService&lt;IHttpClientFactory&gt;(); var client = clientFactory.CreateClient(clientName); var request = new HttpRequestMessage() &#123; RequestUri = new Uri(uri), Method = HttpMethod.Post, &#125;; RequestHeaderAdd(request, customHeaders); request.Content = GenerateContent(obj, mediaType, encoder); return await GetResponseResult&lt;T&gt;(client, request); &#125; private static HttpContent GenerateContent(Object obj, string mediaType, Encoding encoder) &#123; if (typeof(String) == obj.GetType()) &#123; return GenerateContent&lt;String&gt;(obj.ToString(), mediaType, encoder); &#125; else &#123; return GenerateContent&lt;Object&gt;(obj, mediaType, encoder); &#125; &#125; private static HttpContent GenerateContent&lt;T&gt;(T obj, string mediaType, Encoding encoder) &#123; StringBuilder jsonContent = new StringBuilder(); string sendContent = string.Empty; Dictionary&lt;string, string&gt; dic = ConvertPostDataToDictionary&lt;T&gt;(obj, encoder); if (mediaType == &quot;application/json&quot;) &#123; sendContent = JsonConvert.SerializeObject(dic); &#125; else &#123; sendContent = ConvertDictionaryToPostFormData(dic).ToString(); &#125; return new StringContent( sendContent, encoder == null ? Encoding.UTF8 : encoder, mediaType); &#125; private async static Task&lt;T&gt; PostResponseResult&lt;T&gt;(HttpClient client, HttpRequestMessage request) &#123; var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) &#123; return GetResult&lt;T&gt;(response); &#125; else throw new Exception(&quot;请求出错&quot;); &#125; private async static Task&lt;T&gt; GetResponseResult&lt;T&gt;(HttpClient client, HttpRequestMessage request) &#123; var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) &#123; return GetResult&lt;T&gt;(response); &#125; else throw new Exception(&quot;请求出错&quot;); &#125; private static void RequestHeaderAdd(HttpRequestMessage request, Dictionary&lt;string, string&gt; customHeaders) &#123; if (customHeaders != null) &#123; foreach (KeyValuePair&lt;string, string&gt; customHeader in customHeaders) &#123; request.Headers.Add(customHeader.Key, customHeader.Value); &#125; &#125; &#125; private static T GetResult&lt;T&gt;(HttpResponseMessage httpResponseMessage) &#123; // 确认响应成功，否则抛出异常 // result.EnsureSuccessStatusCode(); if (typeof(T) == typeof(byte[])) &#123; return (T)Convert.ChangeType(httpResponseMessage.Content.ReadAsByteArrayAsync(), typeof(T)); &#125; else if (typeof(T) == typeof(Stream)) &#123; return (T)Convert.ChangeType(httpResponseMessage.Content.ReadAsStreamAsync().Result, typeof(T)); &#125; else &#123; if (typeof(T) == typeof(string)) return (T)Convert.ChangeType(httpResponseMessage.Content.ReadAsStringAsync().Result, typeof(T)); return JsonConvert.DeserializeObject&lt;T&gt;(httpResponseMessage.Content.ReadAsStringAsync().Result); &#125; &#125; public static Dictionary&lt;string, string&gt; ConvertPostDataToDictionary&lt;T&gt;(T obj, Encoding encoder = null) &#123; Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;(); if (typeof(T) == typeof(String)) &#123; foreach (var item in obj.ToString().Split(&#x27;&amp;&#x27;)) &#123; dic.Add( item.Split(&#x27;=&#x27;)[0], encoder == null || encoder == Encoding.UTF8 ? item.Split(&#x27;=&#x27;)[1] : item.Split(&#x27;=&#x27;)[1].ConvertStringEncode(Encoding.UTF8, encoder) ); &#125; &#125; else &#123; foreach (var item in obj.GetType().GetRuntimeProperties()) &#123; dic.Add(item.Name, encoder == null || encoder == Encoding.UTF8 ? item.GetValue(obj).ToString() : item.GetValue(obj).ToString().ConvertStringEncode(Encoding.UTF8, encoder) ); &#125; &#125; return dic; &#125; private static StringBuilder ConvertDictionaryToPostFormData(Dictionary&lt;string, string&gt; dic) &#123; StringBuilder builder = new StringBuilder(); if (dic != null) &#123; bool hasParam = false; foreach (KeyValuePair&lt;string, string&gt; kv in dic) &#123; string name = kv.Key; string value = kv.Value; // 忽略参数名或参数值为空的参数 if (!string.IsNullOrEmpty(name) &amp;&amp; !string.IsNullOrEmpty(value)) &#123; if (hasParam) &#123; builder.Append(&quot;&amp;&quot;); &#125; builder.Append(name); builder.Append(&quot;=&quot;); builder.Append(value); hasParam = true; &#125; &#125; &#125; return builder; &#125;&#125; 5. 最后封装获取Request.Body内容后二次封装的方法，因为我会遇到 一个 Post 请求但是 Url 还带有参数的情况，所以这里封装的稍微复杂一些 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static RequestParamsModel GetRequestParams(this Controller controller, string paramFormat = null)&#123; HttpContext context = controller.HttpContext; var request = context.Request; JObject jobj = new JObject(); RequestParamsModel requestParams = new RequestParamsModel(); if (!string.IsNullOrEmpty(context.Request.QueryString.ToString())) &#123; string param = request.QueryString.ToString().Substring(1); requestParams.RequestQueryString = JsonConvert.DeserializeObject&lt;JObject&gt;(JsonConvert.SerializeObject(OdinHttpClientFactory.ConvertPostDataToDictionary&lt;string&gt;(param))); &#125; if (request.ContentType != null &amp;&amp; request.ContentType.StartsWith(&quot;application/json&quot;)) &#123; string param = request.ReadRequestBody(); requestParams.RequestFormData = JsonConvert.DeserializeObject&lt;JObject&gt;(param); &#125; if (request.ContentType != null &amp;&amp; (request.ContentType.StartsWith(&quot;text/plain&quot;) || request.ContentType.StartsWith(&quot;application/javascript&quot;) || request.ContentType.StartsWith(&quot;text/html&quot;) || request.ContentType.StartsWith(&quot;application/xml&quot;))) &#123; string param = request.ReadRequestBody(); requestParams.RequestFormDataString = param.Replace(&quot;\\r&quot;, &quot;&quot;).Replace(&quot;\\n&quot;, &quot;&quot;).Replace(&quot; &quot;, &quot;&quot;); &#125; if (request.ContentType != null &amp;&amp; request.ContentType.StartsWith(&quot;application/x-www-form-urlencoded&quot;)) &#123; string param = request.ReadRequestBody(); requestParams.RequestFormData = JsonConvert.DeserializeObject&lt;JObject&gt;(JsonConvert.SerializeObject(OdinHttpClientFactory.ConvertPostDataToDictionary&lt;string&gt;(param))); &#125; if (request.ContentType != null &amp;&amp; request.ContentType.StartsWith(&quot;multipart/form-data&quot;)) &#123; Dictionary&lt;string, string&gt; dic = new Dictionary&lt;string, string&gt;(); foreach (var kv in request.Form) &#123; dic.Add(kv.Key, kv.Value); &#125; requestParams.RequestFormData = JsonConvert.DeserializeObject&lt;JObject&gt;(JsonConvert.SerializeObject(dic)); List&lt;Dictionary&lt;string, MemoryStream&gt;&gt; files = new List&lt;Dictionary&lt;string, MemoryStream&gt;&gt;(); long filesize = 0; foreach (var file in request.Form.Files) &#123; filesize += file.Length; if (filesize &gt; 1024 * 1024 * 4) throw new Exception(&quot;文件过大无法上传，请联系管理员申请使用大文件上传服务器&quot;); var fileBytes = new Byte[file.Length]; MemoryStream fileStream = new MemoryStream(fileBytes); file.CopyTo(fileStream); files.Add(new Dictionary&lt;string, MemoryStream&gt;() &#123; &#123; file.Name, fileStream &#125; &#125;); &#125; requestParams.RequestUploadFile = files; &#125; return requestParams;&#125; 其中文件上传大小可以通过配置文件限制，现在及时我们遇到有Get请求，但是带着FormData文件的情况，我们也可以正常获取所有信息，其中信息内容格式如下： 1234567891011121314151617181920212223public class RequestParamsModel&#123; /// &lt;summary&gt; /// Url 地址栏参数信息 自动转化为 JObject /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public JObject RequestQueryString &#123; get; set; &#125; /// &lt;summary&gt; /// 当 请求内容包含 application/text application/xml text/plain 和 application/javascript 是，获取内容一律视为 string，后期再自行处理 /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public String RequestFormDataString &#123; get; set; &#125; /// &lt;summary&gt; /// FormData 请求时所有的键值对，自动转化为 JObject /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public JObject RequestFormData &#123; get; set; &#125; /// &lt;summary&gt; /// FormData 请求时附带的文件，key为文件名 value为文件的stream格式 /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public List&lt;Dictionary&lt;string, MemoryStream&gt;&gt; RequestUploadFile &#123; get; set; &#125;&#125; 6. 其中，这个封装并没有处理Body包含 binary 格式和 GraphQL 格式，如有需要可以自行扩展。此时，当我们遇到 123var obj = OdinHttpClientFactory.PostRequestAsync&lt;OdinActionResult&gt;(&quot;OdinClient&quot;, &quot;http://127.0.0.1:20303/api/v1/LinkTrack/pfda?id=4&amp;name=admin&quot;, new &#123; User = &quot;odinsam&quot; &#125;); 这样的请求时，我们就会得到如下内容:(OdinActionResult是我自己定义的一个统一返回格式而已) 123456RequestQueryString - null&#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;admin&quot;&#125;RequestFormDataString - nullRequestFormData&#123;&quot;User&quot;:&quot;odinsam&quot;&#125;RequestUploadFile - null","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"HttpClientFactory","slug":"HttpClientFactory","permalink":"https://www.odinsam.com/tags/HttpClientFactory/"}],"author":"OdinSam"},{"title":"Hexo Pure主题给Post页面添加keywords","slug":"Hexo-Pure主题给Post页面添加keywords","date":"2021-06-09T00:51:00.000Z","updated":"2021-06-10T10:15:38.000Z","comments":true,"path":"/articles/409f.html","link":"","permalink":"https://www.odinsam.com/articles/409f.html","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。https://hexo.io/zh-cn/ 这里是他的中文文档，无论是结合 Github、Gitee 或者是在私人的云端都可以快速部署，非常高效快捷。为了更好的seo优化，使用pure主题给每一个post页面添加keywords 关键字。","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。https://hexo.io/zh-cn/ 这里是他的中文文档，无论是结合 Github、Gitee 或者是在私人的云端都可以快速部署，非常高效快捷。为了更好的seo优化，使用pure主题给每一个post页面添加keywords 关键字。 找到主题 pure/layout/_common/head.ejs 文件，在 title 标签后添加以下代码: 123456&lt;% if (post.tags &amp;&amp; post.tags.length) &#123; %&gt; &lt;% var kw = &quot;&quot;;post.tags.forEach(t=&gt;&#123; kw+=t.name+&#x27;,&#x27; &#125;);kw = kw.substr(0,kw.length-1) %&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= kw %&gt;&quot; /&gt; &lt;% &#125; else if (config.keywords)&#123; %&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= config.keywords %&gt;&quot; /&gt;&lt;%&#125; %&gt; 这样每一个页面都可以依据发布时的tag生成keywords标签 1&lt;meta name=&quot;keywords&quot; content=&quot;Hexo,Seo,Pure&quot;&gt; 如果发布时没有tag，那么会依据hexo的配置文件(注意不是pure的配置文件) _config.yml 中的 keywords 生成对应的 meta 标签 1&lt;meta name=&quot;keywords&quot; content=&quot;.Net Core,javascript,typescript,html5,css,css3,linux,react,vue,js&quot;&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.odinsam.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.odinsam.com/tags/Hexo/"},{"name":"Seo","slug":"Seo","permalink":"https://www.odinsam.com/tags/Seo/"},{"name":"Pure","slug":"Pure","permalink":"https://www.odinsam.com/tags/Pure/"}],"author":"OdinSam"},{"title":"利用Canal集合RabbitMQ实现数据和缓存同步","slug":"利用Canal集合RabbitMQ实现数据和缓存同步","date":"2021-06-08T21:34:00.000Z","updated":"2021-07-06T15:04:30.000Z","comments":true,"path":"/articles/a3b9.html","link":"","permalink":"https://www.odinsam.com/articles/a3b9.html","excerpt":"Canal的主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。他可以模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议。MySQL master收到dump请求，开始推送 binary log 给 slave (即canal)，canal解析binary log 对象(原始为 byte 流)。","text":"Canal的主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。他可以模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议。MySQL master收到dump请求，开始推送 binary log 给 slave (即canal)，canal解析binary log 对象(原始为 byte 流)。 Canal介绍 Canal 的 Github：https://github.com/alibaba/canal 里边有详细介绍说明以及安装方法。具体不在叙述。 MySql改动 首先需要给mysql创建对应的canal用户 123CREATE USER canal IDENTIFIED BY &#x27;canal&#x27;;GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27;;FLUSH PRIVILEGES; 其次修改 my.cnf 文件并 重启数据库 1234[mysqld]log-bin=mysql-bin # 开启 binlogbinlog-format=ROW # 选择 ROW 模式server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 Canal配置 Canal单机环境(开发代码测试)主要配置两个文件，分别是 conf/canal.properties 文件和 conf/example/instance.properties 文件。具体配置如下: canal.properties 12345678910111213######################################################################################################### 这部分结构是配置文件自带的 只需要写清楚即可，其中 exchange 为 rabbitMQ的exchange的名字####### username 和 password 是 rabbitMQ 的 用户名和密码 (我自己新建了一个rabbitMQ用户)################################################################################################## ######### RabbitMQ ###############################################################rabbitmq.host = 127.0.0.1rabbitmq.virtual.host = /rabbitmq.exchange = canal-exchangerabbitmq.username = canalConsumerrabbitmq.password = canalConsumerrabbitmq.deliveryMode = 最为主要的是要找到配置文件中 canal.serverMode = rabbitMQ 他的默认值是 tcp 切记要改为 rabbitMQ instance.properties 1234567891011121314canal.instance.master.address=127.0.0.1:3306 #数据库的 ip:port canal.instance.dbUsername=canal #数据库的 用户名canal.instance.dbPassword=173Canal~ #数据库的 密码 canal.instance.tsdb.dir=$&#123;canal.file.data.dir:../conf&#125;/$&#123;canal.instance.destination:&#125;canal.instance.tsdb.url=jdbc:h2:$&#123;canal.instance.tsdb.dir&#125;/h2;CACHE_SIZE=1000;MODE=MYSQL;#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb # canal.instance.filter.regex=.*\\\\..* # https://github.com/alibaba/canal/wiki/AdminGuide 搜索 canal.instance.filter.regex 有详细说明canal.instance.filter.regex=db_OdinOIS.Logs # 要监控的库和表 https://github.com/alibaba/canal/wiki/AdminGuide 搜索 canal.instance.filter.regex 有详细说明 canal.mq.topic=canal-routingkey # rabbitMQ 创建 queues 时的 routing key 的值 数据解析 至此如果以上步骤都没有问题的话，执行 ./bin/startup.sh 启动，并在你监控的表中设置增量数据，rabbitMQ 就会有对应数据。获取到的数据为json格式，具体说明如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; // data内为获取到的增量数据 key是数据库对应的字段 value是数据库的值 &quot;data&quot;: [&#123; &quot;id&quot;: &quot;1487&quot;, &quot;Timestamp&quot;: &quot;2021-06-09 05:23:12.538+08:00&quot;, &quot;Level&quot;: &quot;Information&quot;, &quot;Message&quot;: &quot;Entity Framework Core&quot;, &quot;Exception&quot;: null, &quot;Properties&quot;: &quot;&quot;, &quot;_ts&quot;: null &#125;], // 库名 &quot;database&quot;: &quot;db_OdinOIS&quot;, &quot;es&quot;: 1623187400000, &quot;id&quot;: 1, &quot;isDdl&quot;: false, // 字段对应mysql的数据类型 &quot;mysqlType&quot;: &#123; &quot;id&quot;: &quot;int&quot;, &quot;Timestamp&quot;: &quot;varchar(100)&quot;, &quot;Level&quot;: &quot;varchar(15)&quot;, &quot;Message&quot;: &quot;text&quot;, &quot;Exception&quot;: &quot;text&quot;, &quot;Properties&quot;: &quot;text&quot;, &quot;_ts&quot;: &quot;timestamp&quot; &#125;, // 如果是 update 操作这里会是更新前的数据 &quot;old&quot;: null, // 主键 &quot;pkNames&quot;: [&quot;id&quot;], &quot;sql&quot;: &quot;&quot;, &quot;sqlType&quot;: &#123; &quot;id&quot;: 4, &quot;Timestamp&quot;: 12, &quot;Level&quot;: 12, &quot;Message&quot;: 2005, &quot;Exception&quot;: -4, &quot;Properties&quot;: 2005, &quot;_ts&quot;: 93 &#125;, // 表名字 &quot;table&quot;: &quot;Logs&quot;, // 时间戳 &quot;ts&quot;: 1623187530269, // 操作类型 &quot;type&quot;: &quot;INSERT&quot;&#125; 这样我们就可以利用代码从 rabbitMQ 中消费对应的信息，然后再做其他操作。当然也可以利用 Canal 结合 redis 实现 mysql 和缓存数据同步，在利用CacheManager类库，利用redis做挡板，就可以同时实现 redis 缓存和内存缓存同步。这样整个分布式项目就可以实现读写分离、缓存同步。","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.odinsam.com/tags/Mysql/"},{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"Canal","slug":"Canal","permalink":"https://www.odinsam.com/tags/Canal/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://www.odinsam.com/tags/RabbitMQ/"}],"author":"OdinSam"},{"title":"Serilog封装扩展并写入Mysql","slug":"Serilog封装扩展并写入Mysql","date":"2021-06-06T20:45:00.000Z","updated":"2021-06-09T05:36:20.000Z","comments":true,"path":"/articles/b919.html","link":"","permalink":"https://www.odinsam.com/articles/b919.html","excerpt":"Serilog是 .NET 中最著名的结构化日志类库。大多数情况下，中小型项目会将日志直接记录在一个对应的文件夹中比如Logs文件夹，并且可以按照日志的等级创建子文件夹比如errror、debug等等，再按照日期创建子文件最后按照日志文件大小上限做日志文件的划分。在一些大型项目中需要将日志写入数据库，文章讲述如何使用Serilog日志类库在mysql数据库中自动创建logs表并将日志写入表中。","text":"Serilog是 .NET 中最著名的结构化日志类库。大多数情况下，中小型项目会将日志直接记录在一个对应的文件夹中比如Logs文件夹，并且可以按照日志的等级创建子文件夹比如errror、debug等等，再按照日期创建子文件最后按照日志文件大小上限做日志文件的划分。在一些大型项目中需要将日志写入数据库，文章讲述如何使用Serilog日志类库在mysql数据库中自动创建logs表并将日志写入表中。 封装模型： LogWriteFileModel.cs 123456789public class LogWriteFileModel&#123; public string FileName &#123; get; set; &#125; public int FileSizeLimitBytes &#123; get; set; &#125; = 1000000; public bool RollOnFileSizeLimit &#123; get; set; &#125; = true; public bool Shared &#123; get; set; &#125; = true; public TimeSpan FlushToDiskInterval &#123; get; set; &#125; = TimeSpan.FromSeconds(1);&#125; LogWriteToConsoleModel.cs 12345public class LogWriteToConsoleModel&#123; public string OutputTemplate &#123; get; set; &#125; public SystemConsoleTheme ConsoleTheme &#123; get; set; &#125; = SystemConsoleTheme.Colored;&#125; LogWriteMySqlModel.cs 1234public class LogWriteMySqlModel&#123; public string ConnectionString &#123; get; set; &#125;&#125; 扩展类 安装package Serilog.Sinks.MySQL, Version=4.0.0.0，LoggerConfigurationExtends.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243public static class LoggerConfigurationExtends &#123; public static LoggerConfiguration OdinWriteLog(this LoggerConfiguration loggerConfiguration, LogWriteFileModel logWriteFileModel, LogWriteToConsoleModel logWriteToConsole, LogWriteMySqlModel logWriteMySqlModel) &#123; return loggerConfiguration .WriteTo.OdinWrite( LogEventLevel.Debug, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ) .WriteTo.OdinWrite( LogEventLevel.Error, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ) .WriteTo.OdinWrite( LogEventLevel.Fatal, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ) .WriteTo.OdinWrite( LogEventLevel.Information, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ) .WriteTo.OdinWrite( LogEventLevel.Warning, logWriteFileModel, logWriteToConsole, logWriteMySqlModel ); &#125; public static LoggerConfiguration OdinWrite(this LoggerSinkConfiguration loggerSinkConfiguration, LogEventLevel logLevel, LogWriteFileModel logWriteFileModel, LogWriteToConsoleModel logWriteToConsole, LogWriteMySqlModel logWriteMySqlModel) &#123; return loggerSinkConfiguration.Logger(fileLogger =&gt; &#123; var config = SerilogHelper.OdinWriteToFile(fileLogger, logLevel, logWriteFileModel); if (logWriteToConsole != null) &#123; config.WriteTo.Console( outputTemplate: string.IsNullOrEmpty(logWriteToConsole.OutputTemplate) ? &quot;&#123;Timestamp:yyyy-MM-dd HH:mm:ss&#125; [&#123;Level&#125;] &#123;Message&#125;&#123;NewLine&#125;&#123;Exception&#125;&quot; : logWriteToConsole.OutputTemplate, theme: logWriteToConsole.ConsoleTheme ); &#125; if (logWriteMySqlModel != null) config.WriteTo.MySQL(connectionString: logWriteMySqlModel.ConnectionString); &#125;); &#125; &#125; 封装类: SerilogHelper.cs 1234567891011121314151617181920public class SerilogHelper&#123; public static LoggerConfiguration OdinWriteToFile(LoggerConfiguration fileLogger, LogEventLevel logLevel, LogWriteFileModel logWriteModel) &#123; return fileLogger.Filter .ByIncludingOnly(p =&gt; p.Level.Equals(logLevel)) .WriteTo.File( path: string.IsNullOrEmpty(logWriteModel.FileName) ? $&quot;logs/&#123;DateTime.Now.ToString(&quot;yyyyMMdd&quot;)&#125;/log-&#123;DateTime.Now.ToString(&quot;yyyyMMdd&quot;)&#125;-&#123;logLevel.ToString()&#125;.txt&quot; : logWriteModel.FileName, fileSizeLimitBytes: logWriteModel.FileSizeLimitBytes, rollOnFileSizeLimit: logWriteModel.RollOnFileSizeLimit, shared: logWriteModel.Shared, flushToDiskInterval: logWriteModel.FlushToDiskInterval ); &#125;&#125; 使用 1234567891011121314#region Log设置Log.Logger = new LoggerConfiguration() // 最小的日志输出级别 .MinimumLevel.Information() //.MinimumLevel.Information () // 日志调用类命名空间如果以 System 开头，覆盖日志输出最小级别为 Information .MinimumLevel.Override(&quot;System&quot;, LogEventLevel.Information) // 日志调用类命名空间如果以 Microsoft 开头，覆盖日志输出最小级别为 Information .MinimumLevel.Override(&quot;Microsoft&quot;, LogEventLevel.Information) .OdinWriteLog( new LogWriteFileModel &#123; &#125;, new LogWriteToConsoleModel &#123; &#125;, new LogWriteMySqlModel &#123; ConnectionString = Configuration.GetSection(&quot;ProjectConfigOptions:DbEntity:ConnectionString&quot;).Value &#125; ) .CreateLogger();#endregion","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"Serilog","slug":"Serilog","permalink":"https://www.odinsam.com/tags/Serilog/"},{"name":"Log","slug":"Log","permalink":"https://www.odinsam.com/tags/Log/"}],"author":"odinsam"},{"title":"vscode控制台中文乱码","slug":"vscode控制台中文乱码","date":"2021-06-06T03:27:00.000Z","updated":"2021-07-06T15:01:34.000Z","comments":true,"path":"/articles/cda.html","link":"","permalink":"https://www.odinsam.com/articles/cda.html","excerpt":"vscode是现在较为流行的一款开发工具，他可以按照用户对应需要的语言插件进行自定义安装和配置，在使用vscode的过程中发现终端输出控制台输出稳重会出现中文乱码的情况，网上搜索很多的解决方案都是修改系统的GBK，但是发现在修改了GBK以后可能会造成其他程序出现中文乱码以及其他的一些问题，这里我们使用修改PowerShell的OutputEncoding来解决这个问题。仅win10系统测试有效。","text":"vscode是现在较为流行的一款开发工具，他可以按照用户对应需要的语言插件进行自定义安装和配置，在使用vscode的过程中发现终端输出控制台输出稳重会出现中文乱码的情况，网上搜索很多的解决方案都是修改系统的GBK，但是发现在修改了GBK以后可能会造成其他程序出现中文乱码以及其他的一些问题，这里我们使用修改PowerShell的OutputEncoding来解决这个问题。仅win10系统测试有效。 正确方法： 1.打开 Windows PowerShell (管理员)，执行命令： Set-ExecutionPolicy Unrestricted 2.新建文档 profile.ps1 3.用记事本编辑，粘贴以下代码并保存： $OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = New-Object System.Text.UTF8Encoding 4.把 profile.ps1 保存到以下路径： C:\\Windows\\System32\\WindowsPowerShell\\v1.0 5.完成。 6.检测是否成功 打开 PowerShell，执行：chcp 结果为 Active code page: 65001，说明设置成功了","categories":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/categories/VsCode/"}],"tags":[{"name":"中文乱码","slug":"中文乱码","permalink":"https://www.odinsam.com/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/tags/VsCode/"}],"author":"odinsam"},{"title":"IdentityServer结合Mysql","slug":"IdentityServer结合Mysql","date":"2021-06-06T03:23:00.000Z","updated":"2021-06-09T05:36:28.000Z","comments":true,"path":"/articles/7094.html","link":"","permalink":"https://www.odinsam.com/articles/7094.html","excerpt":"IdentityServer4 是为 Asp.Net Core 2.0+ 系列量身打造的一款基于 OpenID Connect 和 OAuth 2.0 认证框架，官网提供了对应持久化到SQL Server数据库的方法。但是在持久化到Mysql数据库时，会出现 Specified key was too long 的错误。我们可以通过重写 OnModelCreating 方法的方式解决问题。","text":"IdentityServer4 是为 Asp.Net Core 2.0+ 系列量身打造的一款基于 OpenID Connect 和 OAuth 2.0 认证框架，官网提供了对应持久化到SQL Server数据库的方法。但是在持久化到Mysql数据库时，会出现 Specified key was too long 的错误。我们可以通过重写 OnModelCreating 方法的方式解决问题。 使用 MySql.EntityFrameworkCore ConfigureServices 添加代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041const string connectionString = @&quot;Server=ip;database=databasename;uid=userid;pwd=password;&quot;;var migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name;var mysqlVersion = new MySqlServerVersion(new Version(8, 0, 21));services.AddIdentityServer() .AddDeveloperSigningCredential() // 客户端和资源的数据库存储 // ConfigurationDbContext // dotnet ef migrations add ConfigDbContext -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfiguragtionDb // dotnet ef database update -c ConfigurationDbContext .AddConfigurationStore(opt =&gt; &#123; opt.ConfigureDbContext = context =&gt; &#123; context.UseMySQL(_Options.DbEntity.ConnectionString, sql =&gt; sql.MigrationsAssembly(migrationsAssembly)); &#125;; &#125;) // 令牌和授权码的数据库存储 // PersistedGrantDbContext // dotnet ef migrations add OperationContext -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/OperationDb // dotnet ef database update -c PersistedGrantDbContext .AddOperationalStore(opt =&gt; &#123; opt.ConfigureDbContext = context =&gt; context.UseMySQL(_Options.DbEntity.ConnectionString, sql =&gt; sql.MigrationsAssembly(migrationsAssembly)); opt.EnableTokenCleanup = true; opt.TokenCleanupInterval = 30; &#125;); services.AddIdentityServerDbContext&lt;ConfigurationDbContext&gt;(options =&gt; &#123; options.ConfigureDbContext = builder =&gt; builder.UseMySQL(_Options.DbEntity.ConnectionString, db =&gt; db.MigrationsAssembly(migrationsAssembly)); &#125;) .AddIdentityServerDbContext&lt;PersistedGrantDbContext&gt;(options =&gt; &#123; options.ConfigureDbContext = builder =&gt; builder.UseMySQL(_Options.DbEntity.ConnectionString, db =&gt; db.MigrationsAssembly(migrationsAssembly)); &#125;); // 更改Identity中关于用户和角色的处理到Entityframework // dotnet ef migrations add UserStoreContext -c OdinIdentityEntities -o Data/Migrations/IdentityServer/UserDb // dotnet ef database update -c OdinIdentityEntities &#125; 安装包如下 IdentityServer4 IdentityServer4.EntityFramework Microsoft.EntityFrameworkCore.Tools Microsoft.AspNet.Identity.EntityFramework Microsoft.EntityFrameworkCore IdentityServer4.AspNetIdentity 添加 ApplicationDbContext.cs、ApplicationUser.cs 和 ApplicationRole.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ApplicationDbContext : Microsoft.AspNetCore.Identity.EntityFrameworkCore.IdentityDbContext&lt;ApplicationUser, ApplicationRole, Guid&gt;&#123; public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options) &#123; &#125; public DbSet&lt;IdUser&gt; IdentityUsers &#123; get; set; &#125; public DbSet&lt;IdUser&gt; IdentityRoles &#123; get; set; &#125; public DbSet&lt;IdentityUserClaim&gt; IdentityUserClaim &#123; get; set; &#125; // 其他表 protected override void OnModelCreating(ModelBuilder builder) &#123; base.OnModelCreating(builder); // mysql 修改索引长度 解决 Specified key was too long; max key length is 3072 bytes builder.Entity(&quot;Microsoft.AspNetCore.Identity.IdentityRole&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;Id&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); builder.Entity(&quot;Microsoft.AspNetCore.Identity.IdentityUser&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;Id&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); builder.Entity(&quot;Microsoft.AspNetCore.Identity.IdentityUserLogin&lt;string&gt;&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;LoginProvider&quot;) .HasColumnType(&quot;varchar(256)&quot;); b.Property&lt;string&gt;(&quot;ProviderKey&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); builder.Entity(&quot;Microsoft.AspNetCore.Identity.IdentityUserToken&lt;string&gt;&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;LoginProvider&quot;) .HasColumnType(&quot;varchar(256)&quot;); b.Property&lt;string&gt;(&quot;Name&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); builder.Entity(&quot;OdinOIS.Models.DbModels.IdentityUserStore.IdentityUserClaim&quot;, b =&gt; &#123; b.Property&lt;string&gt;(&quot;ClaimId&quot;) .HasColumnType(&quot;varchar(256)&quot;); &#125;); &#125;&#125; 1234public class ApplicationUser : Microsoft.AspNetCore.Identity.IdentityUser&lt;Guid&gt;&#123; //可以在这里扩展&#125; 1234public class ApplicationRole : Microsoft.AspNetCore.Identity.IdentityRole&lt;Guid&gt;&#123;&#125; 控制台输入 dotnet ef migrations add ConfigDbContext -c ConfigurationDbContext -o Date\\Migrations\\IdentityServer\\ConfiguragtionDb dotnet ef database update ConfigDbContext -c ConfigurationDbContext dotnet ef migrations add ConfigDbContext -c PersistedGrantDbContext -o Date\\Migrations\\IdentityServer\\PersistedGrantDb dotnet ef database update ConfigDbContext -c PersistedGrantDbContext dotnet ef migrations add UserStoreContext -c OdinIdentityEntities -o Data/Migrations/IdentityServer/UserDb dotnet ef database update -c OdinIdentityEntities","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"https://www.odinsam.com/tags/IdentityServer4/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.odinsam.com/tags/Mysql/"},{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"}],"author":"odinsam"},{"title":"vscode无法使用nuget的小问题","slug":"vscode无法使用nuget的小问题","date":"2021-05-28T21:29:00.000Z","updated":"2021-07-06T15:01:28.000Z","comments":true,"path":"/articles/80b6.html","link":"","permalink":"https://www.odinsam.com/articles/80b6.html","excerpt":"在使用vscode的过程使用NuGet Package Manager插件安装Package包的时候会出现 &quot;Versioning information could not be retrieved from the NuGet package repository. &quot; 的错误导致无法安装Package包，可以修改fetchPackageVersions.js解决问题。","text":"在使用vscode的过程使用NuGet Package Manager插件安装Package包的时候会出现 &quot;Versioning information could not be retrieved from the NuGet package repository. &quot; 的错误导致无法安装Package包，可以修改fetchPackageVersions.js解决问题。 问题： “Versioning information could not be retrieved from the NuGet package repository. Please try again later.” 解决方式： 打开 /Users/用户名/.vscode/extensions/jmrog.vscode-nuget-package-manager-1.1.6/out/src/actions/add-methods/fetchPackageVersions.js 修改后的代码 加上 .toLowerCase() 1...node_fetch_1.default(`$&#123;versionsUrl&#125;$&#123;selectedPackageName.toLowerCase()&#125;/index.json`, utils_1.getFetchOptions(vscode.workspace.getConfiguration(&#x27;http&#x27;)))","categories":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/categories/VsCode/"}],"tags":[{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/tags/VsCode/"},{"name":"Nuget","slug":"Nuget","permalink":"https://www.odinsam.com/tags/Nuget/"}],"author":"odinsam"},{"title":"关于net core动态加载配置文件的小问题","slug":"关于net-core动态加载配置文件的小问题","date":"2021-05-27T13:57:00.000Z","updated":"2021-06-10T09:57:40.000Z","comments":true,"path":"/articles/8950.html","link":"","permalink":"https://www.odinsam.com/articles/8950.html","excerpt":"在我的项目当中配置文件较多，例如包括 项目自身的配置文件、consul.config、redis.cofing、identityServer.config 等等，要在项目启动的时候动态加载所有的配置文件。在我的项目中有 serverConfig 文件夹中有对应的所有的配置文件需要动态加载所有文件，在加载过程中发现按照文件路径无法加载 win10 环境。最后发现加载时不能使用绝对路径需要使用相对路径。","text":"在我的项目当中配置文件较多，例如包括 项目自身的配置文件、consul.config、redis.cofing、identityServer.config 等等，要在项目启动的时候动态加载所有的配置文件。在我的项目中有 serverConfig 文件夹中有对应的所有的配置文件需要动态加载所有文件，在加载过程中发现按照文件路径无法加载 win10 环境。最后发现加载时不能使用绝对路径需要使用相对路径。 需求场景: serverConfig 中有对应的一系列配置文件。其中 cnf.json 为主配置文件,里边有当前项目的运行环境的配置，还有其他的文件夹以及对应的其他的配置文件。 现在需要在Config Builder之前递归加载所有的配置文件。 问题: 在编码后运行发现，总是找不对对应的配置文件（win 10 环境），代码如下: 1234567891011121314151617181920public void LoadConfigFiles(string currentPath, IConfigurationBuilder config)&#123; foreach (var item in Directory.GetFiles(currentPath)) &#123; if (Path.GetFileName(item) != &quot;cnf.json&quot;) &#123; if (File.Exists(item)) config.Add(new JsonConfigurationSource &#123; Path = item, Optional = false, ReloadOnChange = true &#125;); &#125; &#125; var dir = Directory.GetDirectories(currentPath); if (dir != null &amp;&amp; dir.Length &gt; 0) &#123; foreach (var dirItem in dir) &#123; if (!Path.GetDirectoryName(dirItem).EndsWith(Path.Combine(FileHelper.DirectorySeparatorChar, &quot;envConfig&quot;))) LoadConfigFiles(dirItem, config); &#125; &#125;&#125; 代码总是报错，提示找不对config文件 解决: 最后发现 config.add 加载的文件路径需要是相对路径而不能是绝对路径，解决代码如下: 12345678910111213141516171819202122public void LoadConfigFiles(string currentPath, IConfigurationBuilder config, string rootPath)&#123; foreach (var item in Directory.GetFiles(currentPath)) &#123; if (Path.GetFileName(item) != &quot;cnf.json&quot;) &#123; var configPath = item.Replace(rootPath, &quot;&quot;); if (File.Exists(item)) config.Add(new JsonConfigurationSource &#123; Path = configPath, Optional = false, ReloadOnChange = true &#125;); //config.add 加载的文件 路径需要是相对路径 而不能是绝对路径 &#125; &#125; var dir = Directory.GetDirectories(currentPath); if (dir != null &amp;&amp; dir.Length &gt; 0) &#123; foreach (var dirItem in dir) &#123; if (!Path.GetDirectoryName(dirItem).EndsWith(Path.Combine(FileHelper.DirectorySeparatorChar, &quot;envConfig&quot;))) LoadConfigFiles(dirItem, config, rootPath); &#125; &#125;&#125;","categories":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"}],"tags":[{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"}],"author":"odinsam"}],"categories":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/categories/vue/"},{"name":"前端","slug":"vue/前端","permalink":"https://www.odinsam.com/categories/vue/%E5%89%8D%E7%AB%AF/"},{"name":"macos","slug":"macos","permalink":"https://www.odinsam.com/categories/macos/"},{"name":"杂项","slug":"macos/杂项","permalink":"https://www.odinsam.com/categories/macos/%E6%9D%82%E9%A1%B9/"},{"name":"mysql","slug":"mysql","permalink":"https://www.odinsam.com/categories/mysql/"},{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/categories/Net-Core/"},{"name":"Git","slug":"Git","permalink":"https://www.odinsam.com/categories/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.odinsam.com/categories/Hexo/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/categories/VsCode/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.odinsam.com/tags/vue/"},{"name":"props","slug":"props","permalink":"https://www.odinsam.com/tags/props/"},{"name":"nextTick","slug":"nextTick","permalink":"https://www.odinsam.com/tags/nextTick/"},{"name":"消息订阅","slug":"消息订阅","permalink":"https://www.odinsam.com/tags/%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85/"},{"name":"消息发布","slug":"消息发布","permalink":"https://www.odinsam.com/tags/%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83/"},{"name":"subscribe","slug":"subscribe","permalink":"https://www.odinsam.com/tags/subscribe/"},{"name":"unsubscribe","slug":"unsubscribe","permalink":"https://www.odinsam.com/tags/unsubscribe/"},{"name":"publish","slug":"publish","permalink":"https://www.odinsam.com/tags/publish/"},{"name":"pubsub-js","slug":"pubsub-js","permalink":"https://www.odinsam.com/tags/pubsub-js/"},{"name":"eventbus","slug":"eventbus","permalink":"https://www.odinsam.com/tags/eventbus/"},{"name":"全局事件总线","slug":"全局事件总线","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"},{"name":"mounted","slug":"mounted","permalink":"https://www.odinsam.com/tags/mounted/"},{"name":"emit","slug":"emit","permalink":"https://www.odinsam.com/tags/emit/"},{"name":"on","slug":"on","permalink":"https://www.odinsam.com/tags/on/"},{"name":"off","slug":"off","permalink":"https://www.odinsam.com/tags/off/"},{"name":"refs","slug":"refs","permalink":"https://www.odinsam.com/tags/refs/"},{"name":"localStorage","slug":"localStorage","permalink":"https://www.odinsam.com/tags/localStorage/"},{"name":"sessionStorage","slug":"sessionStorage","permalink":"https://www.odinsam.com/tags/sessionStorage/"},{"name":"本地存储","slug":"本地存储","permalink":"https://www.odinsam.com/tags/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"},{"name":"webStorage","slug":"webStorage","permalink":"https://www.odinsam.com/tags/webStorage/"},{"name":"style","slug":"style","permalink":"https://www.odinsam.com/tags/style/"},{"name":"less","slug":"less","permalink":"https://www.odinsam.com/tags/less/"},{"name":"scoped","slug":"scoped","permalink":"https://www.odinsam.com/tags/scoped/"},{"name":"全局指令","slug":"全局指令","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4/"},{"name":"directive","slug":"directive","permalink":"https://www.odinsam.com/tags/directive/"},{"name":"filter","slug":"filter","permalink":"https://www.odinsam.com/tags/filter/"},{"name":"全局过滤器","slug":"全局过滤器","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"mixin","slug":"mixin","permalink":"https://www.odinsam.com/tags/mixin/"},{"name":"全局混入","slug":"全局混入","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5/"},{"name":"全局混合","slug":"全局混合","permalink":"https://www.odinsam.com/tags/%E5%85%A8%E5%B1%80%E6%B7%B7%E5%90%88/"},{"name":"插件","slug":"插件","permalink":"https://www.odinsam.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"plugin","slug":"plugin","permalink":"https://www.odinsam.com/tags/plugin/"},{"name":"混入","slug":"混入","permalink":"https://www.odinsam.com/tags/%E6%B7%B7%E5%85%A5/"},{"name":"混合","slug":"混合","permalink":"https://www.odinsam.com/tags/%E6%B7%B7%E5%90%88/"},{"name":"ref","slug":"ref","permalink":"https://www.odinsam.com/tags/ref/"},{"name":"cli","slug":"cli","permalink":"https://www.odinsam.com/tags/cli/"},{"name":"component","slug":"component","permalink":"https://www.odinsam.com/tags/component/"},{"name":"prototype","slug":"prototype","permalink":"https://www.odinsam.com/tags/prototype/"},{"name":"__proto__","slug":"proto","permalink":"https://www.odinsam.com/tags/proto/"},{"name":"嵌套","slug":"嵌套","permalink":"https://www.odinsam.com/tags/%E5%B5%8C%E5%A5%97/"},{"name":"生命周期","slug":"生命周期","permalink":"https://www.odinsam.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"挂载","slug":"挂载","permalink":"https://www.odinsam.com/tags/%E6%8C%82%E8%BD%BD/"},{"name":"销毁","slug":"销毁","permalink":"https://www.odinsam.com/tags/%E9%94%80%E6%AF%81/"},{"name":"更新","slug":"更新","permalink":"https://www.odinsam.com/tags/%E6%9B%B4%E6%96%B0/"},{"name":"beforeCreate","slug":"beforeCreate","permalink":"https://www.odinsam.com/tags/beforeCreate/"},{"name":"created","slug":"created","permalink":"https://www.odinsam.com/tags/created/"},{"name":"beforeMount","slug":"beforeMount","permalink":"https://www.odinsam.com/tags/beforeMount/"},{"name":"beforeUpdate","slug":"beforeUpdate","permalink":"https://www.odinsam.com/tags/beforeUpdate/"},{"name":"update","slug":"update","permalink":"https://www.odinsam.com/tags/update/"},{"name":"beforeDestroy","slug":"beforeDestroy","permalink":"https://www.odinsam.com/tags/beforeDestroy/"},{"name":"destroyed","slug":"destroyed","permalink":"https://www.odinsam.com/tags/destroyed/"},{"name":"filters","slug":"filters","permalink":"https://www.odinsam.com/tags/filters/"},{"name":"过滤器","slug":"过滤器","permalink":"https://www.odinsam.com/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"v-model","slug":"v-model","permalink":"https://www.odinsam.com/tags/v-model/"},{"name":"value","slug":"value","permalink":"https://www.odinsam.com/tags/value/"},{"name":"vue.set","slug":"vue-set","permalink":"https://www.odinsam.com/tags/vue-set/"},{"name":"指令","slug":"指令","permalink":"https://www.odinsam.com/tags/%E6%8C%87%E4%BB%A4/"},{"name":"directives","slug":"directives","permalink":"https://www.odinsam.com/tags/directives/"},{"name":"v-text","slug":"v-text","permalink":"https://www.odinsam.com/tags/v-text/"},{"name":"v-html","slug":"v-html","permalink":"https://www.odinsam.com/tags/v-html/"},{"name":"v-cloak","slug":"v-cloak","permalink":"https://www.odinsam.com/tags/v-cloak/"},{"name":"v-once","slug":"v-once","permalink":"https://www.odinsam.com/tags/v-once/"},{"name":"v-pre","slug":"v-pre","permalink":"https://www.odinsam.com/tags/v-pre/"},{"name":"v-show","slug":"v-show","permalink":"https://www.odinsam.com/tags/v-show/"},{"name":"v-if","slug":"v-if","permalink":"https://www.odinsam.com/tags/v-if/"},{"name":"v-else-if","slug":"v-else-if","permalink":"https://www.odinsam.com/tags/v-else-if/"},{"name":"v-else","slug":"v-else","permalink":"https://www.odinsam.com/tags/v-else/"},{"name":"v-for","slug":"v-for","permalink":"https://www.odinsam.com/tags/v-for/"},{"name":"key","slug":"key","permalink":"https://www.odinsam.com/tags/key/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://www.odinsam.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"name":"class","slug":"class","permalink":"https://www.odinsam.com/tags/class/"},{"name":"watch","slug":"watch","permalink":"https://www.odinsam.com/tags/watch/"},{"name":"keydown","slug":"keydown","permalink":"https://www.odinsam.com/tags/keydown/"},{"name":"keyup","slug":"keyup","permalink":"https://www.odinsam.com/tags/keyup/"},{"name":"prevent","slug":"prevent","permalink":"https://www.odinsam.com/tags/prevent/"},{"name":"stop","slug":"stop","permalink":"https://www.odinsam.com/tags/stop/"},{"name":"once","slug":"once","permalink":"https://www.odinsam.com/tags/once/"},{"name":"capture","slug":"capture","permalink":"https://www.odinsam.com/tags/capture/"},{"name":"self","slug":"self","permalink":"https://www.odinsam.com/tags/self/"},{"name":"passive","slug":"passive","permalink":"https://www.odinsam.com/tags/passive/"},{"name":"v-on","slug":"v-on","permalink":"https://www.odinsam.com/tags/v-on/"},{"name":"@click","slug":"click","permalink":"https://www.odinsam.com/tags/click/"},{"name":"原型链","slug":"原型链","permalink":"https://www.odinsam.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"mvvm","slug":"mvvm","permalink":"https://www.odinsam.com/tags/mvvm/"},{"name":"ViewModel","slug":"ViewModel","permalink":"https://www.odinsam.com/tags/ViewModel/"},{"name":"view","slug":"view","permalink":"https://www.odinsam.com/tags/view/"},{"name":"el","slug":"el","permalink":"https://www.odinsam.com/tags/el/"},{"name":"data","slug":"data","permalink":"https://www.odinsam.com/tags/data/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://www.odinsam.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"name":"v-bind","slug":"v-bind","permalink":"https://www.odinsam.com/tags/v-bind/"},{"name":"插值语法","slug":"插值语法","permalink":"https://www.odinsam.com/tags/%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95/"},{"name":"mysql","slug":"mysql","permalink":"https://www.odinsam.com/tags/mysql/"},{"name":"链路追踪","slug":"链路追踪","permalink":"https://www.odinsam.com/tags/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"},{"name":"ApiLinkMonitor","slug":"ApiLinkMonitor","permalink":"https://www.odinsam.com/tags/ApiLinkMonitor/"},{"name":".Net Core","slug":"Net-Core","permalink":"https://www.odinsam.com/tags/Net-Core/"},{"name":"微服务","slug":"微服务","permalink":"https://www.odinsam.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"BackgroundService","slug":"BackgroundService","permalink":"https://www.odinsam.com/tags/BackgroundService/"},{"name":"后台服务","slug":"后台服务","permalink":"https://www.odinsam.com/tags/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/"},{"name":"Mapster","slug":"Mapster","permalink":"https://www.odinsam.com/tags/Mapster/"},{"name":"VsCode","slug":"VsCode","permalink":"https://www.odinsam.com/tags/VsCode/"},{"name":"Git","slug":"Git","permalink":"https://www.odinsam.com/tags/Git/"},{"name":"SqlSugar","slug":"SqlSugar","permalink":"https://www.odinsam.com/tags/SqlSugar/"},{"name":"Cap","slug":"Cap","permalink":"https://www.odinsam.com/tags/Cap/"},{"name":"HttpClientFactory","slug":"HttpClientFactory","permalink":"https://www.odinsam.com/tags/HttpClientFactory/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.odinsam.com/tags/Hexo/"},{"name":"Seo","slug":"Seo","permalink":"https://www.odinsam.com/tags/Seo/"},{"name":"Pure","slug":"Pure","permalink":"https://www.odinsam.com/tags/Pure/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.odinsam.com/tags/Mysql/"},{"name":"Canal","slug":"Canal","permalink":"https://www.odinsam.com/tags/Canal/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://www.odinsam.com/tags/RabbitMQ/"},{"name":"Serilog","slug":"Serilog","permalink":"https://www.odinsam.com/tags/Serilog/"},{"name":"Log","slug":"Log","permalink":"https://www.odinsam.com/tags/Log/"},{"name":"中文乱码","slug":"中文乱码","permalink":"https://www.odinsam.com/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"},{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"https://www.odinsam.com/tags/IdentityServer4/"},{"name":"Nuget","slug":"Nuget","permalink":"https://www.odinsam.com/tags/Nuget/"}]}